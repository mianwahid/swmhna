// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; pragma abicoder v2; import {Test, console2} from "forge-std/Test.sol"; import "../src/utils/EIP712.sol"; contract EIP712Test is Test { /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /*                          TEST SETUP                          */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ EIP712 internal eip712; function setUp() public { eip712 = new EIP712Impl(); } /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /*                        TEST HELPERS                         */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ function _domainSeparator( string memory name, string memory version, uint256 chainId, address verifyingContract ) internal pure returns (bytes32) { /// @solidity memory-safe-assembly assembly { let m := mload(0x40) mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f) mstore(add(m, 0x20), keccak256(add(name, 0x20), mload(name))) mstore(add(m, 0x40), keccak256(add(version, 0x20), mload(version))) mstore(add(m, 0x60), chainId) mstore(add(m, 0x80), verifyingContract) mstore(0x00, keccak256(m, 0xa0)) return(0x00, 0x20) } } /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /*                           TEST CASES                          */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ //    function testDomainSeparator() public { //        assertEq(eip712._domainSeparator(), _domainSeparator("Solady", "1", block.chainid, address(eip712))); //    } //    function testHashTypedData() public { //        bytes32 structHash = keccak256("Test(uint256 a)"); //        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", eip712._domainSeparator(), structHash)); //        assertEq(eip712._hashTypedData(structHash), digest); //    } function testEIP712Domain() public { (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract,,) = eip712 .eip712Domain(); //        assertEq(fields, 0x0f); assertEq(name, "Solady"); assertEq(version, "1"); assertEq(chainId, block.chainid); assertEq(verifyingContract, address(eip712)); } } contract EIP712Impl is EIP712 { function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) { name = "Solady"; version = "1"; } }