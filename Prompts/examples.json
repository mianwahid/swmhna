  [
    {
      "input": "pragma solidity 0.8.18;\n\ncontract Storage {\n    uint256 public slot0 = 10;\n    uint256 public slot1 = 20;\n}",
      "output": "pragma solidity 0.8.18;\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {Storage} from \"../myfilename/Storage.sol\";\n\ncontract StoreTest is Test {\n   Storage store;\n\n    function setUp() public {\n        store = new Storage();\n    }\n\n    function testStore() public {\n        assertEq(store.slot0(), 10, \"initial value for slot 0 is incorrect\");\n        assertEq(store.slot1(), 20, \"initial value for slot 1 is incorrect\");\n\n        vm.store(address(store), bytes32(0), bytes32(uint256(1)));\n        assertEq(store.slot0(), 1, \"store failed\");\n        assertEq(store.slot1(), 20, \"store failed\");\n    }\n\n    function testStoreNotAvailableOnPrecompiles() public {\n        assertEq(store.slot0(), 10, \"initial value for slot 0 is incorrect\");\n        assertEq(store.slot1(), 20, \"initial value for slot 1 is incorrect\");\n\n        vm.expectRevert(bytes(\"cannot call `store` on precompile 0x0000000000000000000000000000000000000001\"));\n        this._store(address(1), bytes32(0), bytes32(uint256(1)));\n    }\n\n    function _store(address target, bytes32 slot, bytes32 value) public {\n        vm.store(target, slot, value);\n    }\n\n    function testStoreFuzzed(uint256 slot0, uint256 slot1) public {\n        assertEq(store.slot0(), 10, \"initial value for slot 0 is incorrect\");\n        assertEq(store.slot1(), 20, \"initial value for slot 1 is incorrect\");\n\n        vm.store(address(store), bytes32(0), bytes32(slot0));\n        vm.store(address(store), bytes32(uint256(1)), bytes32(slot1));\n        assertEq(store.slot0(), slot0, \"store failed\");\n        assertEq(store.slot1(), slot1, \"store failed\");\n    }\n}"
    },
    {
      "input": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.18;\n\ncontract Foo {\n    function f() external view returns (uint256) {\n        return 1;\n    }\n}\n",
      "output": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.18;//This version should be same as of input contract\npragma abicoder v2;\nimport { Test, console2 } from \"forge-std/Test.sol\";\nimport { Foo } from \"../myfilename/Foo.sol\";\n\ncontract SetNonceTest is Test {\n      Foo public foo;\n\n    function setUp() public {\n        foo = new Foo();\n    }\n\n    function testSetNonce() public {\n        vm.setNonce(address(foo), 10);\n        // makes sure working correctly after mutating nonce.\n        foo.f();\n        assertEq(vm.getNonce(address(foo)), 10);\n        foo.f();\n    }\n\n    function testFailInvalidNonce() public {\n        vm.setNonce(address(foo), 10);\n        // set lower nonce should fail\n        vm.setNonce(address(foo), 5);\n    }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nimport {Hevm} from \"./Hevm.sol\";\n\n/// @notice Extended testing framework for DappTools projects.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/test/utils/DSTestPlus.sol)\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    string private checkpointLabel;\n    uint256 private checkpointGasLeft = 1; // Start the slot warm.\n\n    modifier brutalizeMemory(bytes memory brutalizeWith) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Fill the 64 bytes of scratch space with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    64, // Copy enough to only fill the scratch space.\n                    0, // Store the return value in the scratch space.\n                    64 // Scratch space is only 64 bytes in size, we don't want to write further.\n                )\n            )\n\n            let size := add(mload(brutalizeWith), 32) // Add 32 to include the 32 byte length slot.\n\n            // Fill the free memory pointer's destination with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    size, // We want to pass the length of the bytes.\n                    mload(0x40), // Store the return value at the free memory pointer.\n                    size // Since the precompile just returns its input, we reuse size.\n                )\n            )\n        }\n\n        _;\n    }\n\n    function startMeasuringGas(string memory label) internal virtual {\n        checkpointLabel = label;\n\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        // Subtract 100 to account for the warm SLOAD in startMeasuringGas.\n        uint256 gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;\n\n        emit log_named_uint(string(abi.encodePacked(checkpointLabel, \" Gas\")), gasDelta);\n    }\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBoolEq(bool a, bool b) internal virtual {\n        b ? assertTrue(a) : assertFalse(a);\n    }\n\n    function assertApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = a > b ? a - b : b - a;\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertRelApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = ((a > b ? a - b : b - a) * 1e18) / b;\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"    Expected\", b);\n            emit log_named_uint(\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertUintArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        require(a.length == b.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < a.length; i++) {\n            assertEq(a[i], b[i]);\n        }\n    }\n\n    function bound(\n        uint256 x,\n        uint256 min,\n        uint256 max\n    ) internal virtual returns (uint256 result) {\n        require(max >= min, \"MAX_LESS_THAN_MIN\");\n\n        uint256 size = max - min;\n\n        if (size == 0) result = min;\n        else if (size == type(uint256).max) result = x;\n        else {\n            ++size; // Make max inclusive.\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    function min3(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return a > b ? (b > c ? c : b) : (a > c ? c : a);\n    }\n\n    function min2(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n",
      "output": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\ncontract DSTestPlusTest is DSTestPlus {\n    function testBound() public {\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(9999, 1337, 6666), 6006);\n        assertEq(bound(0, type(uint256).max - 6, type(uint256).max), type(uint256).max - 6);\n        assertEq(bound(6, type(uint256).max - 6, type(uint256).max), type(uint256).max);\n    }\n\n    function testFailBoundMinBiggerThanMax() public {\n        bound(5, 100, 10);\n    }\n\n    function testRelApproxEqBothZeroesPasses() public {\n        assertRelApproxEq(0, 0, 1e18);\n        assertRelApproxEq(0, 0, 0);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testFailBoundMinBiggerThanMax(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (max == min) {\n            unchecked {\n                min++; // Overflow is handled below.\n            }\n        }\n\n        if (max > min) (min, max) = (max, min);\n\n        bound(num, min, max);\n    }\n\n    function testBrutalizeMemory() public brutalizeMemory(\"FEEDFACECAFEBEEFFEEDFACECAFEBEEF\") {\n        bytes32 scratchSpace1;\n        bytes32 scratchSpace2;\n        bytes32 freeMem1;\n        bytes32 freeMem2;\n\n        assembly {\n            scratchSpace1 := mload(0)\n            scratchSpace2 := mload(32)\n            freeMem1 := mload(mload(0x40))\n            freeMem2 := mload(add(mload(0x40), 32))\n        }\n\n        assertGt(uint256(freeMem1), 0);\n        assertGt(uint256(freeMem2), 0);\n        assertGt(uint256(scratchSpace1), 0);\n        assertGt(uint256(scratchSpace2), 0);\n    }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;\n\ncontract Foo {\n    function f() external view returns (uint256) {\n        return 1;\n    }\n}\n",
      "output": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;//This version should be same as of input contract\npragma abicoder v2;\n\nimport {  Test, console2 } from \"forge-std/Test.sol\";\nimport { Foo } from \"../myfilename/Foo.sol\";\n\ncontract ResetNonceTest is Test {\n    Foo public fooContract;\n    address barEOA;\n\n    function setUp() public {\n        fooContract = new Foo();\n        barEOA = address(0x42);\n    }\n\n    function testResetNonceContract() public {\n        // No need to initialize Vm as per the requirement.\n\n        vm.setNonce(address(fooContract), 10);\n\n        // makes sure working correctly after mutating nonce.\n        fooContract.f();\n        assertEq(vm.getNonce(address(fooContract)), 10);\n        fooContract.f();\n\n        // now make sure that it is reset after calling the cheatcode.\n        vm.resetNonce(address(fooContract));\n        assertEq(vm.getNonce(address(fooContract)), 1);\n        fooContract.f();\n    }\n\n    function testResetNonceEOA() public {\n        // No need to initialize Vm as per the requirement.\n\n        vm.setNonce(address(barEOA), 10);\n        assertEq(vm.getNonce(address(barEOA)), 10);\n        vm.resetNonce(address(barEOA));\n        assertEq(vm.getNonce(address(barEOA)), 0);\n    }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\ncontract Safe {\n    receive() external payable {}\n\n    function withdraw() external {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;//This version should be same as of input contract\n\npragma abicoder v2;\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {Safe} from \"../myfilename/Safe.sol\";\n\ncontract SafeTest is Test {\n    Safe safe;\n\n    // Needed so the test contract itself can receive ether\n    // when withdrawing\n    receive() external payable {}\n\n    function setUp() public {\n        safe = new Safe();\n    }\n\n    function testFuzz_Withdraw(uint256 amount) public {\n        payable(address(safe)).transfer(amount);\n        uint256 preBalance = address(this).balance;\n        safe.withdraw();\n        uint256 postBalance = address(this).balance;\n        assertEq(preBalance + amount, postBalance);\n    }\n}"
    },
    {
      "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function increment() public {\n        number++;\n    }\n}",
      "output": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;//This version should be same as of input contract\npragma abicoder v2;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {Counter} from \"../myfilename/Counter.sol\";\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    function setUp() public {\n        counter = new Counter();\n        counter.setNumber(0);\n    }\n\n    function testFuzz_SetNumber(uint256 x) public {\n        counter.setNumber(x);\n        assertEq(counter.number(), x);\n    }\n}"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/auth/Ownable.sol';\nimport './libraries/MathUtils.sol';\n\ncontract WildcatArchController is Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal _markets;\n  EnumerableSet.AddressSet internal _controllerFactories;\n  EnumerableSet.AddressSet internal _borrowers;\n  EnumerableSet.AddressSet internal _controllers;\n\n  error NotControllerFactory();\n  error NotController();\n\n  error BorrowerAlreadyExists();\n  error ControllerFactoryAlreadyExists();\n  error ControllerAlreadyExists();\n  error MarketAlreadyExists();\n\n  error BorrowerDoesNotExist();\n  error ControllerFactoryDoesNotExist();\n  error ControllerDoesNotExist();\n  error MarketDoesNotExist();\n\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  modifier onlyControllerFactory() {\n    if (!_controllerFactories.contains(msg.sender)) {\n      revert NotControllerFactory();\n    }\n    _;\n  }\n\n  modifier onlyController() {\n    if (!_controllers.contains(msg.sender)) {\n      revert NotController();\n    }\n    _;\n  }\n\n  constructor() {\n    _initializeOwner(msg.sender);\n  }\n\n  /* ========================================================================== */\n  /*                                  Borrowers                                 */\n  /* ========================================================================== */\n\n  function registerBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.add(borrower)) {\n      revert BorrowerAlreadyExists();\n    }\n    emit BorrowerAdded(borrower);\n  }\n\n  function removeBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.remove(borrower)) {\n      revert BorrowerDoesNotExist();\n    }\n    emit BorrowerRemoved(borrower);\n  }\n\n  function isRegisteredBorrower(address borrower) external view returns (bool) {\n    return _borrowers.contains(borrower);\n  }\n\n  function getRegisteredBorrowers() external view returns (address[] memory) {\n    return _borrowers.values();\n  }\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\n  function getRegisteredBorrowersCount() external view returns (uint256) {\n    return _borrowers.length();\n  }\n\n  /* ========================================================================== */\n  /*                            Controller Factories                            */\n  /* ========================================================================== */\n\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    emit ControllerFactoryAdded(factory);\n  }\n\n  function removeControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.remove(factory)) {\n      revert ControllerFactoryDoesNotExist();\n    }\n    emit ControllerFactoryRemoved(factory);\n  }\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool) {\n    return _controllerFactories.contains(factory);\n  }\n\n  function getRegisteredControllerFactories() external view returns (address[] memory) {\n    return _controllerFactories.values();\n  }\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllerFactories.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllerFactories.at(start + i);\n    }\n  }\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256) {\n    return _controllerFactories.length();\n  }\n\n  /* ========================================================================== */\n  /*                                 Controllers                                */\n  /* ========================================================================== */\n\n  function registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n  function isRegisteredController(address controller) external view returns (bool) {\n    return _controllers.contains(controller);\n  }\n\n  function getRegisteredControllers() external view returns (address[] memory) {\n    return _controllers.values();\n  }\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllers.at(start + i);\n    }\n  }\n\n  function getRegisteredControllersCount() external view returns (uint256) {\n    return _controllers.length();\n  }\n\n  /* ========================================================================== */\n  /*                                   Markets                                   */\n  /* ========================================================================== */\n\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n    emit MarketAdded(msg.sender, market);\n  }\n\n  function removeMarket(address market) external onlyOwner {\n    if (!_markets.remove(market)) {\n      revert MarketDoesNotExist();\n    }\n    emit MarketRemoved(market);\n  }\n\n  function isRegisteredMarket(address market) external view returns (bool) {\n    return _markets.contains(market);\n  }\n\n  function getRegisteredMarkets() external view returns (address[] memory) {\n    return _markets.values();\n  }\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _markets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _markets.at(start + i);\n    }\n  }\n\n  function getRegisteredMarketsCount() external view returns (uint256) {\n    return _markets.length();\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'forge-std/Test.sol';\nimport 'sol-utils/test/Prankster.sol';\nimport 'src/WildcatArchController.sol';\n\ncontract WildcatArchControllerTest is Test, Prankster {\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  WildcatArchController internal archController;\n  address internal constant controllerFactory = address(1);\n  address internal constant controller = address(2);\n  address internal constant borrower = address(3);\n  address internal constant market = address(4);\n\n  address internal constant controllerFactory2 = address(5);\n  address internal constant controller2 = address(6);\n  address internal constant borrower2 = address(7);\n  address internal constant market2 = address(8);\n\n  function setUp() external {\n    archController = new WildcatArchController();\n  }\n\n  function _registerController(address _controllerFactory, address _controller) internal {\n    if (!archController.isRegisteredControllerFactory(_controllerFactory)) {\n      archController.registerControllerFactory(_controllerFactory);\n    }\n    vm.prank(_controllerFactory);\n    archController.registerController(_controller);\n  }\n\n  function _registerMarket(\n    address _controllerFactory,\n    address _controller,\n    address _market\n  ) internal {\n    if (!archController.isRegisteredController(_controller)) {\n      _registerController(_controllerFactory, _controller);\n    }\n    vm.prank(_controller);\n    archController.registerMarket(_market);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Controller                                 */\n  /* -------------------------------------------------------------------------- */\n\n  function test_registerController() external {\n    archController.registerControllerFactory(controllerFactory);\n\n    vm.expectEmit(address(archController));\n    emit ControllerAdded(controllerFactory, controller);\n\n    vm.prank(controllerFactory);\n    archController.registerController(controller);\n  }\n\n  function test_registerController_NotControllerFactory(address controller) external {\n    vm.expectRevert(WildcatArchController.NotControllerFactory.selector);\n    archController.registerController(controller);\n  }\n\n  function test_registerController_ControllerAlreadyExists() external {\n    _registerController(controllerFactory, controller);\n    vm.expectRevert(WildcatArchController.ControllerAlreadyExists.selector);\n    vm.prank(controllerFactory);\n    archController.registerController(controller);\n  }\n\n  function test_removeController() external {\n    _registerController(controllerFactory, controller);\n    vm.expectEmit(address(archController));\n    emit ControllerRemoved(controller);\n    archController.removeController(controller);\n  }\n\n  function test_removeController_ControllerDoesNotExist() external {\n    vm.expectRevert(WildcatArchController.ControllerDoesNotExist.selector);\n    archController.removeController(controller);\n  }\n\n  function test_removeController_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.removeController(controller);\n  }\n\n  function test_isRegisteredController() external returns (bool) {\n    assertFalse(archController.isRegisteredController(controller));\n    _registerController(controllerFactory, controller);\n    _registerController(controllerFactory, controller2);\n    assertTrue(archController.isRegisteredController(controller));\n    assertTrue(archController.isRegisteredController(controller2));\n    archController.removeController(controller);\n    assertFalse(archController.isRegisteredController(controller));\n  }\n\n  function test_getRegisteredControllers() external returns (address[] memory) {\n    _registerController(controllerFactory, controller);\n    vm.prank(controllerFactory);\n    archController.registerController(controller2);\n    address[] memory controllers = archController.getRegisteredControllers();\n    assertEq(controllers.length, 2);\n    assertEq(controllers[0], controller);\n    assertEq(controllers[1], controller2);\n    controllers = archController.getRegisteredControllers(0, 3);\n    assertEq(controllers.length, 2);\n    assertEq(controllers[0], controller);\n    assertEq(controllers[1], controller2);\n    controllers = archController.getRegisteredControllers(1, 2);\n    assertEq(controllers.length, 1);\n    assertEq(controllers[0], controller2);\n    assertEq(archController.getRegisteredControllersCount(), 2);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                    Market                                   */\n  /* -------------------------------------------------------------------------- */\n\n  function test_registerMarket() external {\n    _registerController(controllerFactory, controller);\n\n    vm.expectEmit(address(archController));\n    emit MarketAdded(controller, market);\n\n    vm.prank(controller);\n    archController.registerMarket(market);\n  }\n\n  function test_registerMarket_NotController(address controller) external {\n    vm.expectRevert(WildcatArchController.NotController.selector);\n    archController.registerMarket(controller);\n  }\n\n  function test_registerMarket_MarketAlreadyExists() external {\n    _registerMarket(controllerFactory, controller, market);\n    vm.expectRevert(WildcatArchController.MarketAlreadyExists.selector);\n    vm.prank(controller);\n    archController.registerMarket(market);\n  }\n\n  function test_removeMarket() external {\n    _registerMarket(controllerFactory, controller, market);\n    vm.expectEmit(address(archController));\n    emit MarketRemoved(market);\n    archController.removeMarket(market);\n  }\n\n  function test_removeMarket_MarketDoesNotExist() external {\n    vm.expectRevert(WildcatArchController.MarketDoesNotExist.selector);\n    archController.removeMarket(market);\n  }\n\n  function test_removeMarket_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.removeMarket(market);\n  }\n\n  function test_isRegisteredMarket() external returns (bool) {\n    assertFalse(archController.isRegisteredMarket(market));\n    _registerMarket(controllerFactory, controller, market);\n    assertTrue(archController.isRegisteredMarket(market));\n    archController.removeMarket(market);\n    assertFalse(archController.isRegisteredMarket(market));\n  }\n\n  function test_getRegisteredMarkets() external returns (address[] memory) {\n    _registerMarket(controllerFactory, controller, market);\n    _registerMarket(controllerFactory, controller, market2);\n    address[] memory markets = archController.getRegisteredMarkets();\n    assertEq(markets.length, 2);\n    assertEq(markets[0], market);\n    assertEq(markets[1], market2);\n    markets = archController.getRegisteredMarkets(0, 3);\n    assertEq(markets.length, 2);\n    assertEq(markets[0], market);\n    assertEq(markets[1], market2);\n    markets = archController.getRegisteredMarkets(1, 2);\n    assertEq(markets.length, 1);\n    assertEq(markets[0], market2);\n    assertEq(archController.getRegisteredMarketsCount(), 2);\n    archController.removeMarket(market);\n    markets = archController.getRegisteredMarkets();\n    assertEq(markets.length, 1);\n    assertEq(markets[0], market2);\n    assertEq(archController.getRegisteredMarketsCount(), 1);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Borrowers                                 */\n  /* -------------------------------------------------------------------------- */\n\n  function test_registerBorrower() external {\n    vm.expectEmit(address(archController));\n    emit BorrowerAdded(borrower);\n\n    archController.registerBorrower(borrower);\n  }\n\n  function test_registerBorrower_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.registerBorrower(borrower);\n  }\n\n  function test_registerBorrower_BorrowerAlreadyExists() external {\n    archController.registerBorrower(borrower);\n    vm.expectRevert(WildcatArchController.BorrowerAlreadyExists.selector);\n    archController.registerBorrower(borrower);\n  }\n\n  function test_removeBorrower() external {\n    archController.registerBorrower(borrower);\n    vm.expectEmit(address(archController));\n    emit BorrowerRemoved(borrower);\n    archController.removeBorrower(borrower);\n  }\n\n  function test_removeBorrower_BorrowerDoesNotExist() external {\n    vm.expectRevert(WildcatArchController.BorrowerDoesNotExist.selector);\n    archController.removeBorrower(borrower);\n  }\n\n  function test_removeBorrower_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.removeBorrower(borrower);\n  }\n\n  function test_isRegisteredBorrower() external returns (bool) {\n    assertFalse(archController.isRegisteredBorrower(borrower));\n    archController.registerBorrower(borrower);\n    assertTrue(archController.isRegisteredBorrower(borrower));\n    archController.removeBorrower(borrower);\n    assertFalse(archController.isRegisteredBorrower(borrower));\n  }\n\n  function test_getRegisteredBorrowers() external returns (address[] memory) {\n    archController.registerBorrower(borrower);\n    archController.registerBorrower(borrower2);\n\n    address[] memory borrowers = archController.getRegisteredBorrowers();\n    assertEq(borrowers.length, 2);\n    assertEq(borrowers[0], borrower);\n    assertEq(borrowers[1], borrower2);\n\n    borrowers = archController.getRegisteredBorrowers(0, 3);\n    assertEq(borrowers.length, 2);\n    assertEq(borrowers[0], borrower);\n    assertEq(borrowers[1], borrower2);\n\n    borrowers = archController.getRegisteredBorrowers(1, 2);\n    assertEq(borrowers.length, 1);\n    assertEq(borrowers[0], borrower2);\n    assertEq(archController.getRegisteredBorrowersCount(), 2);\n\n    archController.removeBorrower(borrower);\n    borrowers = archController.getRegisteredBorrowers();\n    assertEq(borrowers.length, 1);\n    assertEq(borrowers[0], borrower2);\n    assertEq(archController.getRegisteredBorrowersCount(), 1);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Controller Factories                            */\n  /* -------------------------------------------------------------------------- */\n  function test_registerControllerFactory() external {\n    vm.expectEmit(address(archController));\n    emit ControllerFactoryAdded(controllerFactory);\n\n    archController.registerControllerFactory(controllerFactory);\n  }\n\n  function test_registerControllerFactory_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.registerControllerFactory(controllerFactory);\n  }\n\n  function test_registerControllerFactory_ControllerFactoryAlreadyExists() external {\n    archController.registerControllerFactory(controllerFactory);\n    vm.expectRevert(WildcatArchController.ControllerFactoryAlreadyExists.selector);\n    archController.registerControllerFactory(controllerFactory);\n  }\n\n  function test_removeControllerFactory() external {\n    archController.registerControllerFactory(controllerFactory);\n    vm.expectEmit(address(archController));\n    emit ControllerFactoryRemoved(controllerFactory);\n    archController.removeControllerFactory(controllerFactory);\n  }\n\n  function test_removeControllerFactory_ControllerFactoryDoesNotExist() external {\n    vm.expectRevert(WildcatArchController.ControllerFactoryDoesNotExist.selector);\n    archController.removeControllerFactory(controllerFactory);\n  }\n\n  function test_removeControllerFactory_Unauthorized() external {\n    vm.expectRevert(Ownable.Unauthorized.selector);\n    vm.prank(controllerFactory);\n    archController.removeControllerFactory(controllerFactory);\n  }\n\n  function test_isRegisteredControllerFactory() external returns (bool) {\n    assertFalse(archController.isRegisteredControllerFactory(controllerFactory));\n    archController.registerControllerFactory(controllerFactory);\n    assertTrue(archController.isRegisteredControllerFactory(controllerFactory));\n    archController.removeControllerFactory(controllerFactory);\n    assertFalse(archController.isRegisteredControllerFactory(controllerFactory));\n  }\n\n  function test_getRegisteredControllerFactories() external returns (address[] memory) {\n    archController.registerControllerFactory(controllerFactory);\n    archController.registerControllerFactory(controllerFactory2);\n\n    address[] memory controllerFactories = archController.getRegisteredControllerFactories();\n    assertEq(controllerFactories.length, 2);\n    assertEq(controllerFactories[0], controllerFactory);\n    assertEq(controllerFactories[1], controllerFactory2);\n\n    controllerFactories = archController.getRegisteredControllerFactories(0, 3);\n    assertEq(controllerFactories.length, 2);\n    assertEq(controllerFactories[0], controllerFactory);\n    assertEq(controllerFactories[1], controllerFactory2);\n\n    controllerFactories = archController.getRegisteredControllerFactories(1, 2);\n    assertEq(controllerFactories.length, 1);\n    assertEq(controllerFactories[0], controllerFactory2);\n    assertEq(archController.getRegisteredControllerFactoriesCount(), 2);\n\n    archController.removeControllerFactory(controllerFactory);\n    controllerFactories = archController.getRegisteredControllerFactories();\n    assertEq(controllerFactories.length, 1);\n    assertEq(controllerFactories[0], controllerFactory2);\n    assertEq(archController.getRegisteredControllerFactoriesCount(), 1);\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.timestamp < tmp.expiry) {\n      revertWithSelector(ExcessReserveRatioStillActive.selector);\n    }\n\n    WildcatMarket(market).setReserveRatioBips(uint256(tmp.reserveRatioBips).toUint16());\n    delete temporaryExcessReserveRatio[market];\n  }\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n}\n",
      "output": "// SPDX-License-Identifier: NONE\npragma solidity >=0.8.20;\n\nimport './BaseMarketTest.sol';\nimport 'src/interfaces/IMarketEventsAndErrors.sol';\nimport 'src/libraries/MathUtils.sol';\nimport 'src/libraries/SafeCastLib.sol';\nimport 'src/libraries/MarketState.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketControllerTest is BaseMarketTest, IWildcatMarketControllerEventsAndErrors {\n  function _check(\n    uint256 apr,\n    uint256 reserveRatio,\n    uint256 cachedReserveRatio,\n    uint256 tmpExpiry\n  ) internal {\n    (uint256 reserveRatioBips, uint256 expiry) = controller.temporaryExcessReserveRatio(\n      address(market)\n    );\n\n    assertEq(market.annualInterestBips(), apr, 'APR');\n    assertEq(market.reserveRatioBips(), reserveRatio, 'reserve ratio');\n\n    assertEq(reserveRatioBips, cachedReserveRatio, 'Previous reserve ratio');\n    assertEq(expiry, tmpExpiry, 'Temporary reserve ratio expiry');\n  }\n\n  function test_getParameterConstraints() public {\n    MarketParameterConstraints memory constraints = controller.getParameterConstraints();\n    assertEq(\n      constraints.minimumDelinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      'minimumDelinquencyGracePeriod'\n    );\n    assertEq(\n      constraints.maximumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      'maximumDelinquencyGracePeriod'\n    );\n    assertEq(\n      constraints.minimumReserveRatioBips,\n      MinimumReserveRatioBips,\n      'minimumReserveRatioBips'\n    );\n    assertEq(\n      constraints.maximumReserveRatioBips,\n      MaximumReserveRatioBips,\n      'maximumReserveRatioBips'\n    );\n    assertEq(\n      constraints.minimumDelinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      'minimumDelinquencyFeeBips'\n    );\n    assertEq(\n      constraints.maximumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      'maximumDelinquencyFeeBips'\n    );\n    assertEq(\n      constraints.minimumWithdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      'minimumWithdrawalBatchDuration'\n    );\n    assertEq(\n      constraints.maximumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      'maximumWithdrawalBatchDuration'\n    );\n    assertEq(\n      constraints.minimumAnnualInterestBips,\n      MinimumAnnualInterestBips,\n      'minimumAnnualInterestBips'\n    );\n    assertEq(\n      constraints.maximumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      'maximumAnnualInterestBips'\n    );\n  }\n\n  function _getLenders() internal view returns (address[] memory lenders) {\n    lenders = new address[](4);\n    lenders[0] = address(1);\n    lenders[1] = address(2);\n    lenders[2] = address(1);\n    lenders[3] = address(3);\n  }\n\n  function test_authorizeLenders() external asAccount(borrower) {\n    _deauthorizeLender(alice);\n    address[] memory lenders = _getLenders();\n    vm.expectEmit(address(controller));\n    emit LenderAuthorized(address(1));\n    vm.expectEmit(address(controller));\n    emit LenderAuthorized(address(2));\n    vm.expectEmit(address(controller));\n    emit LenderAuthorized(address(3));\n    controller.authorizeLenders(lenders);\n    lenders[2] = address(3);\n    assembly {\n      mstore(lenders, 3)\n    }\n    assertEq(controller.getAuthorizedLenders(), lenders, 'getAuthorizedLenders');\n    address[] memory lenderSlice = new address[](2);\n    lenderSlice[0] = address(1);\n    lenderSlice[1] = address(2);\n    assertEq(\n      controller.getAuthorizedLenders(0, 2),\n      lenderSlice,\n      'getAuthorizedLenders(start, end)'\n    );\n    assertEq(controller.getAuthorizedLendersCount(), 3, 'getAuthorizedLendersCount');\n  }\n\n  function test_deauthorizeLenders() external asAccount(borrower) {\n    _deauthorizeLender(alice);\n    address[] memory lenders = _getLenders();\n    controller.authorizeLenders(lenders);\n    vm.expectEmit(address(controller));\n    emit LenderDeauthorized(address(1));\n    vm.expectEmit(address(controller));\n    emit LenderDeauthorized(address(2));\n    vm.expectEmit(address(controller));\n    emit LenderDeauthorized(address(3));\n    controller.deauthorizeLenders(lenders);\n    assembly {\n      mstore(lenders, 0)\n    }\n    assertEq(controller.getAuthorizedLenders(), lenders, 'getAuthorizedLenders');\n    assertEq(controller.getAuthorizedLenders(0, 2), lenders, 'getAuthorizedLenders(start, end)');\n    assertEq(controller.getAuthorizedLendersCount(), 0, 'getAuthorizedLendersCount');\n  }\n\n  function _callDeployMarket(address from) internal asAccount(from) returns (address marketAddress) {\n    marketAddress = controller.deployMarket(\n      parameters.asset,\n      parameters.namePrefix,\n      parameters.symbolPrefix,\n      parameters.maxTotalSupply,\n      parameters.annualInterestBips,\n      parameters.delinquencyFeeBips,\n      parameters.withdrawalBatchDuration,\n      parameters.reserveRatioBips,\n      parameters.delinquencyGracePeriod\n    );\n    if (marketAddress != address(0)) {\n      assertTrue(controller.isControlledMarket(marketAddress), 'controller does not recognize market');\n      assertTrue(\n        archController.isRegisteredMarket(marketAddress),\n        'arch controller does not recognize market'\n      );\n    }\n  }\n\n  function test_MarketSet() external {\n    address asset2 = address(new MockERC20('nam', 'sym', 18));\n\n    address[] memory markets = new address[](2);\n    markets[0] = address(market);\n    markets[1] = controller.computeMarketAddress(\n      asset2,\n      parameters.namePrefix,\n      parameters.symbolPrefix\n    );\n    parameters.asset = asset2;\n    _callDeployMarket(borrower);\n\n    assertEq(controller.getControlledMarkets(), markets, 'getControlledMarkets');\n    address[] memory marketSlice = new address[](1);\n\n    marketSlice[0] = markets[0];\n    assertEq(controller.getControlledMarkets(0, 1), marketSlice, 'getControlledMarkets(start, end)');\n\n    marketSlice[0] = markets[1];\n    assertEq(controller.getControlledMarkets(1, 2), marketSlice, 'getControlledMarkets(start, end)');\n\n    assertTrue(controller.isControlledMarket(markets[0]), 'isControlledMarket');\n    assertTrue(controller.isControlledMarket(markets[1]), 'isControlledMarket');\n\n    assertEq(controller.getControlledMarketsCount(), 2, 'getControlledMarketsCount');\n\n    assertEq(archController.getRegisteredMarkets(), markets, 'getRegisteredMarkets');\n  }\n\n  function test_deployMarket_OriginationFee() external {\n    MockERC20 feeAsset = new MockERC20('', '', 18);\n    feeAsset.mint(borrower, 10e18);\n    startPrank(borrower);\n    feeAsset.approve(address(controller), 10e18);\n    stopPrank();\n    controllerFactory.setProtocolFeeConfiguration(\n      parameters.feeRecipient,\n      address(feeAsset),\n      10e18,\n      parameters.protocolFeeBips\n    );\n    parameters.asset = address(asset = new MockERC20('Token', 'TKN', 18));\n    vm.expectEmit(address(feeAsset));\n    emit Transfer(borrower, feeRecipient, 10e18);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_AnnualInterestBipsOutOfBounds() external {\n    parameters.annualInterestBips = MaximumAnnualInterestBips + 1;\n    vm.expectRevert(AnnualInterestBipsOutOfBounds.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_DelinquencyFeeBipsOutOfBounds() external {\n    parameters.delinquencyFeeBips = MaximumDelinquencyFeeBips + 1;\n    vm.expectRevert(DelinquencyFeeBipsOutOfBounds.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_WithdrawalBatchDurationOutOfBounds() external {\n    parameters.withdrawalBatchDuration = MaximumWithdrawalBatchDuration + 1;\n    vm.expectRevert(WithdrawalBatchDurationOutOfBounds.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_ReserveRatioBipsOutOfBounds() external {\n    parameters.reserveRatioBips = MaximumReserveRatioBips + 1;\n    vm.expectRevert(ReserveRatioBipsOutOfBounds.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_DelinquencyGracePeriodOutOfBounds() external {\n    parameters.delinquencyGracePeriod = MaximumDelinquencyGracePeriod + 1;\n    vm.expectRevert(DelinquencyGracePeriodOutOfBounds.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_EmptyString() external {\n    parameters.namePrefix = '';\n    vm.expectRevert(EmptyString.selector);\n    _callDeployMarket(borrower);\n    parameters.namePrefix = 'Wildcat ';\n    parameters.symbolPrefix = '';\n    vm.expectRevert(EmptyString.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_CallerNotBorrowerOrControllerFactory() external {\n    vm.expectRevert(CallerNotBorrowerOrControllerFactory.selector);\n    _callDeployMarket(address(this));\n  }\n\n  function test_deployMarket_NotRegisteredBorrower() external {\n    archController.removeBorrower(borrower);\n    vm.expectRevert(NotRegisteredBorrower.selector);\n    _callDeployMarket(borrower);\n  }\n\n  function test_deployMarket_BorrowerNotCheckedWhenCalledByFactory() external {\n    archController.removeBorrower(borrower);\n    parameters.asset = address(new MockERC20('Token', 'TKN', 18));\n    assertEq(\n      _callDeployMarket(address(controllerFactory)),\n      controller.computeMarketAddress(\n        parameters.asset,\n        parameters.namePrefix,\n        parameters.symbolPrefix\n      )\n    );\n  }\n\n  function test_deployMarket_MarketAlreadyDeployed() external {\n    vm.expectRevert(MarketAlreadyDeployed.selector);\n    _callDeployMarket(borrower);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Market Control Tests                            */\n  /* -------------------------------------------------------------------------- */\n\n  function test_setAnnualInterestBips_NotControlledMarket() public {\n    vm.prank(borrower);\n    vm.expectRevert(NotControlledMarket.selector);\n    controller.setAnnualInterestBips(address(1), DefaultInterest + 1);\n  }\n\n  function test_setAnnualInterestBips_CallerNotBorrower() public {\n    vm.expectRevert(CallerNotBorrower.selector);\n    controller.setAnnualInterestBips(address(market), DefaultInterest + 1);\n  }\n\n  function test_setAnnualInterestBips_Decrease() public {\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 1);\n    _check(DefaultInterest - 1, 9000, DefaultReserveRatio, block.timestamp + 2 weeks);\n  }\n\n  function test_setAnnualInterestBips_Decrease_AlreadyPending() public {\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 1);\n\n    uint256 expiry = block.timestamp + 2 weeks;\n    _check(DefaultInterest - 1, 9000, DefaultReserveRatio, expiry);\n\n    fastForward(2 weeks);\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 2);\n    _check(DefaultInterest - 2, 9000, DefaultReserveRatio, expiry + 2 weeks);\n  }\n\n  function test_setAnnualInterestBips_Decrease_Undercollateralized() public {\n    _deposit(alice, 50_000e18);\n    vm.prank(borrower);\n    market.borrow(5_000e18 + 1);\n\n    vm.startPrank(borrower);\n    vm.expectRevert(IMarketEventsAndErrors.InsufficientReservesForNewLiquidityRatio.selector);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 1);\n  }\n\n  function test_setAnnualInterestBips_Increase() public {\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest + 1);\n\n    _check(DefaultInterest + 1, DefaultReserveRatio, 0, 0);\n  }\n\n  function test_setAnnualInterestBips_Increase_Undercollateralized() public {\n    _deposit(alice, 50_000e18);\n    vm.prank(borrower);\n    market.borrow(5_000e18 + 1);\n\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest + 1);\n  }\n\n  function test_resetReserveRatio_NotPending() public {\n    vm.expectRevert(AprChangeNotPending.selector);\n    controller.resetReserveRatio(address(market));\n  }\n\n  function test_resetReserveRatio_StillActive() public {\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 1);\n\n    vm.expectRevert(ExcessReserveRatioStillActive.selector);\n    controller.resetReserveRatio(address(market));\n  }\n\n  function test_resetReserveRatio() public {\n    vm.prank(borrower);\n    controller.setAnnualInterestBips(address(market), DefaultInterest - 1);\n\n    fastForward(2 weeks);\n    controller.resetReserveRatio(address(market));\n\n    assertEq(market.reserveRatioBips(), DefaultReserveRatio, 'reserve ratio not reset');\n\n    _check(DefaultInterest - 1, DefaultReserveRatio, 0, 0);\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './interfaces/IWildcatMarketController.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './market/WildcatMarket.sol';\nimport './WildcatMarketController.sol';\n\ncontract WildcatMarketControllerFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  event NewController(address borrower, address controller, string namePrefix, string symbolPrefix);\n  event UpdateProtocolFeeConfiguration(\n    address feeRecipient,\n    uint16 protocolFeeBips,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  );\n\n  error NotRegisteredBorrower();\n  error InvalidProtocolFeeConfiguration();\n  error CallerNotArchControllerOwner();\n  error InvalidConstraints();\n  error ControllerAlreadyDeployed();\n\n  // Returns immutable arch-controller\n  IWildcatArchController public immutable archController;\n\n  // Returns sentinel used by controller\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  address public immutable controllerInitCodeStorage;\n\n  uint256 public immutable controllerInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  ProtocolFeeConfiguration internal _protocolFeeConfiguration;\n\n  EnumerableSet.AddressSet internal _deployedControllers;\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != archController.owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  constructor(\n    address _archController,\n    address _sentinel,\n    MarketParameterConstraints memory constraints\n  ) {\n    archController = IWildcatArchController(_archController);\n    sentinel = _sentinel;\n    if (\n      constraints.minimumAnnualInterestBips > constraints.maximumAnnualInterestBips ||\n      constraints.maximumAnnualInterestBips > 10000 ||\n      constraints.minimumDelinquencyFeeBips > constraints.maximumDelinquencyFeeBips ||\n      constraints.maximumDelinquencyFeeBips > 10000 ||\n      constraints.minimumReserveRatioBips > constraints.maximumReserveRatioBips ||\n      constraints.maximumReserveRatioBips > 10000 ||\n      constraints.minimumDelinquencyGracePeriod > constraints.maximumDelinquencyGracePeriod ||\n      constraints.minimumWithdrawalBatchDuration > constraints.maximumWithdrawalBatchDuration\n    ) {\n      revert InvalidConstraints();\n    }\n    MinimumDelinquencyGracePeriod = constraints.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = constraints.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = constraints.minimumReserveRatioBips;\n    MaximumReserveRatioBips = constraints.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = constraints.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = constraints.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = constraints.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = constraints.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = constraints.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = constraints.maximumAnnualInterestBips;\n\n    (controllerInitCodeStorage, controllerInitCodeHash) = _storeControllerInitCode();\n    (marketInitCodeStorage, marketInitCodeHash) = _storeMarketInitCode();\n  }\n\n  function _storeControllerInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory controllerInitCode = type(WildcatMarketController).creationCode;\n    initCodeHash = uint256(keccak256(controllerInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(controllerInitCode);\n  }\n\n  function _storeMarketInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory marketInitCode = type(WildcatMarket).creationCode;\n    initCodeHash = uint256(keccak256(marketInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(marketInitCode);\n  }\n\n  function isDeployedController(address controller) external view returns (bool) {\n    return _deployedControllers.contains(controller);\n  }\n\n  function getDeployedControllersCount() external view returns (uint256) {\n    return _deployedControllers.length();\n  }\n\n  function getDeployedControllers() external view returns (address[] memory) {\n    return _deployedControllers.values();\n  }\n\n  function getDeployedControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _deployedControllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _deployedControllers.at(start + i);\n    }\n  }\n\n  /**\n   * @dev Returns protocol fee configuration for new markets.\n   *\n   *      These can be updated by the arch-controller owner but\n   *      `protocolFeeBips` and `feeRecipient` are immutable once\n   *      a market is deployed.\n   *\n   * @return feeRecipient         feeRecipient to use in new markets\n   * @return originationFeeAsset  Asset used to pay fees for new market\n   *                              deployments\n   * @return originationFeeAmount Amount of originationFeeAsset paid\n   *                              for new market deployments\n   * @return protocolFeeBips      protocolFeeBips to use in new markets\n   */\n  function getProtocolFeeConfiguration()\n    external\n    view\n    returns (\n      address feeRecipient,\n      address originationFeeAsset,\n      uint80 originationFeeAmount,\n      uint16 protocolFeeBips\n    )\n  {\n    return (\n      _protocolFeeConfiguration.feeRecipient,\n      _protocolFeeConfiguration.originationFeeAsset,\n      _protocolFeeConfiguration.originationFeeAmount,\n      _protocolFeeConfiguration.protocolFeeBips\n    );\n  }\n\n  /**\n   * @dev Sets protocol fee configuration for new market deployments via\n   *      controllers deployed by this factory.\n   *\n   *      If caller is not `archController.owner()`, reverts with\n   *      `NotArchControllerOwner`.\n   *\n   *      Revert with `InvalidProtocolFeeConfiguration` if:\n   *      - `protocolFeeBips > 0 && feeRecipient == address(0)`\n   *      - OR `originationFeeAmount > 0 && originationFeeAsset == address(0)`\n   *      - OR `originationFeeAmount > 0 && feeRecipient == address(0)`\n   */\n  function setProtocolFeeConfiguration(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external onlyArchControllerOwner {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset)\n    ) {\n      revert InvalidProtocolFeeConfiguration();\n    }\n    _protocolFeeConfiguration = ProtocolFeeConfiguration({\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips\n    });\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Controller Deployment                           */\n  /* -------------------------------------------------------------------------- */\n\n  address internal _tmpMarketBorrowerParameter = address(1);\n\n  function getMarketControllerParameters()\n    external\n    view\n    virtual\n    returns (MarketControllerParameters memory parameters)\n  {\n    parameters.archController = address(archController);\n    parameters.borrower = _tmpMarketBorrowerParameter;\n    parameters.sentinel = sentinel;\n    parameters.marketInitCodeStorage = marketInitCodeStorage;\n    parameters.marketInitCodeHash = marketInitCodeHash;\n    parameters.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    parameters.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    parameters.minimumReserveRatioBips = MinimumReserveRatioBips;\n    parameters.maximumReserveRatioBips = MaximumReserveRatioBips;\n    parameters.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    parameters.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    parameters.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    parameters.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    parameters.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    parameters.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *      reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   *      `NewController(borrower, controller)`.\n   */\n  function deployController() public returns (address controller) {\n    if (!archController.isRegisteredBorrower(msg.sender)) {\n      revert NotRegisteredBorrower();\n    }\n    _tmpMarketBorrowerParameter = msg.sender;\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n    controller = LibStoredInitCode.calculateCreate2Address(\n      ownCreate2Prefix,\n      salt,\n      controllerInitCodeHash\n    );\n    if (controller.codehash != bytes32(0)) {\n      revert ControllerAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(controllerInitCodeStorage, salt);\n    _tmpMarketBorrowerParameter = address(1);\n    archController.registerController(controller);\n    _deployedControllers.add(controller);\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller,\n   *      then deploys a new market through the controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   * \t  `NewController(borrower, controller, namePrefix, symbolPrefix)`.\n   */\n  function deployControllerAndMarket(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    address asset,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address controller, address market) {\n    controller = deployController();\n    market = IWildcatMarketController(controller).deployMarket(\n      asset,\n      namePrefix,\n      symbolPrefix,\n      maxTotalSupply,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n  }\n\n  function computeControllerAddress(address borrower) external view returns (address) {\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(borrower)));\n    return\n      LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, controllerInitCodeHash);\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'forge-std/Test.sol';\nimport 'src/WildcatArchController.sol';\nimport 'src/WildcatMarketControllerFactory.sol';\nimport { MinimumDelinquencyGracePeriod, MaximumDelinquencyGracePeriod, MinimumReserveRatioBips, MaximumReserveRatioBips, MinimumDelinquencyFeeBips, MaximumDelinquencyFeeBips, MinimumWithdrawalBatchDuration, MaximumWithdrawalBatchDuration, MinimumAnnualInterestBips, MaximumAnnualInterestBips } from './shared/TestConstants.sol';\n\ncontract WildcatMarketControllerFactoryTest is Test {\n  WildcatArchController internal archController;\n  WildcatMarketControllerFactory internal controllerFactory;\n  MarketParameterConstraints internal constraints;\n\n  function setUp() external {\n    archController = new WildcatArchController();\n    _resetConstraints();\n    controllerFactory = new WildcatMarketControllerFactory(\n      address(archController),\n      address(0),\n      constraints\n    );\n  }\n\n  function _resetConstraints() internal {\n    constraints = MarketParameterConstraints({\n      minimumDelinquencyGracePeriod: MinimumDelinquencyGracePeriod,\n      maximumDelinquencyGracePeriod: MaximumDelinquencyGracePeriod,\n      minimumReserveRatioBips: MinimumReserveRatioBips,\n      maximumReserveRatioBips: MaximumReserveRatioBips,\n      minimumDelinquencyFeeBips: MinimumDelinquencyFeeBips,\n      maximumDelinquencyFeeBips: MaximumDelinquencyFeeBips,\n      minimumWithdrawalBatchDuration: MinimumWithdrawalBatchDuration,\n      maximumWithdrawalBatchDuration: MaximumWithdrawalBatchDuration,\n      minimumAnnualInterestBips: MinimumAnnualInterestBips,\n      maximumAnnualInterestBips: MaximumAnnualInterestBips\n    });\n  }\n\n  function _expectRevertInvalidConstraints() internal {\n    vm.expectRevert(WildcatMarketControllerFactory.InvalidConstraints.selector);\n    new WildcatMarketControllerFactory(address(archController), address(0), constraints);\n    _resetConstraints();\n  }\n\n  function test_InvalidConstraints() external {\n    constraints.minimumAnnualInterestBips = constraints.maximumAnnualInterestBips + 1;\n    _expectRevertInvalidConstraints();\n    constraints.minimumDelinquencyFeeBips = constraints.maximumDelinquencyFeeBips + 1;\n    _expectRevertInvalidConstraints();\n    constraints.minimumReserveRatioBips = constraints.maximumReserveRatioBips + 1;\n    _expectRevertInvalidConstraints();\n    constraints.minimumDelinquencyGracePeriod = constraints.maximumDelinquencyGracePeriod + 1;\n    _expectRevertInvalidConstraints();\n    constraints.minimumWithdrawalBatchDuration = constraints.maximumWithdrawalBatchDuration + 1;\n    _expectRevertInvalidConstraints();\n\n    constraints.maximumAnnualInterestBips = 10001;\n    _expectRevertInvalidConstraints();\n    constraints.maximumDelinquencyFeeBips = 10001;\n    _expectRevertInvalidConstraints();\n    constraints.maximumReserveRatioBips = 10001;\n    _expectRevertInvalidConstraints();\n  }\n\n  function test_getMarketControllerParameters() external {\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    assertEq(parameters.archController, address(archController));\n    assertEq(parameters.borrower, address(1), 'borrower');\n    assertEq(parameters.sentinel, address(0), 'sentinel');\n    assertEq(\n      parameters.marketInitCodeStorage,\n      controllerFactory.marketInitCodeStorage(),\n      'marketInitCodeStorage'\n    );\n    assertEq(\n      parameters.marketInitCodeHash,\n      controllerFactory.marketInitCodeHash(),\n      'marketInitCodeHash'\n    );\n    assertEq(parameters.marketInitCodeHash, uint256(keccak256(type(WildcatMarket).creationCode)));\n    assertEq(\n      controllerFactory.controllerInitCodeHash(),\n      uint256(keccak256(type(WildcatMarketController).creationCode)),\n      'controllerInitCodeHash'\n    );\n\n    assertEq(\n      parameters.minimumDelinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      'minimumDelinquencyGracePeriod'\n    );\n    assertEq(\n      parameters.maximumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      'maximumDelinquencyGracePeriod'\n    );\n    assertEq(\n      parameters.minimumReserveRatioBips,\n      MinimumReserveRatioBips,\n      'minimumReserveRatioBips'\n    );\n    assertEq(\n      parameters.maximumReserveRatioBips,\n      MaximumReserveRatioBips,\n      'maximumReserveRatioBips'\n    );\n    assertEq(\n      parameters.minimumDelinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      'minimumDelinquencyFeeBips'\n    );\n    assertEq(\n      parameters.maximumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      'maximumDelinquencyFeeBips'\n    );\n    assertEq(\n      parameters.minimumWithdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      'minimumWithdrawalBatchDuration'\n    );\n    assertEq(\n      parameters.maximumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      'maximumWithdrawalBatchDuration'\n    );\n    assertEq(\n      parameters.minimumAnnualInterestBips,\n      MinimumAnnualInterestBips,\n      'minimumAnnualInterestBips'\n    );\n    assertEq(\n      parameters.maximumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      'maximumAnnualInterestBips'\n    );\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport './WildcatMarketBase.sol';\nimport './WildcatMarketConfig.sol';\nimport './WildcatMarketToken.sol';\nimport './WildcatMarketWithdrawals.sol';\n\ncontract WildcatMarket is\n  WildcatMarketBase,\n  WildcatMarketConfig,\n  WildcatMarketToken,\n  WildcatMarketWithdrawals\n{\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /**\n   * @dev Apply pending interest, delinquency fees and protocol fees\n   *      to the state and process the pending withdrawal batch if\n   *      one exists and has expired, then update the market's\n   *      delinquency status.\n   */\n  function updateState() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    _writeState(state);\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function depositUpTo(\n    uint256 amount\n  ) public virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) {\n      revert DepositToClosedMarket();\n    }\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert NullMintAmount();\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.DepositAndWithdraw);\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit Transfer(address(0), msg.sender, amount);\n    emit Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n  /**\n   * @dev Deposit exactly `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *     Reverts if the deposit amount would cause the market to exceed the\n   *     configured `maxTotalSupply`.\n   */\n  function deposit(uint256 amount) external virtual {\n    uint256 actualAmount = depositUpTo(amount);\n    if (amount != actualAmount) {\n      revert MaxSupplyExceeded();\n    }\n  }\n\n  /**\n   * @dev Withdraw available protocol fees to the fee recipient.\n   */\n  function collectFees() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) {\n      revert NullFeeAmount();\n    }\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) {\n      revert InsufficientReservesForFeeWithdrawal();\n    }\n    state.accruedProtocolFees -= withdrawableFees;\n    _writeState(state);\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    emit FeesCollected(withdrawableFees);\n  }\n\n  /**\n   * @dev Withdraw funds from the market to the borrower.\n   *\n   *      Can only withdraw up to the assets that are not required\n   *      to meet the borrower's collateral obligations.\n   *\n   *      Reverts if the market is closed.\n   */\n  function borrow(uint256 amount) external onlyBorrower nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) {\n      revert BorrowFromClosedMarket();\n    }\n    uint256 borrowable = state.borrowableAssets(totalAssets());\n    if (amount > borrowable) {\n      revert BorrowAmountTooHigh();\n    }\n    _writeState(state);\n    asset.safeTransfer(msg.sender, amount);\n    emit Borrow(amount);\n  }\n\n  /**\n   * @dev Sets the market APR to 0% and marks market as closed.\n   *\n   *      Can not be called if there are any unpaid withdrawal batches.\n   *\n   *      Transfers remaining debts from borrower if market is not fully\n   *      collateralized; otherwise, transfers any assets in excess of\n   *      debts to the borrower.\n   */\n  function closeMarket() external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 0;\n    if (_withdrawalData.unpaidBatches.length() > 0) {\n      revert CloseMarketWithUnpaidWithdrawals();\n    }\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      asset.safeTransferFrom(borrower, address(this), totalDebts - currentlyHeld);\n    } else if (currentlyHeld > totalDebts) {\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, currentlyHeld - totalDebts);\n    }\n    _writeState(state);\n    emit MarketClosed(block.timestamp);\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../BaseMarketTest.sol';\nimport 'src/interfaces/IMarketEventsAndErrors.sol';\nimport 'src/libraries/MathUtils.sol';\nimport 'src/libraries/SafeCastLib.sol';\nimport 'src/libraries/MarketState.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketTest is BaseMarketTest {\n  using stdStorage for StdStorage;\n  // using WadRayMath for uint256;\n  using MathUtils for int256;\n  using MathUtils for uint256;\n\n  // ===================================================================== //\n  //                             updateState()                             //\n  // ===================================================================== //\n\n  function test_updateState() external {\n    _deposit(alice, 1e18);\n    fastForward(365 days);\n    MarketState memory state = pendingState();\n    updateState(state);\n    market.updateState();\n    assertEq(market.previousState(), state);\n  }\n\n  function test_updateState_NoChange() external {\n    _deposit(alice, 1e18);\n    MarketState memory state = pendingState();\n    bytes32 stateHash = keccak256(abi.encode(state));\n    market.updateState();\n    assertEq(keccak256(abi.encode(market.previousState())), stateHash);\n    assertEq(keccak256(abi.encode(market.currentState())), stateHash);\n  }\n\n  function test_updateState_HasPendingExpiredBatch() external {\n    parameters.annualInterestBips = 3650;\n    setUp();\n    _deposit(alice, 1e18);\n    _requestWithdrawal(alice, 1e18);\n    uint32 expiry = previousState.pendingWithdrawalExpiry;\n    fastForward(1 days);\n    MarketState memory state = pendingState();\n    vm.expectEmit(address(market));\n    emit ScaleFactorUpdated(1.001e27, 1e24, 0, 0);\n    vm.expectEmit(address(market));\n    emit WithdrawalBatchExpired(expiry, 1e18, 1e18, 1e18);\n    vm.expectEmit(address(market));\n    emit WithdrawalBatchClosed(expiry);\n    vm.expectEmit(address(market));\n    emit StateUpdated(1.001e27, false);\n    market.updateState();\n  }\n\n  function test_updateState_HasPendingExpiredBatch_SameBlock() external {\n    parameters.withdrawalBatchDuration = 0;\n    setUpContracts(true);\n    setUp();\n    _deposit(alice, 1e18);\n    _requestWithdrawal(alice, 1e18);\n    MarketState memory state = pendingState();\n    vm.expectEmit(address(market));\n    emit WithdrawalBatchExpired(block.timestamp, 1e18, 1e18, 1e18);\n    vm.expectEmit(address(market));\n    emit WithdrawalBatchClosed(block.timestamp);\n    vm.expectEmit(address(market));\n    emit StateUpdated(1e27, false);\n    market.updateState();\n  }\n\n  // ===================================================================== //\n  //                         depositUpTo(uint256)                          //\n  // ===================================================================== //\n\n  function test_depositUpTo() external asAccount(alice) {\n    _deposit(alice, 50_000e18);\n    assertEq(market.totalSupply(), 50_000e18);\n    assertEq(market.balanceOf(alice), 50_000e18);\n  }\n\n  function test_depositUpTo(uint256 amount) external asAccount(alice) {\n    amount = bound(amount, 1, DefaultMaximumSupply);\n    market.depositUpTo(amount);\n  }\n\n  function test_depositUpTo_ApprovedOnController() public asAccount(bob) {\n    _authorizeLender(bob);\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(bob, AuthRole.DepositAndWithdraw);\n    market.depositUpTo(1e18);\n    assertEq(uint(market.getAccountRole(bob)), uint(AuthRole.DepositAndWithdraw));\n  }\n\n  function test_depositUpTo_NullMintAmount() external asAccount(alice) {\n    vm.expectRevert(IMarketEventsAndErrors.NullMintAmount.selector);\n    market.depositUpTo(0);\n  }\n\n  function testDepositUpTo_MaxSupplyExceeded() public asAccount(bob) {\n    _authorizeLender(bob);\n    asset.transfer(address(1), type(uint128).max);\n    asset.mint(bob, DefaultMaximumSupply);\n    asset.approve(address(market), DefaultMaximumSupply);\n    market.depositUpTo(DefaultMaximumSupply - 1);\n    market.depositUpTo(2);\n    assertEq(market.balanceOf(bob), DefaultMaximumSupply);\n    assertEq(asset.balanceOf(bob), 0);\n  }\n\n  function testDepositUpTo_NotApprovedLender() public asAccount(bob) {\n    asset.mint(bob, 1e18);\n    asset.approve(address(market), 1e18);\n    vm.expectRevert(IMarketEventsAndErrors.NotApprovedLender.selector);\n    market.depositUpTo(1e18);\n  }\n\n  function testDepositUpTo_TransferFail() public asAccount(alice) {\n    asset.approve(address(market), 0);\n    vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n    market.depositUpTo(50_000e18);\n  }\n\n  // ===================================================================== //\n  //                           deposit(uint256)                            //\n  // ===================================================================== //\n\n  function test_deposit(uint256 amount) external asAccount(alice) {\n    amount = bound(amount, 1, DefaultMaximumSupply);\n    market.deposit(amount);\n  }\n\n  function testDeposit_NotApprovedLender() public asAccount(bob) {\n    vm.expectRevert(IMarketEventsAndErrors.NotApprovedLender.selector);\n    market.deposit(1e18);\n  }\n\n  function testDeposit_MaxSupplyExceeded() public asAccount(alice) {\n    market.deposit(DefaultMaximumSupply - 1);\n    vm.expectRevert(IMarketEventsAndErrors.MaxSupplyExceeded.selector);\n    market.deposit(2);\n  }\n\n  // ===================================================================== //\n  //                             collectFees()                             //\n  // ===================================================================== //\n\n  function test_collectFees_NoFeesAccrued() external {\n    vm.expectRevert(IMarketEventsAndErrors.NullFeeAmount.selector);\n    market.collectFees();\n  }\n\n  function test_collectFees() external {\n    _deposit(alice, 1e18);\n    fastForward(365 days);\n    vm.expectEmit(address(asset));\n    emit Transfer(address(market), feeRecipient, 1e16);\n    vm.expectEmit(address(market));\n    emit FeesCollected(1e16);\n    market.collectFees();\n  }\n\n  function test_collectFees_InsufficientReservesForFeeWithdrawal() external {\n    _deposit(alice, 1e18);\n    fastForward(1);\n    asset.burn(address(market), 1e18);\n    vm.expectRevert(IMarketEventsAndErrors.InsufficientReservesForFeeWithdrawal.selector);\n    market.collectFees();\n  }\n\n  // ===================================================================== //\n  //                            borrow(uint256)                            //\n  // ===================================================================== //\n\n  function test_borrow(uint256 amount) external {\n    uint256 availableCollateral = market.borrowableAssets();\n    assertEq(availableCollateral, 0, 'borrowable should be 0');\n\n    vm.prank(alice);\n    market.depositUpTo(50_000e18);\n    assertEq(market.borrowableAssets(), 40_000e18, 'borrowable should be 40k');\n    vm.prank(borrower);\n    market.borrow(40_000e18);\n    assertEq(asset.balanceOf(borrower), 40_000e18);\n  }\n\n  function test_borrow_BorrowAmountTooHigh() external {\n    vm.prank(alice);\n    market.depositUpTo(50_000e18);\n\n    vm.startPrank(borrower);\n    vm.expectRevert(IMarketEventsAndErrors.BorrowAmountTooHigh.selector);\n    market.borrow(40_000e18 + 1);\n  }\n\n  // ===================================================================== //\n  //                             closeMarket()                              //\n  // ===================================================================== //\n\n  function test_closeMarket_TransferRemainingDebt() external asAccount(address(controller)) {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    startPrank(borrower);\n    asset.approve(address(market), 8e17);\n    stopPrank();\n    vm.expectEmit(address(asset));\n    emit Transfer(borrower, address(market), 8e17);\n    market.closeMarket();\n  }\n\n  function test_closeMarket_TransferExcessAssets() external asAccount(address(controller)) {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    asset.mint(address(market), 1e18);\n    vm.expectEmit(address(asset));\n    emit Transfer(address(market), borrower, 2e17);\n    market.closeMarket();\n  }\n\n  function test_closeMarket_FailTransferRemainingDebt() external asAccount(address(controller)) {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n    market.closeMarket();\n  }\n\n  function test_closeMarket_NotController() external {\n    vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n    market.closeMarket();\n  }\n\n  function test_closeMarket_CloseMarketWithUnpaidWithdrawals()\n    external\n    asAccount(address(controller))\n  {\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    fastForward(parameters.withdrawalBatchDuration);\n    market.updateState();\n    uint32[] memory unpaidBatches = market.getUnpaidBatchExpiries();\n    assertEq(unpaidBatches.length, 1);\n    vm.expectRevert(IMarketEventsAndErrors.CloseMarketWithUnpaidWithdrawals.selector);\n    market.closeMarket();\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiry != state.lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            protocolFeeBips,\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n        emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 expiredBatchExpiry,\n      WithdrawalBatch memory expiredBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      expiredBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiredBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiredBatchExpiry\n        );\n      }\n\n      expiredBatch = _withdrawalData.batches[expiredBatchExpiry];\n      uint256 availableLiquidity = expiredBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(expiredBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n    _state = state;\n    emit StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    emit WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit Transfer(address(this), address(0), normalizedAmountPaid);\n    emit WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../BaseMarketTest.sol';\n\ncontract WildcatMarketBaseTest is BaseMarketTest {\n  // ===================================================================== //\n  //                          coverageLiquidity()                          //\n  // ===================================================================== //\n\n  function test_coverageLiquidity() external {\n    market.coverageLiquidity();\n  }\n\n  // ===================================================================== //\n  //                             scaleFactor()                             //\n  // ===================================================================== //\n\n  function test_scaleFactor() external {\n    assertEq(market.scaleFactor(), 1e27, 'scaleFactor should be 1 ray');\n    fastForward(365 days);\n    assertEq(market.scaleFactor(), 1.1e27, 'scaleFactor should grow by 10% from APR');\n    // updateState(pendingState());\n    // Deposit one token\n    _deposit(alice, 1e18);\n    // Borrow 80% of market assets\n    _borrow(8e17);\n    assertEq(market.currentState().isDelinquent, false);\n    // Withdraw 100% of deposits\n    _requestWithdrawal(alice, 1e18);\n    assertEq(market.scaleFactor(), 1.1e27);\n    // Fast forward to delinquency grace period\n    fastForward(2000);\n    MarketState memory state = previousState;\n    uint256 scaleFactorAtGracePeriodExpiry = uint(1.1e27) +\n      MathUtils.rayMul(\n        1.1e27,\n        FeeMath.calculateLinearInterestFromBips(parameters.annualInterestBips, 2_000)\n      );\n    assertEq(market.scaleFactor(), scaleFactorAtGracePeriodExpiry);\n    // uint256 dayOneInterest = FeeMath.calculateLinearInterestFromBips(\n    // \t1000,\n    // \t86_400\n    // );\n    // uint256 scaleFactorDayOne = 1.1e27 + MathUtils.rayMul(1.1e27, dayOneInterest);\n    // uint256 scaleFactor = scaleFactorDayOne +\n    // \tMathUtils.rayMul(scaleFactorDayOne, FeeMath.calculateLinearInterestFromBips(2000, 364 days));\n\n    // assertEq(\n    // \tmarket.scaleFactor(),\n    // \tscaleFactor,\n    // \t'scaleFactor should grow by 20% with delinquency fees'\n    // );\n  }\n\n  // ===================================================================== //\n  //                             totalAssets()                             //\n  // ===================================================================== //\n\n  function test_totalAssets() external {\n    market.totalAssets();\n  }\n\n  // ===================================================================== //\n  //                          borrowableAssets()                           //\n  // ===================================================================== //\n\n  function test_borrowableAssets() external {\n    assertEq(market.borrowableAssets(), 0, 'borrowable should be 0');\n\n    _deposit(alice, 50_000e18);\n    assertEq(market.borrowableAssets(), 40_000e18, 'borrowable should be 40k');\n    // market.borrowableAssets();\n  }\n\n  // ===================================================================== //\n  //                         accruedProtocolFees()                         //\n  // ===================================================================== //\n\n  function test_accruedProtocolFees() external {\n    market.accruedProtocolFees();\n  }\n\n  // ===================================================================== //\n  //                            previousState()                            //\n  // ===================================================================== //\n\n  function test_previousState() external {\n    market.previousState();\n  }\n\n  // ===================================================================== //\n  //                            currentState()                             //\n  // ===================================================================== //\n\n  function test_currentState() external {\n    market.currentState();\n  }\n\n  // ===================================================================== //\n  //                          scaledTotalSupply()                          //\n  // ===================================================================== //\n\n  function test_scaledTotalSupply() external {\n    market.scaledTotalSupply();\n  }\n\n  // ===================================================================== //\n  //                       scaledBalanceOf(address)                        //\n  // ===================================================================== //\n\n  function test_scaledBalanceOf(address account) external {\n    market.scaledBalanceOf(account);\n  }\n\n  function test_scaledBalanceOf() external {\n    address account;\n    market.scaledBalanceOf(account);\n  }\n\n  // ===================================================================== //\n  //                        effectiveBorrowerAPR()                         //\n  // ===================================================================== //\n\n  function test_effectiveBorrowerAPR() external {\n    assertEq(market.effectiveBorrowerAPR(), 1.1e26);\n    _deposit(alice, 1e18);\n    _borrow(8e17);\n    _requestWithdrawal(alice, 1e18);\n    assertEq(market.effectiveBorrowerAPR(), 1.1e26);\n    fastForward(2_001);\n    assertEq(market.effectiveBorrowerAPR(), 2.1e26);\n  }\n\n  // ===================================================================== //\n  //                         effectiveLenderAPR()                          //\n  // ===================================================================== //\n\n  function test_effectiveLenderAPR() external {\n    assertEq(market.effectiveLenderAPR(), 1e26);\n    _deposit(alice, 1e18);\n    _borrow(8e17);\n    _requestWithdrawal(alice, 1e18);\n    assertEq(market.effectiveLenderAPR(), 1e26);\n    fastForward(2_001);\n    assertEq(market.effectiveLenderAPR(), 2e26);\n  }\n\n  // ===================================================================== //\n  //                      withdrawableProtocolFees()                       //\n  // ===================================================================== //\n\n  function test_withdrawableProtocolFees() external {\n    assertEq(market.withdrawableProtocolFees(), 0);\n    _deposit(alice, 1e18);\n    fastForward(365 days);\n    assertEq(market.withdrawableProtocolFees(), 1e16);\n  }\n\n  function test_withdrawableProtocolFees_LessNormalizedUnclaimedWithdrawals() external {\n    assertEq(market.withdrawableProtocolFees(), 0);\n    _deposit(alice, 1e18);\n    _borrow(8e17);\n    fastForward(365 days);\n    _requestWithdrawal(alice, 1e18);\n    assertEq(market.withdrawableProtocolFees(), 1e16);\n    asset.mint(address(market), 8e17 + 1);\n    assertEq(market.withdrawableProtocolFees(), 1e16);\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketConfig is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  // ===================================================================== //\n  //                      External Config Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the maximum amount of underlying asset that can\n   *      currently be deposited to the market.\n   */\n  function maximumDeposit() external view returns (uint256) {\n    MarketState memory state = currentState();\n    return state.maximumDeposit();\n  }\n\n  /**\n   * @dev Returns the maximum supply the market can reach via\n   *      deposits (does not apply to interest accrual).\n   */\n  function maxTotalSupply() external view returns (uint256) {\n    return _state.maxTotalSupply;\n  }\n\n  /**\n   * @dev Returns the annual interest rate earned by lenders\n   *      in bips.\n   */\n  function annualInterestBips() external view returns (uint256) {\n    return _state.annualInterestBips;\n  }\n\n  function reserveRatioBips() external view returns (uint256) {\n    return _state.reserveRatioBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Sanctions                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /// @dev Block a sanctioned account from interacting with the market\n  ///      and transfer its balance to an escrow contract.\n  // ******************************************************************\n  //          *  |\\**/|  *          *                                *\n  //          *  \\ == /  *          *                                *\n  //          *   | b|   *          *                                *\n  //          *   | y|   *          *                                *\n  //          *   \\ e/   *          *                                *\n  //          *    \\/    *          *                                *\n  //          *          *          *                                *\n  //          *          *          *                                *\n  //          *          *  |\\**/|  *                                *\n  //          *          *  \\ == /  *         _.-^^---....,,--       *\n  //          *          *   | b|   *    _--                  --_    *\n  //          *          *   | y|   *   <                        >)  *\n  //          *          *   \\ e/   *   |         O-FAC!          |  *\n  //          *          *    \\/    *    \\._                   _./   *\n  //          *          *          *       ```--. . , ; .--'''      *\n  //          *          *          *   \uD83D\uDCB8        | |   |            *\n  //          *          *          *          .-=||  | |=-.    \uD83D\uDCB8   *\n  //  \uD83D\uDCB0\uD83E\uDD11\uD83D\uDCB0 *   \uD83D\uDE05    *    \uD83D\uDE10    *    \uD83D\uDCB8    `-=#$%&%$#=-'         *\n  //   \\|/    *   /|\\    *   /|\\    *  \uD83C\uDF2A         | ;  :|    \uD83C\uDF2A       *\n  //   /\\     * \uD83D\uDCB0/\\ \uD83D\uDCB0 * \uD83D\uDCB0/\\ \uD83D\uDCB0 *    _____.,-#%&$@%#&#~,._____    *\n  // ******************************************************************\n  function nukeFromOrbit(address accountAddress) external nonReentrant {\n    if (!IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert BadLaunchCode();\n    }\n    MarketState memory state = _getUpdatedState();\n    _blockAccount(state, accountAddress);\n    _writeState(state);\n  }\n\n  /**\n   * @dev Unblock an account that was previously sanctioned and blocked\n   *      and has since been removed from the sanctions list or had\n   *      their sanctioned status overridden by the borrower.\n   */\n  function stunningReversal(address accountAddress) external nonReentrant {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      revert AccountNotBlocked();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert NotReversedOrStunning();\n    }\n\n    account.approval = AuthRole.Null;\n    emit AuthorizationStatusUpdated(accountAddress, account.approval);\n\n    _accounts[accountAddress] = account;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                           External Config Setters                          */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Updates an account's authorization status based on whether the controller\n   *      has it marked as approved.\n   */\n  function updateAccountAuthorization(\n    address _account,\n    bool _isAuthorized\n  ) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    Account memory account = _getAccount(_account);\n    if (_isAuthorized) {\n      account.approval = AuthRole.DepositAndWithdraw;\n    } else {\n      account.approval = AuthRole.WithdrawOnly;\n    }\n    _accounts[_account] = account;\n    _writeState(state);\n    emit AuthorizationStatusUpdated(_account, account.approval);\n  }\n\n  /**\n   * @dev Sets the maximum total supply - this only limits deposits and\n   *      does not affect interest accrual.\n   *\n   *      Can not be set lower than current total supply.\n   */\n  function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_maxTotalSupply < state.totalSupply()) {\n      revert NewMaxSupplyTooLow();\n    }\n\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n\n  /**\n   * @dev Sets the annual interest rate earned by lenders in bips.\n   */\n  function setAnnualInterestBips(uint16 _annualInterestBips) public onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n\n    state.annualInterestBips = _annualInterestBips;\n    _writeState(state);\n    emit AnnualInterestBipsUpdated(_annualInterestBips);\n  }\n\n  /**\n   * @dev Adjust the market's reserve ratio.\n   *\n   *      If the new ratio is lower than the old ratio,\n   *      asserts that the market is not currently delinquent.\n   *\n   *      If the new ratio is higher than the old ratio,\n   *      asserts that the market will not become delinquent\n   *      because of the change.\n   */\n  function setReserveRatioBips(uint16 _reserveRatioBips) public onlyController nonReentrant {\n    if (_reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n\n    MarketState memory state = _getUpdatedState();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    if (_reserveRatioBips < initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n    _writeState(state);\n    emit ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'src/interfaces/IMarketEventsAndErrors.sol';\nimport '../BaseMarketTest.sol';\n\ncontract WildcatMarketConfigTest is BaseMarketTest {\n  function test_maximumDeposit(uint256 _depositAmount) external returns (uint256) {\n    assertEq(market.maximumDeposit(), parameters.maxTotalSupply);\n    _depositAmount = bound(_depositAmount, 1, DefaultMaximumSupply);\n    _deposit(alice, _depositAmount);\n    assertEq(market.maximumDeposit(), DefaultMaximumSupply - _depositAmount);\n  }\n\n  function test_maximumDeposit_SupplyExceedsMaximum() external returns (uint256) {\n    _deposit(alice, parameters.maxTotalSupply);\n    fastForward(365 days);\n    assertEq(market.totalSupply(), 110_000e18);\n    assertEq(market.maximumDeposit(), 0);\n  }\n\n  function test_maxTotalSupply() external returns (uint256) {\n    assertEq(market.maxTotalSupply(), parameters.maxTotalSupply);\n    vm.prank(parameters.controller);\n    market.setMaxTotalSupply(10000);\n    assertEq(market.maxTotalSupply(), 10000);\n  }\n\n  function test_annualInterestBips() external returns (uint256) {\n    assertEq(market.annualInterestBips(), parameters.annualInterestBips);\n    vm.prank(parameters.controller);\n    market.setAnnualInterestBips(10000);\n    assertEq(market.annualInterestBips(), 10000);\n  }\n\n  function test_reserveRatioBips() external returns (uint256) {}\n\n  // function test_revokeAccountAuthorization(\n  //   address _account\n  // ) external asAccount(parameters.controller) {\n  //   vm.expectEmit(address(market));\n  //   emit AuthorizationStatusUpdated(_account, AuthRole.WithdrawOnly);\n  //   market.revokeAccountAuthorization(_account);\n  //   assertEq(\n  //     uint(market.getAccountRole(_account)),\n  //     uint(AuthRole.WithdrawOnly),\n  //     'account role should be WithdrawOnly'\n  //   );\n  // }\n\n  // function test_revokeAccountAuthorization_NotController(address _account) external {\n  //   vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n  //   market.revokeAccountAuthorization(_account);\n  // }\n\n  // function test_revokeAccountAuthorization_AccountBlacklisted(address _account) external {\n  //   MockSanctionsSentinel(sentinel).sanction(_account);\n  //   market.nukeFromOrbit(_account);\n  //   vm.startPrank(parameters.controller);\n  //   vm.expectRevert(IMarketEventsAndErrors.AccountBlacklisted.selector);\n  //   market.revokeAccountAuthorization(_account);\n  // }\n\n  // function test_grantAccountAuthorization(\n  //   address _account\n  // ) external asAccount(parameters.controller) {\n  //   vm.expectEmit(address(market));\n  //   emit AuthorizationStatusUpdated(_account, AuthRole.DepositAndWithdraw);\n  //   market.grantAccountAuthorization(_account);\n  //   assertEq(\n  //     uint(market.getAccountRole(_account)),\n  //     uint(AuthRole.DepositAndWithdraw),\n  //     'account role should be DepositAndWithdraw'\n  //   );\n  // }\n\n  // function test_grantAccountAuthorization_NotController(address _account) external {\n  //   vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n  //   market.grantAccountAuthorization(_account);\n  // }\n\n  // function test_grantAccountAuthorization_AccountBlacklisted(address _account) external {\n  //   MockSanctionsSentinel(sentinel).sanction(_account);\n  //   market.nukeFromOrbit(_account);\n  //   vm.startPrank(parameters.controller);\n  //   vm.expectRevert(IMarketEventsAndErrors.AccountBlacklisted.selector);\n  //   market.grantAccountAuthorization(_account);\n  // }\n\n  function test_nukeFromOrbit(address _account) external {\n    sanctionsSentinel.sanction(_account);\n\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(_account, AuthRole.Blocked);\n    market.nukeFromOrbit(_account);\n    assertEq(\n      uint(market.getAccountRole(_account)),\n      uint(AuthRole.Blocked),\n      'account role should be Blocked'\n    );\n  }\n\n  function test_nukeFromOrbit_WithBalance() external {\n    _deposit(alice, 1e18);\n    address escrow = sanctionsSentinel.getEscrowAddress(alice, borrower, address(market));\n    sanctionsSentinel.sanction(alice);\n\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(alice, AuthRole.Blocked);\n    vm.expectEmit(address(market));\n    emit Transfer(alice, escrow, 1e18);\n    vm.expectEmit(address(market));\n    emit SanctionedAccountAssetsSentToEscrow(alice, escrow, 1e18);\n    market.nukeFromOrbit(alice);\n    assertEq(\n      uint(market.getAccountRole(alice)),\n      uint(AuthRole.Blocked),\n      'account role should be Blocked'\n    );\n  }\n\n  function test_nukeFromOrbit_BadLaunchCode(address _account) external {\n    vm.expectRevert(IMarketEventsAndErrors.BadLaunchCode.selector);\n    market.nukeFromOrbit(_account);\n  }\n\n  function test_stunningReversal() external {\n    sanctionsSentinel.sanction(alice);\n\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(alice, AuthRole.Blocked);\n    market.nukeFromOrbit(alice);\n\n    vm.prank(borrower);\n    sanctionsSentinel.overrideSanction(alice);\n\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(alice, AuthRole.Null);\n    market.stunningReversal(alice);\n    assertEq(uint(market.getAccountRole(alice)), uint(AuthRole.Null), 'account role should be Null');\n  }\n\n  function test_stunningReversal_AccountNotBlocked(address _account) external {\n    vm.expectRevert(IMarketEventsAndErrors.AccountNotBlocked.selector);\n    market.stunningReversal(_account);\n  }\n\n  function test_stunningReversal_NotReversedOrStunning() external {\n    sanctionsSentinel.sanction(alice);\n    vm.expectEmit(address(market));\n    emit AuthorizationStatusUpdated(alice, AuthRole.Blocked);\n    market.nukeFromOrbit(alice);\n    vm.expectRevert(IMarketEventsAndErrors.NotReversedOrStunning.selector);\n    market.stunningReversal(alice);\n  }\n\n  function test_setMaxTotalSupply(\n    uint256 _totalSupply,\n    uint256 _maxTotalSupply\n  ) external asAccount(parameters.controller) {\n    _totalSupply = bound(_totalSupply, 0, DefaultMaximumSupply);\n    _maxTotalSupply = bound(_maxTotalSupply, _totalSupply, type(uint128).max);\n    if (_totalSupply > 0) {\n      _deposit(alice, _totalSupply);\n    }\n    market.setMaxTotalSupply(_maxTotalSupply);\n    assertEq(market.maxTotalSupply(), _maxTotalSupply, 'maxTotalSupply should be _maxTotalSupply');\n  }\n\n  function test_setMaxTotalSupply_NotController(uint128 _maxTotalSupply) external {\n    vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n    market.setMaxTotalSupply(_maxTotalSupply);\n  }\n\n  function test_setMaxTotalSupply_NewMaxSupplyTooLow(\n    uint256 _totalSupply,\n    uint256 _maxTotalSupply\n  ) external asAccount(parameters.controller) {\n    _totalSupply = bound(_totalSupply, 1, DefaultMaximumSupply - 1);\n    _maxTotalSupply = bound(_maxTotalSupply, 0, _totalSupply - 1);\n    _deposit(alice, _totalSupply);\n    vm.expectRevert(IMarketEventsAndErrors.NewMaxSupplyTooLow.selector);\n    market.setMaxTotalSupply(_maxTotalSupply);\n  }\n\n  function test_setAnnualInterestBips(\n    uint16 _annualInterestBips\n  ) external asAccount(parameters.controller) {\n    _annualInterestBips = uint16(bound(_annualInterestBips, 0, 10000));\n    market.setAnnualInterestBips(_annualInterestBips);\n    assertEq(market.annualInterestBips(), _annualInterestBips);\n  }\n\n  function test_setAnnualInterestBips_InterestRateTooHigh()\n    external\n    asAccount(parameters.controller)\n  {\n    vm.expectRevert(IMarketEventsAndErrors.InterestRateTooHigh.selector);\n    market.setAnnualInterestBips(10001);\n  }\n\n  function test_setAnnualInterestBips_NotController(uint16 _annualInterestBips) external {\n    vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n    market.setAnnualInterestBips(_annualInterestBips);\n  }\n\n  function test_setReserveRatioBips(\n    uint256 _reserveRatioBips\n  ) external asAccount(parameters.controller) {\n    _reserveRatioBips = bound(_reserveRatioBips, 0, 10000);\n    market.setReserveRatioBips(uint16(_reserveRatioBips));\n    assertEq(market.reserveRatioBips(), _reserveRatioBips);\n  }\n\n  /* \tfunction test_setReserveRatioBips_IncreaseWhileDelinquent(\n\t\tuint256 _reserveRatioBips\n\t) external asAccount(parameters.controller) {\n\t\t_reserveRatioBips = bound(\n\t\t\t_reserveRatioBips,\n\t\t\tparameters.reserveRatioBips + 1,\n\t\t\t10000\n\t\t);\n\t\t_induceDelinquency();\n\t\tvm.expectEmit(address(market));\n\t\temit ReserveRatioBipsUpdated(uint16(_reserveRatioBips));\n\t\tmarket.setReserveRatioBips(uint16(_reserveRatioBips));\n\t\tassertEq(market.reserveRatioBips(), _reserveRatioBips);\n\t} */\n\n  function _induceDelinquency() internal {\n    _deposit(alice, 1e18);\n    _borrow(2e17);\n    _requestWithdrawal(alice, 9e17);\n  }\n\n  function test_setReserveRatioBips_ReserveRatioBipsTooHigh()\n    external\n    asAccount(parameters.controller)\n  {\n    vm.expectRevert(IMarketEventsAndErrors.ReserveRatioBipsTooHigh.selector);\n    market.setReserveRatioBips(10001);\n  }\n\n  // Market already deliquent, LCR set to lower value\n  function test_setReserveRatioBips_InsufficientReservesForOldLiquidityRatio()\n    external\n    asAccount(parameters.controller)\n  {\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    vm.expectRevert(IMarketEventsAndErrors.InsufficientReservesForOldLiquidityRatio.selector);\n    market.setReserveRatioBips(1000);\n  }\n\n  function test_setReserveRatioBips_InsufficientReservesForNewLiquidityRatio()\n    external\n    asAccount(parameters.controller)\n  {\n    _deposit(alice, 1e18);\n    _borrow(7e17);\n    vm.expectRevert(IMarketEventsAndErrors.InsufficientReservesForNewLiquidityRatio.selector);\n    market.setReserveRatioBips(3001);\n  }\n\n  function test_setReserveRatioBips_NotController(uint16 _reserveRatioBips) external {\n    vm.expectRevert(IMarketEventsAndErrors.NotController.selector);\n    market.setReserveRatioBips(_reserveRatioBips);\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.normalizeAmount(_accounts[account].scaledBalance);\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.totalSupply();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Actions                               */\n  /* -------------------------------------------------------------------------- */\n\n  function approve(address spender, uint256 amount) external virtual nonReentrant returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) external virtual nonReentrant returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit Approval(approver, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) {\n      revert NullTransferAmount();\n    }\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit Transfer(from, to, amount);\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MockERC20 } from 'solmate/test/utils/mocks/MockERC20.sol';\nimport { BaseERC20Test } from '../helpers/BaseERC20Test.sol';\nimport '../shared/TestConstants.sol';\nimport '../shared/Test.sol';\n\nbytes32 constant DaiSalt = bytes32(uint256(1));\n\ncontract WildcatMarketTokenTest is BaseERC20Test, Test {\n  using MarketStateLib for MarketState;\n\n  // WildcatMarketFactory internal factory;\n  // WildcatMarketController internal controller;\n  MockERC20 internal asset;\n  address internal feeRecipient = address(0xfee);\n  address internal borrower = address(this);\n\n  function bound(\n    uint x,\n    uint min,\n    uint max\n  ) internal view virtual override(StdUtils, Test) returns (uint256 result) {\n    return Test.bound(x, min, max);\n  }\n\n  function _maxAmount() internal override returns (uint256) {\n    return uint256(type(uint104).max);\n  }\n\n  function _minAmount() internal override returns (uint256 min) {\n    min = divUp(WildcatMarket(address(token)).scaleFactor(), RAY);\n  }\n\n  function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      if iszero(d) {\n        // Store the function selector of `DivFailed()`.\n        mstore(0x00, 0x65244e4e)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := add(iszero(iszero(mod(x, d))), div(x, d))\n    }\n  }\n\n  function setUp() public override {\n    asset = new MockERC20('Token', 'TKN', 18);\n\n    MarketParameters memory marketParameters = MarketParameters({\n      asset: address(asset),\n      namePrefix: 'Wildcat ',\n      symbolPrefix: 'WC',\n      borrower: borrower,\n      controller: controllerFactory.computeControllerAddress(borrower),\n      feeRecipient: feeRecipient,\n      sentinel: address(sanctionsSentinel),\n      maxTotalSupply: uint128(_maxAmount()),\n      protocolFeeBips: DefaultProtocolFeeBips,\n      annualInterestBips: 10000,\n      delinquencyFeeBips: DefaultDelinquencyFee,\n      withdrawalBatchDuration: 0,\n      delinquencyGracePeriod: DefaultGracePeriod,\n      reserveRatioBips: DefaultReserveRatio\n    });\n    deployControllerAndMarket(marketParameters, true, true);\n    token = IERC20Metadata(address(market));\n    _name = 'Wildcat Token';\n    _symbol = 'WCTKN';\n    _decimals = 18;\n    // vm.warp(block.timestamp + 5008);\n    // assertEq(WildcatMarket(address(token)).scaleFactor(), 2e27);\n  }\n\n  function testCtrl() external {\n    assertEq(\n      address(controller),\n      controllerFactory.computeControllerAddress(borrower),\n      'bad controller address'\n    );\n    assertTrue(MockController(address(controller)).AUTH_ALL(), 'bad auth');\n    assertEq(\n      controllerFactory.controllerInitCodeHash(),\n      uint256(keccak256(type(MockController).creationCode)),\n      'bad init code hash'\n    );\n    console2.log(market.name());\n  }\n\n  // function _assertTokenAmountEq(uint256 expected, uint256 actual) internal virtual override {\n  // \tassertEq(expected, actual);\n  // }\n\n  function _mint(address to, uint256 amount) internal override {\n    require(amount <= _maxAmount(), 'amount too large');\n    vm.startPrank(to);\n    asset.mint(to, amount);\n    asset.mint(to, amount);\n    // vm.startPrank(to);\n    asset.approve(address(token), amount);\n    WildcatMarket(address(token)).depositUpTo(amount);\n    WildcatMarket(address(token)).transfer(to, amount);\n    vm.stopPrank();\n  }\n\n  function _burn(address from, uint256 amount) internal override {\n    vm.prank(from);\n    WildcatMarket(address(token)).queueWithdrawal(amount);\n    WildcatMarket(address(token)).executeWithdrawal(from, uint32(block.timestamp));\n  }\n\n  function testTransferNullAmount() external {\n    vm.expectRevert(IMarketEventsAndErrors.NullTransferAmount.selector);\n    token.transfer(address(1), 0);\n  }\n\n  function testTransferFromNullAmount() external {\n    vm.expectRevert(IMarketEventsAndErrors.NullTransferAmount.selector);\n    token.transferFrom(address(0), address(1), 0);\n  }\n}\n"
    },
    {
      "input": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/MarketState.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/FIFOQueue.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketWithdrawals is WildcatMarketBase {\n  using SafeTransferLib for address;\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Queries                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the expiry timestamp of every unpaid withdrawal batch.\n   */\n  function getUnpaidBatchExpiries() external view nonReentrantView returns (uint32[] memory) {\n    return _withdrawalData.unpaidBatches.values();\n  }\n\n  function getWithdrawalBatch(\n    uint32 expiry\n  ) external view nonReentrantView returns (WithdrawalBatch memory) {\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    if ((expiry == expiredBatchExpiry).and(expiry > 0)) {\n      return expiredBatch;\n    }\n    return _withdrawalData.batches[expiry];\n  }\n\n  function getAccountWithdrawalStatus(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (AccountWithdrawalStatus memory) {\n    return _withdrawalData.accountStatuses[expiry][accountAddress];\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    WithdrawalBatch memory batch;\n    if (expiry == expiredBatchExpiry) {\n      batch = expiredBatch;\n    } else {\n      batch = _withdrawalData.batches[expiry];\n    }\n    AccountWithdrawalStatus memory status = _withdrawalData.accountStatuses[expiry][accountAddress];\n    // Rounding errors will lead to some dust accumulating in the batch, but the cost of\n    // executing a withdrawal will be lower for users.\n    uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n    return newTotalWithdrawn - previousTotalWithdrawn;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Actions                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Create a withdrawal request for a lender.\n   */\n  function queueWithdrawal(uint256 amount) external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Cache account data and revert if not authorized to withdraw.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.WithdrawOnly);\n\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) {\n      revert NullBurnAmount();\n    }\n\n    // Reduce caller's balance and emit transfer event.\n    account.scaledBalance -= scaledAmount;\n    _accounts[msg.sender] = account;\n    emit Transfer(msg.sender, address(this), amount);\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      state.pendingWithdrawalExpiry = uint32(block.timestamp + withdrawalBatchDuration);\n      emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n    }\n    // Cache batch expiry on the stack for gas savings.\n    uint32 expiry = state.pendingWithdrawalExpiry;\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n    _withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount += scaledAmount;\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n\n    emit WithdrawalQueued(expiry, msg.sender, scaledAmount);\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    // Update stored batch data\n    _withdrawalData.batches[expiry] = batch;\n\n    // Update stored state\n    _writeState(state);\n  }\n\n  /**\n   * @dev Execute a pending withdrawal request for a batch that has expired.\n   *\n   *      Withdraws the proportional amount of the paid batch owed to\n   *      `accountAddress` which has not already been withdrawn.\n   *\n   *      If `accountAddress` is sanctioned, transfers the owed amount to\n   *      an escrow contract specific to the account and blocks the account.\n   *\n   *      Reverts if:\n   *      - `expiry > block.timestamp`\n   *      -  `expiry` does not correspond to an existing withdrawal batch\n   *      - `accountAddress` has already withdrawn the full amount owed\n   */\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) external nonReentrant returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    MarketState memory state = _getUpdatedState();\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n\n    uint128 newTotalWithdrawn = uint128(\n      MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount)\n    );\n\n    uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n\n    status.normalizedAmountWithdrawn = newTotalWithdrawn;\n    state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n    if (normalizedAmountWithdrawn == 0) {\n      revert NullWithdrawalAmount();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      _blockAccount(state, accountAddress);\n      address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n        accountAddress,\n        borrower,\n        address(asset)\n      );\n      asset.safeTransfer(escrow, normalizedAmountWithdrawn);\n      emit SanctionedAccountWithdrawalSentToEscrow(\n        accountAddress,\n        escrow,\n        expiry,\n        normalizedAmountWithdrawn\n      );\n    } else {\n      asset.safeTransfer(accountAddress, normalizedAmountWithdrawn);\n    }\n\n    emit WithdrawalExecuted(expiry, accountAddress, normalizedAmountWithdrawn);\n\n    // Update stored state\n    _writeState(state);\n\n    return normalizedAmountWithdrawn;\n  }\n\n  function processUnpaidWithdrawalBatch() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Get the next unpaid batch timestamp from storage (reverts if none)\n    uint32 expiry = _withdrawalData.unpaidBatches.first();\n\n    // Cache batch data in memory\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Calculate assets available to process the batch\n    uint256 availableLiquidity = totalAssets() -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n\n    // Remove batch from unpaid set if fully paid\n    if (batch.scaledTotalAmount == batch.scaledAmountBurned) {\n      _withdrawalData.unpaidBatches.shift();\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    // Update stored batch\n    _withdrawalData.batches[expiry] = batch;\n    _writeState(state);\n  }\n}\n",
      "output": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../BaseMarketTest.sol';\n\ncontract WithdrawalsTest is BaseMarketTest {\n  using MathUtils for uint256;\n  using FeeMath for uint256;\n\n  function test_queueWithdrawal_NotApprovedLender() external {\n    _deposit(alice, 1e18);\n    vm.prank(alice);\n    market.transfer(bob, 1e18);\n    vm.startPrank(bob);\n    vm.expectRevert(IMarketEventsAndErrors.NotApprovedLender.selector);\n    market.queueWithdrawal(1e18);\n  }\n\n  function test_queueWithdrawal_AuthorizedWithdrawOnly() public asAccount(bob) {\n    _deposit(bob, 1e18);\n    startPrank(address(controller));\n    market.updateAccountAuthorization(bob, false);\n    stopPrank();\n    _requestWithdrawal(bob, 1e18);\n  }\n\n  function test_queueWithdrawal_AuthorizedOnController() public {\n    _deposit(alice, 1e18);\n    vm.prank(alice);\n    market.transfer(bob, 1e18);\n    _authorizeLender(bob);\n    vm.startPrank(bob);\n    market.queueWithdrawal(1e18);\n  }\n\n  function test_queueWithdrawal_NullBurnAmount() external asAccount(alice) {\n    vm.expectRevert(IMarketEventsAndErrors.NullBurnAmount.selector);\n    market.queueWithdrawal(0);\n  }\n\n  function test_queueWithdrawal_InsufficientBalance() external asAccount(alice) {\n    _deposit(alice, 1e18);\n    vm.expectRevert(abi.encodePacked(uint32(Panic_ErrorSelector), Panic_Arithmetic));\n    market.queueWithdrawal(1e18 + 1);\n  }\n\n  function test_queueWithdrawal_AddToExisting(\n    uint256 userBalance1,\n    uint256 withdrawalAmount1,\n    uint256 userBalance2,\n    uint256 withdrawalAmount2\n  ) external asAccount(alice) {\n    (userBalance1, withdrawalAmount1) = dbound(\n      userBalance1,\n      withdrawalAmount1,\n      2,\n      DefaultMaximumSupply / 2\n    );\n    (userBalance2, withdrawalAmount2) = dbound(\n      userBalance2,\n      withdrawalAmount2,\n      2,\n      DefaultMaximumSupply - userBalance1\n    );\n    _deposit(alice, userBalance1);\n    _deposit(bob, userBalance2);\n    _requestWithdrawal(alice, userBalance1);\n    _requestWithdrawal(bob, userBalance2);\n    MarketState memory state = previousState;\n    assertEq(state.isDelinquent, false, 'isDelinquent');\n    assertEq(state.timeDelinquent, 0, 'timeDelinquent');\n    assertEq(state.scaledPendingWithdrawals, 0, 'scaledPendingWithdrawals');\n    assertEq(state.scaledTotalSupply, 0, 'scaledTotalSupply');\n    assertEq(\n      state.normalizedUnclaimedWithdrawals,\n      userBalance1 + userBalance2,\n      'normalizedUnclaimedWithdrawals'\n    );\n  }\n\n  function test_queueWithdrawal_BurnAll(\n    uint128 userBalance,\n    uint128 withdrawalAmount\n  ) external asAccount(alice) {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    _deposit(alice, userBalance);\n    _requestWithdrawal(alice, userBalance);\n    MarketState memory state = previousState;\n    assertEq(state.isDelinquent, false, 'isDelinquent');\n    assertEq(state.timeDelinquent, 0, 'timeDelinquent');\n    assertEq(state.scaledPendingWithdrawals, 0, 'scaledPendingWithdrawals');\n    assertEq(state.scaledTotalSupply, 0, 'scaledTotalSupply');\n    assertEq(state.normalizedUnclaimedWithdrawals, userBalance, 'normalizedUnclaimedWithdrawals');\n  }\n\n  function test_queueWithdrawal_BurnPartial(\n    uint128 userBalance,\n    uint128 borrowAmount\n  ) external asAccount(alice) {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    borrowAmount = uint128(\n      bound(borrowAmount, 2, uint256(userBalance).bipMul(10000 - parameters.reserveRatioBips))\n    );\n    _deposit(alice, userBalance);\n    _borrow(borrowAmount);\n    _requestWithdrawal(alice, userBalance);\n    MarketState memory state = previousState;\n    assertEq(state.isDelinquent, true, 'state.isDelinquent');\n    assertEq(state.timeDelinquent, 0, 'state.timeDelinquent');\n    uint128 remainingAssets = userBalance - borrowAmount;\n\n    assertEq(state.scaledPendingWithdrawals, borrowAmount, 'state.scaledPendingWithdrawals');\n    assertEq(state.scaledTotalSupply, borrowAmount, 'state.scaledTotalSupply');\n    assertEq(\n      state.normalizedUnclaimedWithdrawals,\n      remainingAssets,\n      'state.normalizedUnclaimedWithdrawals'\n    );\n  }\n\n  function test_queueWithdrawal(\n    uint128 userBalance,\n    uint128 withdrawalAmount\n  ) external asAccount(alice) {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    withdrawalAmount = uint128(bound(withdrawalAmount, 2, userBalance));\n    _deposit(alice, userBalance);\n    _requestWithdrawal(alice, withdrawalAmount);\n  }\n\n  function test_executeWithdrawal_NotExpired(\n    uint128 userBalance,\n    uint128 withdrawalAmount\n  ) external {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    withdrawalAmount = uint128(bound(withdrawalAmount, 2, userBalance));\n    _deposit(alice, userBalance);\n    _requestWithdrawal(alice, withdrawalAmount);\n    vm.expectRevert(IMarketEventsAndErrors.WithdrawalBatchNotExpired.selector);\n    market.executeWithdrawal(alice, uint32(block.timestamp + parameters.withdrawalBatchDuration));\n  }\n\n  function test_executeWithdrawal(uint128 userBalance, uint128 withdrawalAmount) external {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    withdrawalAmount = uint128(bound(withdrawalAmount, 2, userBalance));\n    _deposit(alice, userBalance);\n    _requestWithdrawal(alice, withdrawalAmount);\n    uint256 expiry = block.timestamp + parameters.withdrawalBatchDuration;\n    fastForward(parameters.withdrawalBatchDuration);\n    MarketState memory state = pendingState();\n    updateState(state);\n    uint256 previousBalance = asset.balanceOf(alice);\n    uint256 withdrawalAmount = state.normalizedUnclaimedWithdrawals;\n    vm.prank(alice);\n    market.executeWithdrawal(alice, uint32(expiry));\n    assertEq(asset.balanceOf(alice), previousBalance + withdrawalAmount);\n  }\n\n  function test_executeWithdrawal_NullWithdrawalAmount(\n    uint128 userBalance,\n    uint128 withdrawalAmount\n  ) external {\n    userBalance = uint128(bound(userBalance, 2, DefaultMaximumSupply));\n    withdrawalAmount = uint128(bound(withdrawalAmount, 2, userBalance));\n    _deposit(alice, userBalance);\n    _requestWithdrawal(alice, withdrawalAmount);\n    uint256 expiry = block.timestamp + parameters.withdrawalBatchDuration;\n    fastForward(parameters.withdrawalBatchDuration);\n    MarketState memory state = pendingState();\n    updateState(state);\n    uint256 previousBalance = asset.balanceOf(alice);\n    uint256 withdrawalAmount = state.normalizedUnclaimedWithdrawals;\n    vm.prank(alice);\n    market.executeWithdrawal(alice, uint32(expiry));\n    assertEq(asset.balanceOf(alice), previousBalance + withdrawalAmount);\n    vm.expectRevert(IMarketEventsAndErrors.NullWithdrawalAmount.selector);\n    market.executeWithdrawal(alice, uint32(expiry));\n  }\n\n  function test_executeWithdrawal_Sanctioned() external {\n    _deposit(alice, 1e18);\n    _requestWithdrawal(alice, 1e18);\n    fastForward(parameters.withdrawalBatchDuration);\n    sanctionsSentinel.sanction(alice);\n    address escrow = sanctionsSentinel.getEscrowAddress(alice, borrower, address(asset));\n    vm.expectEmit(address(asset));\n    emit Transfer(address(market), escrow, 1e18);\n    vm.expectEmit(address(market));\n    emit SanctionedAccountWithdrawalSentToEscrow(alice, escrow, uint32(block.timestamp), 1e18);\n    market.executeWithdrawal(alice, uint32(block.timestamp));\n  }\n\n  function test_processUnpaidWithdrawalBatch_NoUnpaidBatches() external {\n    vm.expectRevert(FIFOQueueLib.FIFOQueueOutOfBounds.selector);\n    market.processUnpaidWithdrawalBatch();\n  }\n\n  function _checkBatch(\n    uint32 expiry,\n    uint256 scaledTotalAmount,\n    uint256 scaledAmountBurned,\n    uint256 normalizedAmountPaid\n  ) internal {\n    WithdrawalBatch memory batch = market.getWithdrawalBatch(expiry);\n    assertEq(batch.scaledTotalAmount, scaledTotalAmount, 'scaledAmountBurned');\n    assertEq(batch.scaledAmountBurned, scaledAmountBurned, 'scaledAmountBurned');\n    assertEq(batch.normalizedAmountPaid, normalizedAmountPaid, 'normalizedAmountPaid');\n  }\n\n  function test_processUnpaidWithdrawalBatch() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    assertEq(market.previousState().isDelinquent, true);\n    fastForward(parameters.withdrawalBatchDuration);\n    uint32 expiry = uint32(block.timestamp);\n    _checkBatch(expiry, 1e18, 2e17, 2e17);\n    updateState(pendingState());\n    market.updateState();\n    uint32[] memory unpaidBatchExpiries = market.getUnpaidBatchExpiries();\n    assertEq(unpaidBatchExpiries.length, 1);\n    assertEq(unpaidBatchExpiries[0], expiry);\n    _checkState();\n    assertEq(market.previousState().timeDelinquent, parameters.withdrawalBatchDuration);\n\n    MarketState memory state = pendingState();\n    _checkBatch(expiry, 1e18, 2e17, 2e17);\n    assertEq(state.accruedProtocolFees, uint256(8e15) / 365);\n\n    asset.mint(address(market), 8e17 + state.accruedProtocolFees);\n    market.processUnpaidWithdrawalBatch();\n    uint256 delinquencyFeeRay = FeeMath.calculateLinearInterestFromBips(\n      parameters.delinquencyFeeBips,\n      uint256(parameters.withdrawalBatchDuration).satSub(parameters.delinquencyGracePeriod)\n    );\n    uint256 baseInterestRay = FeeMath.calculateLinearInterestFromBips(\n      parameters.annualInterestBips,\n      parameters.withdrawalBatchDuration\n    );\n    uint256 feesAccruedOnWithdrawal = (delinquencyFeeRay + baseInterestRay).rayMul(8e17);\n    asset.mint(address(market), feesAccruedOnWithdrawal);\n    market.processUnpaidWithdrawalBatch();\n    _checkBatch(expiry, 1e18, 1e18, 1e18 + feesAccruedOnWithdrawal);\n    assertEq(market.getUnpaidBatchExpiries().length, 0);\n  }\n\n  function test_getWithdrawalBatch_DoesNotExist() external {\n    WithdrawalBatch memory batch = market.getWithdrawalBatch(0);\n    assertEq(batch.scaledTotalAmount, 0);\n    assertEq(batch.scaledAmountBurned, 0);\n    assertEq(batch.normalizedAmountPaid, 0);\n  }\n\n  function test_getWithdrawalBatch_Expired() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 3e17);\n    assertEq(market.previousState().isDelinquent, true);\n    fastForward(parameters.withdrawalBatchDuration);\n    uint32 expiry = uint32(block.timestamp);\n    _checkBatch(expiry, 3e17, 2e17, 2e17);\n    assertEq(market.previousState().pendingWithdrawalExpiry, expiry);\n    updateState(pendingState());\n    _requestWithdrawal(alice, 7e17);\n    fastForward(parameters.withdrawalBatchDuration);\n    updateState(pendingState());\n    _checkBatch(0, 0, 0, 0);\n  }\n\n  function test_getWithdrawalBatch_Paid() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _deposit(alice, 2e18);\n    _requestWithdrawal(alice, 1e18);\n    fastForward(parameters.withdrawalBatchDuration);\n    uint32 expiry = uint32(block.timestamp);\n    _checkBatch(expiry, 1e18, 1e18, 1e18);\n    updateState(pendingState());\n  }\n\n  function test_getAccountWithdrawalStatus() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    uint32 expiry = uint32(block.timestamp + parameters.withdrawalBatchDuration);\n    AccountWithdrawalStatus memory status = market.getAccountWithdrawalStatus(alice, expiry);\n    assertEq(status.scaledAmount, 1e18);\n    assertEq(status.normalizedAmountWithdrawn, 0);\n    fastForward(parameters.withdrawalBatchDuration);\n    market.updateState();\n    market.executeWithdrawal(alice, expiry);\n    status = market.getAccountWithdrawalStatus(alice, expiry);\n    assertEq(status.scaledAmount, 1e18);\n    assertEq(status.normalizedAmountWithdrawn, 2e17);\n  }\n\n  function test_getAvailableWithdrawalAmount() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    uint32 expiry = uint32(block.timestamp + parameters.withdrawalBatchDuration);\n    fastForward(parameters.withdrawalBatchDuration);\n    AccountWithdrawalStatus memory status = market.getAccountWithdrawalStatus(alice, expiry);\n    uint256 withdrawableAmount = market.getAvailableWithdrawalAmount(alice, expiry);\n    assertEq(withdrawableAmount, 2e17);\n  }\n\n  function test_getAvailableWithdrawalAmount_UnpaidBatch() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    uint32 expiry = uint32(block.timestamp + parameters.withdrawalBatchDuration);\n    fastForward(parameters.withdrawalBatchDuration);\n    market.updateState();\n    AccountWithdrawalStatus memory status = market.getAccountWithdrawalStatus(alice, expiry);\n    uint256 withdrawableAmount = market.getAvailableWithdrawalAmount(alice, expiry);\n    assertEq(withdrawableAmount, 2e17);\n  }\n\n  function test_getAvailableWithdrawalAmount_NotExpired() external {\n    vm.expectRevert(IMarketEventsAndErrors.WithdrawalBatchNotExpired.selector);\n    market.getAvailableWithdrawalAmount(alice, uint32(block.timestamp + 1));\n  }\n\n  function test_getAvailableWithdrawalAmount_AtExpiry() external {\n    // Borrow 80% of deposits then request withdrawal of 100% of deposits\n    _depositBorrowWithdraw(alice, 1e18, 8e17, 1e18);\n    uint32 expiry = uint32(block.timestamp + parameters.withdrawalBatchDuration);\n    fastForward(parameters.withdrawalBatchDuration);\n    AccountWithdrawalStatus memory status = market.getAccountWithdrawalStatus(alice, expiry);\n    uint256 withdrawableAmount = market.getAvailableWithdrawalAmount(alice, expiry);\n    assertEq(withdrawableAmount, 2e17);\n  }\n}\n"
    }
  ]