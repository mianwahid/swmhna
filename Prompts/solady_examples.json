[
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing enumerable sets in storage.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\n///\n/// @dev Note:\n/// In many applications, the number of elements in an enumerable set is small.\n/// This enumerable set implementation avoids storing the length and indices\n/// for up to 3 elements. Once the length exceeds 3 for the first time, the length\n/// and indices will be initialized. The amortized cost of adding elements is O(1).\n///\n/// The AddressSet implementation packs the length with the 0th entry.\nlibrary EnumerableSetLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The index must be less than the length.\n    error IndexOutOfBounds();\n\n    /// @dev The value cannot be the zero sentinel.\n    error ValueIsZeroSentinel();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A sentinel value to denote the zero value in storage.\n    /// No elements can be equal to this value.\n    /// `uint72(bytes9(keccak256(bytes(\"_ZERO_SENTINEL\"))))`.\n    uint256 private constant _ZERO_SENTINEL = 0xfbb67fda52d4bfb8bf;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, shr(96, shl(96, value)))\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := shr(96, sload(valueSlot))\n    ///     let lazyLength := shr(160, shl(160, sload(rootSlot)))\n    /// ```\n    uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED = 0x978aab92;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, value)\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := sload(valueSlot)\n    ///     let lazyLength := sload(not(rootSlot))\n    /// ```\n    uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED = 0x18fb5864;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev An enumerable address set in storage.\n    struct AddressSet {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable bytes32 set in storage.\n    struct Bytes32Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable uint256 set in storage.\n    struct Uint256Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable int256 set in storage.\n    struct Int256Set {\n        uint256 _spacer;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the number of elements in the set.\n    function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Uint256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Int256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Int256Set storage set, int256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(p, add(1, n))\n                    sstore(rootSlot, add(2, rootPacked))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    sstore(add(rootSlot, n), 0)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    sstore(add(rootSlot, n), 0)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Uint256Set storage set) internal view returns (uint256[] memory result) {\n        result = _toUints(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Int256Set storage set) internal view returns (int256[] memory result) {\n        result = _toInts(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns the element at index `i` in the set.\n    function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set.\n    function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set.\n    function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = uint256(at(_toBytes32Set(set), i));\n    }\n\n    /// @dev Returns the element at index `i` in the set.\n    function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {\n        result = int256(uint256(at(_toBytes32Set(set), i)));\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the root slot.\n    function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Returns the root slot.\n    function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a uint256 array.\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n\n    /// @dev Casts to a int256 array.\n    function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {EnumerableSetLib} from \"../src/utils/EnumerableSetLib.sol\";\nimport {LibSort} from \"../src/utils/LibSort.sol\";\nimport {LibPRNG} from \"../src/utils/LibPRNG.sol\";\n\ncontract EnumerableSetLibTest is SoladyTest {\n    using EnumerableSetLib for *;\n    using LibPRNG for *;\n\n    uint256 private constant _ZERO_SENTINEL = 0xfbb67fda52d4bfb8bf;\n\n    EnumerableSetLib.AddressSet addressSet;\n    EnumerableSetLib.AddressSet addressSet2;\n\n    EnumerableSetLib.Bytes32Set bytes32Set;\n    EnumerableSetLib.Bytes32Set bytes32Set2;\n\n    EnumerableSetLib.Uint256Set uint256Set;\n    EnumerableSetLib.Int256Set int256Set;\n\n    function testEnumerableAddressSetNoStorageCollision() public {\n        addressSet.add(address(1));\n        assertEq(addressSet2.contains(address(1)), false);\n        addressSet2.add(address(2));\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet2.contains(address(1)), false);\n        assertEq(addressSet.contains(address(2)), false);\n        addressSet.add(address(2));\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet2.contains(address(1)), false);\n        addressSet2.add(address(1));\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet2.contains(address(1)), true);\n    }\n\n    function testEnumerableBytes32SetNoStorageCollision() public {\n        bytes32Set.add(bytes32(uint256(1)));\n        assertEq(bytes32Set2.contains(bytes32(uint256(1))), false);\n        bytes32Set2.add(bytes32(uint256(2)));\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set2.contains(bytes32(uint256(1))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), false);\n        bytes32Set.add(bytes32(uint256(2)));\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set2.contains(bytes32(uint256(1))), false);\n        bytes32Set2.add(bytes32(uint256(1)));\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set2.contains(bytes32(uint256(1))), true);\n    }\n\n    function testEnumerableAddressSetBasic() public {\n        assertEq(addressSet.length(), 0);\n        assertEq(addressSet.contains(address(1)), false);\n        assertEq(addressSet.contains(address(2)), false);\n        assertEq(addressSet.contains(address(3)), false);\n        assertEq(addressSet.contains(address(4)), false);\n        assertEq(addressSet.contains(address(5)), false);\n\n        assertTrue(addressSet.add(address(1)));\n        assertFalse(addressSet.add(address(1)));\n\n        assertEq(addressSet.length(), 1);\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet.contains(address(2)), false);\n        assertEq(addressSet.contains(address(3)), false);\n        assertEq(addressSet.contains(address(4)), false);\n        assertEq(addressSet.contains(address(5)), false);\n\n        assertTrue(addressSet.add(address(2)));\n        assertFalse(addressSet.add(address(2)));\n\n        assertEq(addressSet.length(), 2);\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet.contains(address(3)), false);\n        assertEq(addressSet.contains(address(4)), false);\n        assertEq(addressSet.contains(address(5)), false);\n\n        assertTrue(addressSet.add(address(3)));\n        assertFalse(addressSet.add(address(3)));\n\n        assertEq(addressSet.length(), 3);\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet.contains(address(3)), true);\n        assertEq(addressSet.contains(address(4)), false);\n        assertEq(addressSet.contains(address(5)), false);\n\n        assertTrue(addressSet.add(address(4)));\n        assertFalse(addressSet.add(address(4)));\n\n        assertEq(addressSet.length(), 4);\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet.contains(address(3)), true);\n        assertEq(addressSet.contains(address(4)), true);\n        assertEq(addressSet.contains(address(5)), false);\n\n        assertTrue(addressSet.add(address(5)));\n        assertFalse(addressSet.add(address(5)));\n\n        assertEq(addressSet.length(), 5);\n        assertEq(addressSet.contains(address(1)), true);\n        assertEq(addressSet.contains(address(2)), true);\n        assertEq(addressSet.contains(address(3)), true);\n        assertEq(addressSet.contains(address(4)), true);\n        assertEq(addressSet.contains(address(5)), true);\n    }\n\n    function testEnumerableBytes32SetBasic() public {\n        assertEq(bytes32Set.length(), 0);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), false);\n\n        assertTrue(bytes32Set.add(bytes32(uint256(1))));\n        assertFalse(bytes32Set.add(bytes32(uint256(1))));\n\n        assertEq(bytes32Set.length(), 1);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), false);\n\n        assertTrue(bytes32Set.add(bytes32(uint256(2))));\n        assertFalse(bytes32Set.add(bytes32(uint256(2))));\n\n        assertEq(bytes32Set.length(), 2);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), false);\n\n        assertTrue(bytes32Set.add(bytes32(uint256(3))));\n        assertFalse(bytes32Set.add(bytes32(uint256(3))));\n\n        assertEq(bytes32Set.length(), 3);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), false);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), false);\n\n        assertTrue(bytes32Set.add(bytes32(uint256(4))));\n        assertFalse(bytes32Set.add(bytes32(uint256(4))));\n\n        assertEq(bytes32Set.length(), 4);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), false);\n\n        assertTrue(bytes32Set.add(bytes32(uint256(5))));\n        assertFalse(bytes32Set.add(bytes32(uint256(5))));\n\n        assertEq(bytes32Set.length(), 5);\n        assertEq(bytes32Set.contains(bytes32(uint256(1))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(2))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(3))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(4))), true);\n        assertEq(bytes32Set.contains(bytes32(uint256(5))), true);\n    }\n\n    function testEnumerableAddressSetBasic2() public {\n        addressSet.add(address(1));\n        addressSet.add(address(2));\n\n        addressSet.remove(address(1));\n        assertEq(addressSet.length(), 1);\n        addressSet.remove(address(2));\n        assertEq(addressSet.length(), 0);\n\n        addressSet.add(address(1));\n        addressSet.add(address(2));\n\n        addressSet.remove(address(2));\n        assertEq(addressSet.length(), 1);\n        addressSet.remove(address(1));\n        assertEq(addressSet.length(), 0);\n\n        addressSet.add(address(1));\n        addressSet.add(address(2));\n        addressSet.add(address(3));\n\n        addressSet.remove(address(3));\n        assertEq(addressSet.length(), 2);\n        addressSet.remove(address(2));\n        assertEq(addressSet.length(), 1);\n        addressSet.remove(address(1));\n        assertEq(addressSet.length(), 0);\n\n        addressSet.add(address(1));\n        addressSet.add(address(2));\n        addressSet.add(address(3));\n\n        addressSet.remove(address(1));\n        assertEq(addressSet.length(), 2);\n        addressSet.remove(address(2));\n        assertEq(addressSet.length(), 1);\n        addressSet.remove(address(3));\n        assertEq(addressSet.length(), 0);\n    }\n\n    function testEnumerableBytes32SetBasic2() public {\n        bytes32Set.add(bytes32(uint256(1)));\n        bytes32Set.add(bytes32(uint256(2)));\n\n        bytes32Set.remove(bytes32(uint256(1)));\n        assertEq(bytes32Set.length(), 1);\n        bytes32Set.remove(bytes32(uint256(2)));\n        assertEq(bytes32Set.length(), 0);\n\n        bytes32Set.add(bytes32(uint256(1)));\n        bytes32Set.add(bytes32(uint256(2)));\n\n        bytes32Set.remove(bytes32(uint256(2)));\n        assertEq(bytes32Set.length(), 1);\n        bytes32Set.remove(bytes32(uint256(1)));\n        assertEq(bytes32Set.length(), 0);\n\n        bytes32Set.add(bytes32(uint256(1)));\n        bytes32Set.add(bytes32(uint256(2)));\n        bytes32Set.add(bytes32(uint256(3)));\n\n        bytes32Set.remove(bytes32(uint256(3)));\n        assertEq(bytes32Set.length(), 2);\n        bytes32Set.remove(bytes32(uint256(2)));\n        assertEq(bytes32Set.length(), 1);\n        bytes32Set.remove(bytes32(uint256(1)));\n        assertEq(bytes32Set.length(), 0);\n\n        bytes32Set.add(bytes32(uint256(1)));\n        bytes32Set.add(bytes32(uint256(2)));\n        bytes32Set.add(bytes32(uint256(3)));\n\n        bytes32Set.remove(bytes32(uint256(1)));\n        assertEq(bytes32Set.length(), 2);\n        bytes32Set.remove(bytes32(uint256(2)));\n        assertEq(bytes32Set.length(), 1);\n        bytes32Set.remove(bytes32(uint256(3)));\n        assertEq(bytes32Set.length(), 0);\n    }\n\n    function testEnumerableSetFuzz(uint256 n) public {\n        if (_random() % 2 == 0) {\n            _testEnumerableAddressSetFuzz(n);\n            _testEnumerableBytes32SetFuzz(n);\n        } else {\n            if (_random() % 2 == 0) _testEnumerableAddressSetFuzz();\n            if (_random() % 2 == 0) _testEnumerableBytes32SetFuzz();\n            if (_random() % 2 == 0) _testEnumerableUint256SetFuzz();\n            if (_random() % 2 == 0) _testEnumerableInt256SetFuzz();\n        }\n    }\n\n    function _testEnumerableAddressSetFuzz(uint256 n) internal {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            prng.state = n;\n            uint256[] memory additions = new uint256[](prng.next() % 16);\n            uint256 mask = _random() % 2 == 0 ? 7 : 15;\n\n            for (uint256 i; i != additions.length; ++i) {\n                uint256 x = prng.next() & mask;\n                additions[i] = x;\n                addressSet.add(_brutalized(address(uint160(x))));\n                assertTrue(addressSet.contains(_brutalized(address(uint160(x)))));\n            }\n            LibSort.sort(additions);\n            LibSort.uniquifySorted(additions);\n            assertEq(addressSet.length(), additions.length);\n            {\n                address[] memory values = addressSet.values();\n                _checkMemory();\n                uint256[] memory valuesCasted = _toUints(values);\n                LibSort.sort(valuesCasted);\n                assertEq(valuesCasted, additions);\n            }\n\n            uint256[] memory removals = new uint256[](prng.next() % 16);\n            for (uint256 i; i != removals.length; ++i) {\n                uint256 x = prng.next() & mask;\n                removals[i] = x;\n                addressSet.remove(_brutalized(address(uint160(x))));\n                assertFalse(addressSet.contains(_brutalized(address(uint160(x)))));\n            }\n            LibSort.sort(removals);\n            LibSort.uniquifySorted(removals);\n\n            {\n                uint256[] memory difference = LibSort.difference(additions, removals);\n                address[] memory values = addressSet.values();\n                _checkMemory();\n                if (_random() % 8 == 0) _checkAddressSetValues(values);\n                uint256[] memory valuesCasted = _toUints(values);\n                LibSort.sort(valuesCasted);\n                assertEq(valuesCasted, difference);\n            }\n        }\n    }\n\n    function _testEnumerableAddressSetFuzz() internal {\n        uint256[] memory s = _makeArray(0);\n        do {\n            address r = address(uint160(_random()));\n            if (_random() % 16 == 0) _brutalizeMemory();\n            if (_random() % 2 == 0) {\n                addressSet.add(r);\n                _addToArray(s, uint256(uint160(r)));\n                assertTrue(addressSet.contains(r));\n            } else {\n                addressSet.remove(r);\n                _removeFromArray(s, uint256(uint160(r)));\n                assertFalse(addressSet.contains(r));\n            }\n            if (_random() % 16 == 0) _brutalizeMemory();\n            if (_random() % 8 == 0) {\n                _checkArraysSortedEq(_toUints(addressSet.values()), s);\n            }\n            assertEq(addressSet.length(), s.length);\n            if (s.length == 512) break;\n        } while (_random() % 8 != 0);\n        assertEq(addressSet.length(), s.length);\n        _checkArraysSortedEq(_toUints(addressSet.values()), s);\n        if (_random() % 4 == 0) {\n            unchecked {\n                for (uint256 i; i != s.length; ++i) {\n                    assertTrue(addressSet.contains(address(uint160(s[i]))));\n                }\n            }\n        }\n    }\n\n    function _testEnumerableBytes32SetFuzz(uint256 n) internal {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            prng.state = n;\n            uint256[] memory additions = new uint256[](prng.next() % 16);\n            uint256 mask = _random() % 2 == 0 ? 7 : 15;\n\n            for (uint256 i; i != additions.length; ++i) {\n                uint256 x = prng.next() & mask;\n                additions[i] = x;\n                bytes32Set.add(bytes32(x));\n                assertTrue(bytes32Set.contains(bytes32(x)));\n            }\n            LibSort.sort(additions);\n            LibSort.uniquifySorted(additions);\n            assertEq(bytes32Set.length(), additions.length);\n            {\n                bytes32[] memory values = bytes32Set.values();\n                _checkMemory();\n                uint256[] memory valuesCasted = _toUints(values);\n                LibSort.sort(valuesCasted);\n                assertEq(valuesCasted, additions);\n            }\n\n            uint256[] memory removals = new uint256[](prng.next() % 16);\n            for (uint256 i; i != removals.length; ++i) {\n                uint256 x = prng.next() & mask;\n                removals[i] = x;\n                bytes32Set.remove(bytes32(x));\n                assertFalse(bytes32Set.contains(bytes32(x)));\n            }\n            LibSort.sort(removals);\n            LibSort.uniquifySorted(removals);\n\n            {\n                uint256[] memory difference = LibSort.difference(additions, removals);\n                bytes32[] memory values = bytes32Set.values();\n                _checkMemory();\n                if (_random() % 8 == 0) _checkBytes32SetValues(values);\n                uint256[] memory valuesCasted = _toUints(values);\n                LibSort.sort(valuesCasted);\n                assertEq(valuesCasted, difference);\n            }\n        }\n    }\n\n    function _testEnumerableBytes32SetFuzz() internal {\n        uint256[] memory s = _makeArray(0);\n        do {\n            bytes32 r = bytes32(_random());\n            if (_random() % 16 == 0) _brutalizeMemory();\n            if (_random() % 2 == 0) {\n                bytes32Set.add(r);\n                _addToArray(s, uint256(r));\n                assertTrue(bytes32Set.contains(r));\n            } else {\n                bytes32Set.remove(r);\n                _removeFromArray(s, uint256(r));\n                assertFalse(bytes32Set.contains(r));\n            }\n            if (_random() % 16 == 0) _brutalizeMemory();\n            if (_random() % 16 == 0) {\n                _checkArraysSortedEq(_toUints(bytes32Set.values()), s);\n                assertEq(bytes32Set.length(), s.length);\n            }\n            if (s.length == 512) break;\n        } while (_random() % 8 != 0);\n        _checkArraysSortedEq(_toUints(bytes32Set.values()), s);\n    }\n\n    function _testEnumerableUint256SetFuzz() public {\n        uint256[] memory s = _makeArray(0);\n        uint256 mask = _random() % 2 == 0 ? 7 : type(uint256).max;\n        do {\n            uint256 r = _random() & mask;\n            if (_random() % 2 == 0) {\n                uint256Set.add(r);\n                _addToArray(s, r);\n            } else {\n                uint256Set.remove(r);\n                _removeFromArray(s, r);\n            }\n            if (_random() % 8 == 0) {\n                _checkArraysSortedEq(uint256Set.values(), s);\n                assertEq(uint256Set.length(), s.length);\n            }\n            if (s.length == 512) break;\n        } while (_random() % 16 != 0);\n        _checkArraysSortedEq(uint256Set.values(), s);\n        if (_random() % 4 == 0) {\n            unchecked {\n                for (uint256 i; i != s.length; ++i) {\n                    assertTrue(uint256Set.contains(s[i]));\n                }\n            }\n        }\n    }\n\n    function _testEnumerableInt256SetFuzz() public {\n        uint256[] memory s = _makeArray(0);\n        do {\n            uint256 r = _random();\n            if (_random() % 2 == 0) {\n                int256Set.add(int256(r));\n                _addToArray(s, uint256(r));\n            } else {\n                int256Set.remove(int256(r));\n                _removeFromArray(s, uint256(r));\n            }\n            if (_random() % 16 == 0) {\n                _checkArraysSortedEq(_toUints(int256Set.values()), s);\n                assertEq(int256Set.length(), s.length);\n            }\n            if (s.length == 512) break;\n        } while (_random() % 8 != 0);\n        _checkArraysSortedEq(_toUints(int256Set.values()), s);\n    }\n\n    function _checkArraysSortedEq(uint256[] memory a, uint256[] memory b) internal {\n        LibSort.sort(a);\n        LibSort.sort(b);\n        assertEq(a, b);\n    }\n\n    function _checkAddressSetValues(address[] memory values) internal {\n        unchecked {\n            for (uint256 i; i != values.length; ++i) {\n                assertEq(addressSet.at(i), values[i]);\n            }\n            vm.expectRevert(EnumerableSetLib.IndexOutOfBounds.selector);\n            addressSetAt(_bound(_random(), values.length, type(uint256).max));\n        }\n    }\n\n    function _checkBytes32SetValues(bytes32[] memory values) internal {\n        unchecked {\n            for (uint256 i; i != values.length; ++i) {\n                assertEq(bytes32Set.at(i), values[i]);\n            }\n            vm.expectRevert(EnumerableSetLib.IndexOutOfBounds.selector);\n            bytes32SetAt(_bound(_random(), values.length, type(uint256).max));\n        }\n    }\n\n    function testEnumerableAddressSetRevertsOnSentinel(uint256) public {\n        do {\n            address a = address(uint160(_random()));\n            if (_random() % 32 == 0) {\n                a = address(uint160(_ZERO_SENTINEL));\n            }\n            uint256 r = _random() % 3;\n            if (r == 0) {\n                if (a == address(uint160(_ZERO_SENTINEL))) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.addToAddressSet(a);\n            }\n            if (r == 1) {\n                if (a == address(uint160(_ZERO_SENTINEL))) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.addressSetContains(a);\n            }\n            if (r == 2) {\n                if (a == address(uint160(_ZERO_SENTINEL))) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.removeFromAddressSet(a);\n            }\n        } while (_random() % 2 != 0);\n    }\n\n    function testEnumerableBytes32SetRevertsOnSentinel(uint256) public {\n        do {\n            bytes32 a = bytes32(_random());\n            if (_random() % 32 == 0) {\n                a = bytes32(_ZERO_SENTINEL);\n            }\n            uint256 r = _random() % 3;\n            if (r == 0) {\n                if (a == bytes32(_ZERO_SENTINEL)) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.addToBytes32Set(a);\n            }\n            if (r == 1) {\n                if (a == bytes32(_ZERO_SENTINEL)) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.bytes32SetContains(a);\n            }\n            if (r == 2) {\n                if (a == bytes32(_ZERO_SENTINEL)) {\n                    vm.expectRevert(EnumerableSetLib.ValueIsZeroSentinel.selector);\n                }\n                this.removeFromBytes32Set(a);\n            }\n        } while (_random() % 2 != 0);\n    }\n\n    function addToAddressSet(address a) public returns (bool) {\n        return addressSet.add(a);\n    }\n\n    function addressSetContains(address a) public view returns (bool) {\n        return addressSet.contains(a);\n    }\n\n    function removeFromAddressSet(address a) public returns (bool) {\n        return addressSet.remove(a);\n    }\n\n    function addressSetAt(uint256 i) public view returns (address) {\n        return addressSet.at(i);\n    }\n\n    function addToBytes32Set(bytes32 a) public returns (bool) {\n        return bytes32Set.add(a);\n    }\n\n    function bytes32SetContains(bytes32 a) public view returns (bool) {\n        return bytes32Set.contains(a);\n    }\n\n    function removeFromBytes32Set(bytes32 a) public returns (bool) {\n        return bytes32Set.remove(a);\n    }\n\n    function bytes32SetAt(uint256 i) public view returns (bytes32) {\n        return bytes32Set.at(i);\n    }\n\n    function _toUints(address[] memory a) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    function _makeArray(uint256 size, uint256 maxCap)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, size)\n            mstore(0x40, add(result, shl(5, add(maxCap, 1))))\n        }\n    }\n\n    function _makeArray(uint256 size) internal pure returns (uint256[] memory result) {\n        require(size <= 512, \"Size too big.\");\n        result = _makeArray(size, 512);\n    }\n\n    function _addToArray(uint256[] memory a, uint256 x) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let exists := 0\n            let n := mload(a)\n            for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                let o := add(add(a, 0x20), shl(5, i))\n                if eq(mload(o), x) {\n                    exists := 1\n                    break\n                }\n            }\n            if iszero(exists) {\n                n := add(n, 1)\n                mstore(add(a, shl(5, n)), x)\n                mstore(a, n)\n            }\n        }\n    }\n\n    function _removeFromArray(uint256[] memory a, uint256 x) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                let o := add(add(a, 0x20), shl(5, i))\n                if eq(mload(o), x) {\n                    mstore(o, mload(add(a, shl(5, n))))\n                    mstore(a, sub(n, 1))\n                    break\n                }\n            }\n        }\n    }\n}\n",
        "contractname": "EnumerableSetLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for computing contract addresses from their deployer and nonce.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibRLP.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\nlibrary LibRLP {\n    /// @dev Returns the address where a contract will be stored if deployed via\n    /// `deployer` with `nonce` using the `CREATE` opcode.\n    /// For the specification of the Recursive Length Prefix (RLP)\n    /// encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper\n    /// (https://ethereum.github.io/yellowpaper/paper.pdf)\n    /// and the Ethereum Wiki (https://eth.wiki/fundamentals/rlp).\n    ///\n    /// Based on the EIP-161 (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md)\n    /// specification, all contract accounts on the Ethereum mainnet are initiated with\n    /// `nonce = 1`. Thus, the first contract address created by another contract\n    /// is calculated with a non-zero nonce.\n    ///\n    /// The theoretical allowed limit, based on EIP-2681\n    /// (https://eips.ethereum.org/EIPS/eip-2681), for an account nonce is 2**64-2.\n    ///\n    /// Caution! This function will NOT check that the nonce is within the theoretical range.\n    /// This is for performance, as exceeding the range is extremely impractical.\n    /// It is the user's responsibility to ensure that the nonce is valid\n    /// (e.g. no dirty bits after packing / unpacking).\n    ///\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function computeAddress(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its\n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibRLP} from \"../src/utils/LibRLP.sol\";\n\ncontract LibRLPTest is SoladyTest {\n    function testComputeAddressDifferential(address deployer, uint256 nonce) public {\n        assertEq(LibRLP.computeAddress(deployer, nonce), computeAddressOriginal(deployer, nonce));\n    }\n\n    function testComputeAddressForSmallNonces() public {\n        address deployer = address(1);\n        assertTrue(LibRLP.computeAddress(deployer, 1) != address(0));\n        assertTrue(LibRLP.computeAddress(deployer, 0x7f) != address(0));\n        assertTrue(LibRLP.computeAddress(deployer, 0xff) != address(0));\n    }\n\n    function testComputeAddressOriginalForSmallNonces() public {\n        address deployer = address(1);\n        assertTrue(computeAddressOriginal(deployer, 1) != address(0));\n        assertTrue(computeAddressOriginal(deployer, 0x7f) != address(0));\n        assertTrue(computeAddressOriginal(deployer, 0xff) != address(0));\n    }\n\n    function testComputeAddressForLargeNonces() public {\n        address deployer = address(1);\n        assertTrue(LibRLP.computeAddress(deployer, 0xffffffff) != address(0));\n        assertTrue(LibRLP.computeAddress(deployer, 0xffffffffffffff) != address(0));\n        assertTrue(LibRLP.computeAddress(deployer, 0xffffffffffffffff) != address(0));\n    }\n\n    function testComputeAddressOriginalForLargeNonces() public {\n        address deployer = address(1);\n        assertTrue(computeAddressOriginal(deployer, 0xffffffff) != address(0));\n        assertTrue(computeAddressOriginal(deployer, 0xffffffffffffff) != address(0));\n        assertTrue(computeAddressOriginal(deployer, 0xffffffffffffffff) != address(0));\n    }\n\n    function computeAddressOriginal(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address)\n    {\n        // Although the theoretical allowed limit, based on EIP-2681,\n        // for an account nonce is 2**64-2: https://eips.ethereum.org/EIPS/eip-2681,\n        // we just test all the way to 2**256-1 to ensure that the computeAddress function does not revert\n        // for whatever nonce we provide.\n        // forgefmt: disable-next-item\n        if (nonce == 0x00) {\n            return address(\n                uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))))\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= 0x7f) {\n            return address(\n                uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))))\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint8).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint16).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint24).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint32).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint40).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xdb), bytes1(0x94), deployer, bytes1(0x85), uint40(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint48).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xdc), bytes1(0x94), deployer, bytes1(0x86), uint48(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint56).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xdd), bytes1(0x94), deployer, bytes1(0x87), uint56(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint64).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xde), bytes1(0x94), deployer, bytes1(0x88), uint64(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint72).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xdf), bytes1(0x94), deployer, bytes1(0x89), uint72(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint80).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe0), bytes1(0x94), deployer, bytes1(0x8a), uint80(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint88).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe1), bytes1(0x94), deployer, bytes1(0x8b), uint88(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint96).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe2), bytes1(0x94), deployer, bytes1(0x8c), uint96(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint104).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe3), bytes1(0x94), deployer, bytes1(0x8d), uint104(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint112).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe4), bytes1(0x94), deployer, bytes1(0x8e), uint112(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint120).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe5), bytes1(0x94), deployer, bytes1(0x8f), uint120(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint128).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe6), bytes1(0x94), deployer, bytes1(0x90), uint128(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint136).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe7), bytes1(0x94), deployer, bytes1(0x91), uint136(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint144).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe8), bytes1(0x94), deployer, bytes1(0x92), uint144(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint152).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xe9), bytes1(0x94), deployer, bytes1(0x93), uint152(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint160).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xea), bytes1(0x94), deployer, bytes1(0x94), uint160(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint168).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xeb), bytes1(0x94), deployer, bytes1(0x95), uint168(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint176).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xec), bytes1(0x94), deployer, bytes1(0x96), uint176(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint184).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xed), bytes1(0x94), deployer, bytes1(0x97), uint184(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint192).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xee), bytes1(0x94), deployer, bytes1(0x98), uint192(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint200).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xef), bytes1(0x94), deployer, bytes1(0x99), uint200(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint208).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf0), bytes1(0x94), deployer, bytes1(0x9a), uint208(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint216).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf1), bytes1(0x94), deployer, bytes1(0x9b), uint216(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint224).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf2), bytes1(0x94), deployer, bytes1(0x9c), uint224(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint232).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf3), bytes1(0x94), deployer, bytes1(0x9d), uint232(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint240).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf4), bytes1(0x94), deployer, bytes1(0x9e), uint240(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint248).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf5), bytes1(0x94), deployer, bytes1(0x9f), uint248(nonce)))\n                    )\n                )\n            );\n        }\n        // forgefmt: disable-next-item\n        if (nonce <= type(uint256).max) {\n            return address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(bytes1(0xf6), bytes1(0x94), deployer, bytes1(0xa0), uint256(nonce)))\n                    )\n                )\n            );\n        }\n        revert();\n    }\n}\n",
        "contractname": "LibRLP.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    error Overflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function toInt8(int256 x) internal pure returns (int8) {\n        int8 y = int8(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt16(int256 x) internal pure returns (int16) {\n        int16 y = int16(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt24(int256 x) internal pure returns (int24) {\n        int24 y = int24(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt32(int256 x) internal pure returns (int32) {\n        int32 y = int32(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt40(int256 x) internal pure returns (int40) {\n        int40 y = int40(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt48(int256 x) internal pure returns (int48) {\n        int48 y = int48(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt56(int256 x) internal pure returns (int56) {\n        int56 y = int56(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt64(int256 x) internal pure returns (int64) {\n        int64 y = int64(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt72(int256 x) internal pure returns (int72) {\n        int72 y = int72(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt80(int256 x) internal pure returns (int80) {\n        int80 y = int80(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt88(int256 x) internal pure returns (int88) {\n        int88 y = int88(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt96(int256 x) internal pure returns (int96) {\n        int96 y = int96(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt104(int256 x) internal pure returns (int104) {\n        int104 y = int104(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt112(int256 x) internal pure returns (int112) {\n        int112 y = int112(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt120(int256 x) internal pure returns (int120) {\n        int120 y = int120(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt128(int256 x) internal pure returns (int128) {\n        int128 y = int128(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt136(int256 x) internal pure returns (int136) {\n        int136 y = int136(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt144(int256 x) internal pure returns (int144) {\n        int144 y = int144(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt152(int256 x) internal pure returns (int152) {\n        int152 y = int152(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt160(int256 x) internal pure returns (int160) {\n        int160 y = int160(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt168(int256 x) internal pure returns (int168) {\n        int168 y = int168(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt176(int256 x) internal pure returns (int176) {\n        int176 y = int176(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt184(int256 x) internal pure returns (int184) {\n        int184 y = int184(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt192(int256 x) internal pure returns (int192) {\n        int192 y = int192(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt200(int256 x) internal pure returns (int200) {\n        int200 y = int200(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt208(int256 x) internal pure returns (int208) {\n        int208 y = int208(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt216(int256 x) internal pure returns (int216) {\n        int216 y = int216(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt224(int256 x) internal pure returns (int224) {\n        int224 y = int224(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt232(int256 x) internal pure returns (int232) {\n        int232 y = int232(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt240(int256 x) internal pure returns (int240) {\n        int240 y = int240(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt248(int256 x) internal pure returns (int248) {\n        int248 y = int248(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (x >= 1 << 255) _revertOverflow();\n        return int256(x);\n    }\n\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x < 0) _revertOverflow();\n        return uint256(x);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {SafeCastLib} from \"../src/utils/SafeCastLib.sol\";\n\ncontract SafeCastLibTest is SoladyTest {\n    function testSafeCastToUint(uint256 x) public {\n        assertEq(SafeCastLib.toUint8(uint8(x)), uint8(x));\n        if (x >= (1 << 8)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint8(x);\n        assertEq(SafeCastLib.toUint16(uint16(x)), uint16(x));\n        if (x >= (1 << 16)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint16(x);\n        assertEq(SafeCastLib.toUint24(uint24(x)), uint24(x));\n        if (x >= (1 << 24)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint24(x);\n        assertEq(SafeCastLib.toUint32(uint32(x)), uint32(x));\n        if (x >= (1 << 32)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint32(x);\n        assertEq(SafeCastLib.toUint40(uint40(x)), uint40(x));\n        if (x >= (1 << 40)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint40(x);\n        assertEq(SafeCastLib.toUint48(uint48(x)), uint48(x));\n        if (x >= (1 << 48)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint48(x);\n        assertEq(SafeCastLib.toUint56(uint56(x)), uint56(x));\n        if (x >= (1 << 56)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint56(x);\n        assertEq(SafeCastLib.toUint64(uint64(x)), uint64(x));\n        if (x >= (1 << 64)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint64(x);\n        assertEq(SafeCastLib.toUint72(uint72(x)), uint72(x));\n        if (x >= (1 << 72)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint72(x);\n        assertEq(SafeCastLib.toUint80(uint80(x)), uint80(x));\n        if (x >= (1 << 80)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint80(x);\n        assertEq(SafeCastLib.toUint88(uint88(x)), uint88(x));\n        if (x >= (1 << 88)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint88(x);\n        assertEq(SafeCastLib.toUint96(uint96(x)), uint96(x));\n        if (x >= (1 << 96)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint96(x);\n        assertEq(SafeCastLib.toUint104(uint104(x)), uint104(x));\n        if (x >= (1 << 104)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint104(x);\n        assertEq(SafeCastLib.toUint112(uint112(x)), uint112(x));\n        if (x >= (1 << 112)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint112(x);\n        assertEq(SafeCastLib.toUint120(uint120(x)), uint120(x));\n        if (x >= (1 << 120)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint120(x);\n        assertEq(SafeCastLib.toUint128(uint128(x)), uint128(x));\n        if (x >= (1 << 128)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint128(x);\n        assertEq(SafeCastLib.toUint136(uint136(x)), uint136(x));\n        if (x >= (1 << 136)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint136(x);\n        assertEq(SafeCastLib.toUint144(uint144(x)), uint144(x));\n        if (x >= (1 << 144)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint144(x);\n        assertEq(SafeCastLib.toUint152(uint152(x)), uint152(x));\n        if (x >= (1 << 152)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint152(x);\n        assertEq(SafeCastLib.toUint160(uint160(x)), uint160(x));\n        if (x >= (1 << 160)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint160(x);\n        assertEq(SafeCastLib.toUint168(uint168(x)), uint168(x));\n        if (x >= (1 << 168)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint168(x);\n        assertEq(SafeCastLib.toUint176(uint176(x)), uint176(x));\n        if (x >= (1 << 176)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint176(x);\n        assertEq(SafeCastLib.toUint184(uint184(x)), uint184(x));\n        if (x >= (1 << 184)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint184(x);\n        assertEq(SafeCastLib.toUint192(uint192(x)), uint192(x));\n        if (x >= (1 << 192)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint192(x);\n        assertEq(SafeCastLib.toUint200(uint200(x)), uint200(x));\n        if (x >= (1 << 200)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint200(x);\n        assertEq(SafeCastLib.toUint208(uint208(x)), uint208(x));\n        if (x >= (1 << 208)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint208(x);\n        assertEq(SafeCastLib.toUint216(uint216(x)), uint216(x));\n        if (x >= (1 << 216)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint216(x);\n        assertEq(SafeCastLib.toUint224(uint224(x)), uint224(x));\n        if (x >= (1 << 224)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint224(x);\n        assertEq(SafeCastLib.toUint232(uint232(x)), uint232(x));\n        if (x >= (1 << 232)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint232(x);\n        assertEq(SafeCastLib.toUint240(uint240(x)), uint240(x));\n        if (x >= (1 << 240)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint240(x);\n        assertEq(SafeCastLib.toUint248(uint248(x)), uint248(x));\n        if (x >= (1 << 248)) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toUint248(x);\n    }\n\n    function testSafeCastToUint() public {\n        unchecked {\n            for (uint256 i; i != 256; ++i) {\n                testSafeCastToUint(1 << i);\n                testSafeCastToUint(type(uint256).max >> i);\n                testSafeCastToUint(_random());\n            }\n        }\n    }\n\n    function testSafeCastToUintBench() public {\n        unchecked {\n            uint256 sum;\n            for (uint256 i; i != 127; ++i) {\n                sum += uint256(SafeCastLib.toUint8(i));\n                sum += uint256(SafeCastLib.toUint16(i));\n                sum += uint256(SafeCastLib.toUint24(i));\n                sum += uint256(SafeCastLib.toUint32(i));\n                sum += uint256(SafeCastLib.toUint40(i));\n                sum += uint256(SafeCastLib.toUint48(i));\n                sum += uint256(SafeCastLib.toUint56(i));\n                sum += uint256(SafeCastLib.toUint64(i));\n                sum += uint256(SafeCastLib.toUint72(i));\n                sum += uint256(SafeCastLib.toUint80(i));\n                sum += uint256(SafeCastLib.toUint88(i));\n                sum += uint256(SafeCastLib.toUint96(i));\n                sum += uint256(SafeCastLib.toUint104(i));\n                sum += uint256(SafeCastLib.toUint112(i));\n                sum += uint256(SafeCastLib.toUint120(i));\n                sum += uint256(SafeCastLib.toUint128(i));\n                sum += uint256(SafeCastLib.toUint136(i));\n                sum += uint256(SafeCastLib.toUint144(i));\n                sum += uint256(SafeCastLib.toUint152(i));\n                sum += uint256(SafeCastLib.toUint160(i));\n                sum += uint256(SafeCastLib.toUint168(i));\n                sum += uint256(SafeCastLib.toUint176(i));\n                sum += uint256(SafeCastLib.toUint184(i));\n                sum += uint256(SafeCastLib.toUint192(i));\n                sum += uint256(SafeCastLib.toUint200(i));\n                sum += uint256(SafeCastLib.toUint208(i));\n                sum += uint256(SafeCastLib.toUint216(i));\n                sum += uint256(SafeCastLib.toUint224(i));\n                sum += uint256(SafeCastLib.toUint232(i));\n                sum += uint256(SafeCastLib.toUint240(i));\n                sum += uint256(SafeCastLib.toUint248(i));\n            }\n            assertTrue(sum > 100);\n        }\n    }\n\n    function testSafeCastToInt(int256 x) public {\n        assertEq(SafeCastLib.toInt8(int8(x)), int8(x));\n        if (int8(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt8(x);\n        assertEq(SafeCastLib.toInt16(int16(x)), int16(x));\n        if (int16(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt16(x);\n        assertEq(SafeCastLib.toInt24(int24(x)), int24(x));\n        if (int24(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt24(x);\n        assertEq(SafeCastLib.toInt32(int32(x)), int32(x));\n        if (int32(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt32(x);\n        assertEq(SafeCastLib.toInt40(int40(x)), int40(x));\n        if (int40(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt40(x);\n        assertEq(SafeCastLib.toInt48(int48(x)), int48(x));\n        if (int48(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt48(x);\n        assertEq(SafeCastLib.toInt56(int56(x)), int56(x));\n        if (int56(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt56(x);\n        assertEq(SafeCastLib.toInt64(int64(x)), int64(x));\n        if (int64(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt64(x);\n        assertEq(SafeCastLib.toInt72(int72(x)), int72(x));\n        if (int72(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt72(x);\n        assertEq(SafeCastLib.toInt80(int80(x)), int80(x));\n        if (int80(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt80(x);\n        assertEq(SafeCastLib.toInt88(int88(x)), int88(x));\n        if (int88(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt88(x);\n        assertEq(SafeCastLib.toInt96(int96(x)), int96(x));\n        if (int96(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt96(x);\n        assertEq(SafeCastLib.toInt104(int104(x)), int104(x));\n        if (int104(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt104(x);\n        assertEq(SafeCastLib.toInt112(int112(x)), int112(x));\n        if (int112(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt112(x);\n        assertEq(SafeCastLib.toInt120(int120(x)), int120(x));\n        if (int120(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt120(x);\n        assertEq(SafeCastLib.toInt128(int128(x)), int128(x));\n        if (int128(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt128(x);\n        assertEq(SafeCastLib.toInt136(int136(x)), int136(x));\n        if (int136(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt136(x);\n        assertEq(SafeCastLib.toInt144(int144(x)), int144(x));\n        if (int144(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt144(x);\n        assertEq(SafeCastLib.toInt152(int152(x)), int152(x));\n        if (int152(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt152(x);\n        assertEq(SafeCastLib.toInt160(int160(x)), int160(x));\n        if (int160(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt160(x);\n        assertEq(SafeCastLib.toInt168(int168(x)), int168(x));\n        if (int168(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt168(x);\n        assertEq(SafeCastLib.toInt176(int176(x)), int176(x));\n        if (int176(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt176(x);\n        assertEq(SafeCastLib.toInt184(int184(x)), int184(x));\n        if (int184(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt184(x);\n        assertEq(SafeCastLib.toInt192(int192(x)), int192(x));\n        if (int192(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt192(x);\n        assertEq(SafeCastLib.toInt200(int200(x)), int200(x));\n        if (int200(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt200(x);\n        assertEq(SafeCastLib.toInt208(int208(x)), int208(x));\n        if (int208(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt208(x);\n        assertEq(SafeCastLib.toInt216(int216(x)), int216(x));\n        if (int216(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt216(x);\n        assertEq(SafeCastLib.toInt224(int224(x)), int224(x));\n        if (int224(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt224(x);\n        assertEq(SafeCastLib.toInt232(int232(x)), int232(x));\n        if (int232(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt232(x);\n        assertEq(SafeCastLib.toInt240(int240(x)), int240(x));\n        if (int240(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt240(x);\n        assertEq(SafeCastLib.toInt248(int248(x)), int248(x));\n        if (int248(x) != x) vm.expectRevert(SafeCastLib.Overflow.selector);\n        SafeCastLib.toInt248(x);\n    }\n\n    function testSafeCastToInt256(uint256 x) public {\n        if (x > uint256(type(int256).max)) {\n            vm.expectRevert(SafeCastLib.Overflow.selector);\n            SafeCastLib.toInt256(x);\n        } else {\n            assertEq(SafeCastLib.toInt256(x), int256(x));\n        }\n    }\n\n    function testSafeCastToUint256(int256 x) public {\n        if (x < 0) {\n            vm.expectRevert(SafeCastLib.Overflow.selector);\n            SafeCastLib.toUint256(x);\n        } else {\n            assertEq(SafeCastLib.toUint256(x), uint256(x));\n        }\n    }\n\n    function testSafeCastToIntBench() public {\n        unchecked {\n            int256 sum;\n            for (int256 i; i != 127; ++i) {\n                sum += int256(SafeCastLib.toInt8(i));\n                sum += int256(SafeCastLib.toInt16(i));\n                sum += int256(SafeCastLib.toInt24(i));\n                sum += int256(SafeCastLib.toInt32(i));\n                sum += int256(SafeCastLib.toInt40(i));\n                sum += int256(SafeCastLib.toInt48(i));\n                sum += int256(SafeCastLib.toInt56(i));\n                sum += int256(SafeCastLib.toInt64(i));\n                sum += int256(SafeCastLib.toInt72(i));\n                sum += int256(SafeCastLib.toInt80(i));\n                sum += int256(SafeCastLib.toInt88(i));\n                sum += int256(SafeCastLib.toInt96(i));\n                sum += int256(SafeCastLib.toInt104(i));\n                sum += int256(SafeCastLib.toInt112(i));\n                sum += int256(SafeCastLib.toInt120(i));\n                sum += int256(SafeCastLib.toInt128(i));\n                sum += int256(SafeCastLib.toInt136(i));\n                sum += int256(SafeCastLib.toInt144(i));\n                sum += int256(SafeCastLib.toInt152(i));\n                sum += int256(SafeCastLib.toInt160(i));\n                sum += int256(SafeCastLib.toInt168(i));\n                sum += int256(SafeCastLib.toInt176(i));\n                sum += int256(SafeCastLib.toInt184(i));\n                sum += int256(SafeCastLib.toInt192(i));\n                sum += int256(SafeCastLib.toInt200(i));\n                sum += int256(SafeCastLib.toInt208(i));\n                sum += int256(SafeCastLib.toInt216(i));\n                sum += int256(SafeCastLib.toInt224(i));\n                sum += int256(SafeCastLib.toInt232(i));\n                sum += int256(SafeCastLib.toInt240(i));\n                sum += int256(SafeCastLib.toInt248(i));\n            }\n            assertTrue(sum > 100);\n        }\n    }\n}\n",
        "contractname": "SafeCastLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for buffers with automatic capacity resizing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DynamicBuffer.sol)\n/// @author Modified from cozyco (https://github.com/samkingco/cozyco/blob/main/contracts/utils/DynamicBuffer.sol)\nlibrary DynamicBufferLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Type to represent a dynamic buffer in memory.\n    /// You can directly assign to `data`, and the `p` function will\n    /// take care of the memory allocation.\n    struct DynamicBuffer {\n        bytes data;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Reserves at least `minimum` amount of contiguous memory.\n    function reserve(DynamicBuffer memory buffer, uint256 minimum)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        uint256 n = buffer.data.length;\n        if (minimum > n) {\n            uint256 i = 0x40;\n            do {} while ((i <<= 1) < minimum);\n            bytes memory data;\n            /// @solidity memory-safe-assembly\n            assembly {\n                data := 0x00\n                mstore(data, sub(i, n))\n            }\n            result = p(result, data);\n        }\n    }\n\n    /// @dev Clears the buffer without deallocating the memory.\n    function clear(DynamicBuffer memory buffer)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(buffer), 0)\n        }\n        result = buffer;\n    }\n\n    /// @dev Returns a string pointing to the underlying bytes data.\n    /// Note: The string WILL change if the buffer is updated.\n    function s(DynamicBuffer memory buffer) internal pure returns (string memory) {\n        return string(buffer.data);\n    }\n\n    /// @dev Appends `data` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(DynamicBuffer memory buffer, bytes memory data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        if (data.length == 0) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let bufData := mload(buffer)\n            let bufDataLen := mload(bufData)\n            let newBufDataLen := add(mload(data), bufDataLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic buffer.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 1621250193422201\n            let cap := mload(add(bufData, w)) // `mload(sub(bufData, 0x20))`.\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length, and\n            // and another extra word as a safety word (giving a total of 0x40 bytes).\n            // Without the safety word, the backwards copying can cause a buffer overflow.\n            for {} iszero(lt(newBufDataLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := and(add(cap, add(or(cap, newBufDataLen), 0x20)), w)\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(bufData, add(0x40, cap))), eq(bufData, 0x60))) {\n                    // Store `cap * prime` in the word before the length.\n                    mstore(add(bufData, w), mul(prime, newCap))\n                    mstore(0x40, add(bufData, add(0x40, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newBufData` to point to the word after `cap`.\n                let newBufData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newBufData, add(0x40, newCap))) // Reallocate the memory.\n                mstore(buffer, newBufData) // Store the `newBufData`.\n                // Copy `bufData` one word at a time, backwards.\n                for { let o := and(add(bufDataLen, 0x20), w) } 1 {} {\n                    mstore(add(newBufData, o), mload(add(bufData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Store `cap * prime` in the word before the length.\n                mstore(add(newBufData, w), mul(prime, newCap))\n                bufData := newBufData // Assign `newBufData` to `bufData`.\n                break\n            }\n            // If it's a reserve operation, set the variables to skip the appending.\n            if iszero(data) {\n                mstore(data, data)\n                newBufDataLen := bufDataLen\n            }\n            // Copy `data` one word at a time, backwards.\n            for { let o := and(add(mload(data), 0x20), w) } 1 {} {\n                mstore(add(add(bufData, bufDataLen), o), mload(add(data, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            mstore(add(add(bufData, 0x20), newBufDataLen), 0) // Zeroize the word after the buffer.\n            mstore(bufData, newBufDataLen) // Store the length.\n        }\n    }\n\n    /// @dev Appends `data0`, `data1` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(p(buffer, data0), data1);\n    }\n\n    /// @dev Appends `data0` .. `data2` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(buffer, data0), data1), data2);\n    }\n\n    /// @dev Appends `data0` .. `data3` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(buffer, data0), data1), data2), data3);\n    }\n\n    /// @dev Appends `data0` .. `data4` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(buffer, data0), data1), data2), data3), data4);\n    }\n\n    /// @dev Appends `data0` .. `data5` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5);\n    }\n\n    /// @dev Appends `data0` .. `data6` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5), data6);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper for deallocating a automatically allocated `buffer` pointer.\n    function _deallocate(DynamicBuffer memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {DynamicBufferLib} from \"../src/utils/DynamicBufferLib.sol\";\n\ncontract DynamicBufferLibTest is SoladyTest {\n    using DynamicBufferLib for DynamicBufferLib.DynamicBuffer;\n\n    function testClear(uint256) public {\n        DynamicBufferLib.DynamicBuffer memory buffer;\n        bytes memory b0 = _generateRandomBytes(128, _random());\n        bytes memory b1 = _generateRandomBytes(256, _random());\n        bytes memory emptyBytes;\n        assertEq(buffer.data.length, 0);\n        assertEq(emptyBytes.length, 0);\n        if (_random() & 1 == 0) buffer.clear();\n        assertEq(buffer.data.length, 0);\n        assertEq(emptyBytes.length, 0);\n        buffer.clear().p(b0);\n        assertEq(buffer.data, b0);\n        assertEq(emptyBytes.length, 0);\n        uint256 n0 = _bound(_random(), 0, 1024);\n        uint256 n1 = _bound(_random(), 0, 4096);\n        buffer.reserve(n0).p(b1).clear().reserve(n1);\n        assertEq(buffer.data.length, 0);\n        assertEq(emptyBytes.length, 0);\n        buffer.p(b1);\n        assertEq(buffer.data, b1);\n        assertEq(emptyBytes.length, 0);\n        buffer.p(b0);\n        assertEq(buffer.data, abi.encodePacked(b1, b0));\n        assertEq(emptyBytes.length, 0);\n        buffer.clear();\n    }\n\n    function testDynamicBufferReserveFromEmpty() public {\n        uint256 m = _freeMemoryPointer();\n        DynamicBufferLib.DynamicBuffer memory buffer;\n        assertEq(_freeMemoryPointer(), m + 0x20);\n        buffer.reserve(0x200);\n        assertTrue(_freeMemoryPointer() > m + 0x20);\n        assertTrue(_freeMemoryPointer() < 0xffff);\n        m = _freeMemoryPointer();\n        buffer.reserve(0x200);\n        assertEq(_freeMemoryPointer(), m);\n        buffer.reserve(0x200);\n        assertEq(_freeMemoryPointer(), m);\n    }\n\n    function testDynamicBufferReserveFromEmpty2() public {\n        DynamicBufferLib.DynamicBuffer memory buffer;\n        _incrementFreeMemoryPointer();\n        buffer.reserve(0x200);\n        uint256 m = _freeMemoryPointer();\n        buffer.reserve(0x200);\n        assertEq(_freeMemoryPointer(), m);\n        buffer.reserve(0x200);\n        assertEq(_freeMemoryPointer(), m);\n    }\n\n    function testDynamicBufferReserveFromEmpty3(bytes calldata b, uint256 t) public {\n        DynamicBufferLib.DynamicBuffer memory buffer;\n        if (t & 1 == 0) _incrementFreeMemoryPointer();\n        if (t & 2 == 0) buffer.p(_generateRandomBytes((t >> 32) & 0xff, 1));\n        if (t & 4 == 0) buffer.p(b);\n        assertTrue(_freeMemoryPointer() < 0xffffff);\n        uint256 r = t >> 240;\n        buffer.reserve(r);\n        assertTrue(_freeMemoryPointer() < 0xffffff);\n        uint256 m = _freeMemoryPointer();\n        buffer.reserve(r);\n        assertEq(_freeMemoryPointer(), m);\n        buffer.reserve(r);\n        assertEq(_freeMemoryPointer(), m);\n    }\n\n    function _incrementFreeMemoryPointer() internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n    }\n\n    function _freeMemoryPointer() internal pure returns (uint256 m) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            m := mload(0x40)\n        }\n    }\n\n    function _bufferLocation(DynamicBufferLib.DynamicBuffer memory buffer)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(buffer)\n        }\n    }\n\n    function testDynamicBuffer(uint256) public brutalizeMemory {\n        unchecked {\n            if (_random() & 7 == 0) _misalignFreeMemoryPointer();\n            DynamicBufferLib.DynamicBuffer memory bufferA;\n            DynamicBufferLib.DynamicBuffer memory bufferB;\n            uint256 z = _bound(_random(), 32, 4096);\n            if (_random() & 7 == 0) bufferA.reserve(_random() % z);\n            if (_random() & 7 == 0) bufferB.reserve(_random() % z);\n            uint256 r = _random() % 3;\n            uint256 o = _bound(_random(), 0, 32);\n            uint256 n = _bound(_random(), 5, _random() & 7 == 0 ? 64 : 8);\n            z = z + z;\n\n            if (r == 0) {\n                for (uint256 i; i != n; ++i) {\n                    if (_random() & 7 == 0) bufferA.reserve(_random() % z);\n                    bufferA.p(_generateRandomBytes(i + o, i + z));\n                }\n                for (uint256 i; i != n; ++i) {\n                    if (_random() & 7 == 0) bufferB.reserve(_random() % z);\n                    bufferB.p(_generateRandomBytes(i + o, i + z));\n                }\n            } else if (r == 1) {\n                for (uint256 i; i != n; ++i) {\n                    if (_random() & 7 == 0) bufferB.reserve(_random() % z);\n                    bufferB.p(_generateRandomBytes(i + o, i + z));\n                }\n                for (uint256 i; i != n; ++i) {\n                    if (_random() & 7 == 0) bufferA.reserve(_random() % z);\n                    bufferA.p(_generateRandomBytes(i + o, i + z));\n                }\n            } else {\n                uint256 mode;\n                for (uint256 i; i != n; ++i) {\n                    if (_random() & 7 == 0) mode ^= 1;\n                    if (mode == 0) {\n                        if (_random() & 7 == 0) bufferA.reserve(_random() % z);\n                        bufferA.p(_generateRandomBytes(i + o, i + z));\n                        if (_random() & 7 == 0) bufferB.reserve(_random() % z);\n                        bufferB.p(_generateRandomBytes(i + o, i + z));\n                    } else {\n                        if (_random() & 7 == 0) bufferB.reserve(_random() % z);\n                        bufferB.p(_generateRandomBytes(i + o, i + z));\n                        if (_random() & 7 == 0) bufferA.reserve(_random() % z);\n                        bufferA.p(_generateRandomBytes(i + o, i + z));\n                    }\n                }\n            }\n\n            bytes memory expected;\n            for (uint256 i; i != n; ++i) {\n                expected = bytes.concat(expected, _generateRandomBytes(i + o, i + z));\n            }\n            assertEq(bufferA.data, expected);\n            assertEq(bufferB.data, expected);\n        }\n    }\n\n    function _generateRandomBytes(uint256 n, uint256 seed)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                result := mload(0x40)\n                mstore(result, n)\n                mstore(0x00, seed)\n                for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                    mstore(0x20, i)\n                    mstore(add(add(result, 0x20), i), keccak256(0x00, 0x40))\n                }\n                mstore(0x40, add(add(result, 0x20), n))\n            }\n        }\n    }\n\n    function testDynamicBuffer(bytes[] memory inputs, uint256 t) public brutalizeMemory {\n        _boundInputs(inputs);\n\n        uint256 sharedLocation;\n        if ((t >> 128) & 1 == 0) {\n            bytes memory first = _generateRandomBytes((t & 0xff | 1), t);\n            bytes memory expectedResult = first;\n            for (uint256 i; i < inputs.length; ++i) {\n                expectedResult = bytes.concat(expectedResult, inputs[i]);\n            }\n            DynamicBufferLib.DynamicBuffer memory buffer;\n            buffer.p(first);\n            uint256 location = _bufferLocation(buffer);\n            for (uint256 i; i < inputs.length; ++i) {\n                buffer.p(inputs[i]);\n                assertEq(_bufferLocation(buffer), location);\n                _checkMemory(buffer.data);\n            }\n            assertEq(buffer.data, expectedResult);\n            sharedLocation = _bufferLocation(buffer);\n        }\n\n        if ((t >> 129) & 1 == 0) {\n            if ((t >> 16) & 7 == 0) _misalignFreeMemoryPointer();\n            DynamicBufferLib.DynamicBuffer memory buffer;\n            if ((t >> 160) & 3 == 0) _incrementFreeMemoryPointer();\n            if ((t >> 130) & 1 == 0 && sharedLocation != 0) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore(buffer, sharedLocation)\n                }\n                buffer.clear();\n            }\n            if ((t >> 162) & 3 == 0) _incrementFreeMemoryPointer();\n            if ((t >> 32) & 3 == 0) {\n                buffer.reserve((t >> 128) % 1024);\n            }\n\n            unchecked {\n                uint256 expectedLength;\n                uint256 start;\n                if (t & 1 == 0) {\n                    if (inputs.length > 0) {\n                        expectedLength = inputs[0].length;\n                        buffer.data = inputs[0];\n                        start = 1;\n                    }\n                }\n                for (uint256 i = start; i < inputs.length; ++i) {\n                    expectedLength += inputs[i].length;\n                    // Manually store the t in the next free memory word,\n                    // and then check if p will corrupt it\n                    // (in the case of insufficient memory allocation).\n                    uint256 corruptCheckSlot;\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        corruptCheckSlot := mload(0x40)\n                        mstore(corruptCheckSlot, t)\n                        mstore(0x40, add(corruptCheckSlot, 0x20))\n                    }\n                    buffer.p(inputs[i]);\n                    if ((t >> 48) & 7 == 0 && expectedLength != 0) {\n                        buffer.reserve((t >> 160) % (expectedLength * 2));\n                    }\n                    assertEq(buffer.data.length, expectedLength);\n                    _checkMemory(buffer.data);\n                    bool isCorrupted;\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        isCorrupted := iszero(eq(t, mload(corruptCheckSlot)))\n                    }\n                    assertFalse(isCorrupted);\n                }\n            }\n\n            bytes memory expectedResult;\n            unchecked {\n                for (uint256 i; i < inputs.length; ++i) {\n                    expectedResult = bytes.concat(expectedResult, inputs[i]);\n                }\n            }\n\n            assertEq(keccak256(buffer.data), keccak256(expectedResult));\n        }\n    }\n\n    function testJoinWithConcat() public {\n        bytes memory expectedResult;\n        (bytes[] memory chunks, bytes32 joinedHash) = _getChunks();\n        unchecked {\n            for (uint256 i; i < chunks.length; ++i) {\n                expectedResult = bytes.concat(expectedResult, chunks[i]);\n            }\n        }\n        assertEq(keccak256(expectedResult), joinedHash);\n    }\n\n    function testJoinWithDynamicBuffer() public {\n        DynamicBufferLib.DynamicBuffer memory buffer;\n        (bytes[] memory chunks, bytes32 joinedHash) = _getChunks();\n        unchecked {\n            for (uint256 i; i < chunks.length; ++i) {\n                buffer.p(chunks[i]);\n            }\n        }\n        assertEq(keccak256(buffer.data), joinedHash);\n    }\n\n    function testDynamicBufferChaining() public {\n        DynamicBufferLib.DynamicBuffer memory bufferA;\n        DynamicBufferLib.DynamicBuffer memory bufferB;\n        bufferA = bufferB.p(\"0\", \"1\");\n        _checkSamePointers(bufferA, bufferB);\n        bufferA = bufferB.p(\"0\", \"1\", \"2\");\n        _checkSamePointers(bufferA, bufferB);\n        bufferA = bufferB.p(\"0\", \"1\", \"2\", \"3\");\n        _checkSamePointers(bufferA, bufferB);\n        bufferA = bufferB.p(\"0\", \"1\", \"2\", \"3\", \"4\");\n        _checkSamePointers(bufferA, bufferB);\n        bufferA = bufferB.p(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\");\n        _checkSamePointers(bufferA, bufferB);\n        bufferA = bufferB.p(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\");\n        _checkSamePointers(bufferA, bufferB);\n        assertEq(bufferA.data, \"010120123012340123450123456\");\n        assertEq(bufferB.data, \"010120123012340123450123456\");\n    }\n\n    function _checkSamePointers(\n        DynamicBufferLib.DynamicBuffer memory a,\n        DynamicBufferLib.DynamicBuffer memory b\n    ) internal {\n        bool isSamePointer;\n        assembly {\n            isSamePointer := eq(a, b)\n        }\n        assertTrue(isSamePointer);\n    }\n\n    function _getChunks() internal pure returns (bytes[] memory chunks, bytes32 joinedHash) {\n        chunks = new bytes[](20);\n        chunks[0] = bytes(\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n        );\n        chunks[1] = bytes(\"Vitae suscipit tellus mauris a diam maecenas sed enim ut.\");\n        chunks[2] = bytes(\"Nisl nisi scelerisque eu ultrices vitae auctor eu augue.\");\n        chunks[3] = bytes(\"Et pharetra pharetra massa massa ultricies mi quis.\");\n        chunks[4] = bytes(\"Ullamcorper malesuada proin libero nunc.\");\n        chunks[5] = bytes(\"Tempus imperdiet nulla malesuada pellentesque.\");\n        chunks[6] = bytes(\"Nunc congue nisi vitae suscipit tellus mauris.\");\n        chunks[7] = bytes(\"Eu augue ut lectus arcu.\");\n        chunks[8] = bytes(\"Natoque penatibus et magnis dis parturient montes nascetur.\");\n        chunks[9] = bytes(\"Convallis posuere morbi leo urna.\");\n\n        chunks[15] = bytes(\"Hehe\");\n\n        joinedHash = 0x166b0e99fea53034ed188896344996efc141b922127f90922905e478cb26b312;\n    }\n\n    function _boundInputs(bytes[] memory inputs) internal pure {\n        // Limit the total number of inputs.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if gt(mload(inputs), 16) { mstore(inputs, 16) }\n        }\n        unchecked {\n            // Limit the lengths of the inputs.\n            for (uint256 i; i < inputs.length; ++i) {\n                bytes memory x = inputs[i];\n                /// @solidity memory-safe-assembly\n                assembly {\n                    if gt(mload(x), 128) { mstore(x, 128) }\n                }\n            }\n        }\n    }\n}\n",
        "contractname": "DynamicBufferLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A uint8 map in storage.\n    struct Uint8Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint16 map in storage.\n    struct Uint16Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\n    struct Uint40Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint64 map in storage.\n    struct Uint64Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint128 map in storage.\n    struct Uint128Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the uint8 value at `index` in `map`.\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }\n\n    /// @dev Updates the uint8 value at `index` in `map`.\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }\n\n    /// @dev Returns the uint16 value at `index` in `map`.\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\n    }\n\n    /// @dev Updates the uint16 value at `index` in `map`.\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint32 value at `index` in `map`.\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\n    }\n\n    /// @dev Updates the uint32 value at `index` in `map`.\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint40 value at `index` in `map`.\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }\n\n    /// @dev Updates the uint40 value at `index` in `map`.\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint64 value at `index` in `map`.\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\n    }\n\n    /// @dev Updates the uint64 value at `index` in `map`.\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint128 value at `index` in `map`.\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\n    }\n\n    /// @dev Updates the uint128 value at `index` in `map`.\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the value at `index` in `map`.\n    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }\n\n    /// @dev Updates the value at `index` in `map`.\n    function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       BINARY SEARCH                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // The following functions search in the range of [`start`, `end`)\n    // (i.e. `start <= index < end`).\n    // The range must be sorted in ascending order.\n    // `index` precedence: equal to > nearest before > nearest after.\n    // An invalid search range will simply return `(found = false, index = start)`.\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibMap} from \"../src/utils/LibMap.sol\";\n\ncontract LibMapTest is SoladyTest {\n    using LibMap for *;\n\n    uint8[0xffffffffffffffff] bigUint8ArrayMap;\n\n    LibMap.Uint8Map[2] uint8s;\n\n    LibMap.Uint16Map[2] uint16s;\n\n    LibMap.Uint32Map[2] uint32s;\n\n    LibMap.Uint40Map[2] uint40s;\n\n    LibMap.Uint64Map[2] uint64s;\n\n    LibMap.Uint128Map[2] uint128s;\n\n    mapping(uint256 => LibMap.Uint32Map) uint32Maps;\n\n    mapping(uint256 => mapping(uint256 => uint256)) generalMaps;\n\n    mapping(uint256 => uint256) filled;\n\n    struct _TestTemps {\n        uint256 i0;\n        uint256 i1;\n        uint256 v0;\n        uint256 v1;\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        uint256 r = _random();\n        t.i0 = (r >> 8) & 31;\n        t.i1 = (r >> 16) & 31;\n        t.v0 = _random();\n        t.v1 = _random();\n    }\n\n    function getUint8(uint256 index) public view returns (uint8 result) {\n        result = uint8s[0].get(index);\n    }\n\n    function setUint8(uint256 index, uint8 value) public {\n        uint8s[0].set(index, value);\n    }\n\n    function getUint8FromBigArray(uint256 index) public view returns (uint8 result) {\n        result = bigUint8ArrayMap[index];\n    }\n\n    function setUint8FromBigArray(uint256 index, uint8 value) public {\n        bigUint8ArrayMap[index] = value;\n    }\n\n    function testMapSetUint8() public {\n        this.setUint8(111111, 123);\n    }\n\n    function testMapGetUint8() public {\n        assertEq(this.getUint8(222222), uint8(0));\n    }\n\n    function testMapSetUint8FromBigArray() public {\n        this.setUint8FromBigArray(111111, 123);\n    }\n\n    function testMapGetFromBigArray() public {\n        assertEq(this.getUint8FromBigArray(222222), uint8(0));\n    }\n\n    function testUint8MapSetAndGet(uint256) public {\n        uint8 u = uint8(_random());\n        uint8s[0].set(0, u);\n        assertEq(uint8s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint8 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint8s[0].set(index, casted);\n                assertEq(uint8s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint8MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint8 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint8s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint8s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint8MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint8s[0].set(t.i0, uint8(t.v0));\n        uint8s[1].set(t.i1, uint8(t.v1));\n        assertEq(uint8s[0].get(t.i0), uint8(t.v0));\n        assertEq(uint8s[1].get(t.i1), uint8(t.v1));\n    }\n\n    function testUint16MapSetAndGet(uint256) public {\n        uint16 u = uint16(_random());\n        uint16s[0].set(0, u);\n        assertEq(uint16s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint16 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint16s[0].set(index, casted);\n                assertEq(uint16s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint16MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint16 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint16s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint16s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint16MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint16s[0].set(t.i0, uint16(t.v0));\n        uint16s[1].set(t.i1, uint16(t.v1));\n        assertEq(uint16s[0].get(t.i0), uint16(t.v0));\n        assertEq(uint16s[1].get(t.i1), uint16(t.v1));\n    }\n\n    function testUint32MapSetAndGet(uint256) public {\n        uint32 u = uint32(_random());\n        uint32s[0].set(0, u);\n        assertEq(uint32s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint32 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint32s[0].set(index, casted);\n                assertEq(uint32s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint32MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint32 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint32s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint32s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint32MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint32s[0].set(t.i0, uint32(t.v0));\n        uint32s[1].set(t.i1, uint32(t.v1));\n        assertEq(uint32s[0].get(t.i0), uint32(t.v0));\n        assertEq(uint32s[1].get(t.i1), uint32(t.v1));\n    }\n\n    function testUint40MapSetAndGet(uint256) public {\n        uint40 u = uint40(_random());\n        uint40s[0].set(0, u);\n        assertEq(uint40s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint40 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint40s[0].set(index, casted);\n                assertEq(uint40s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint40MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint40 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint40s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint40s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint40MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint40s[0].set(t.i0, uint40(t.v0));\n        uint40s[1].set(t.i1, uint40(t.v1));\n        assertEq(uint40s[0].get(t.i0), uint40(t.v0));\n        assertEq(uint40s[1].get(t.i1), uint40(t.v1));\n    }\n\n    function testUint64MapSetAndGet(uint256) public {\n        uint64 u = uint64(_random());\n        uint64s[0].set(0, u);\n        assertEq(uint64s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint64 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint64s[0].set(index, casted);\n                assertEq(uint64s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint64MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint64 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint64s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint64s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint64MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint64s[0].set(t.i0, uint64(t.v0));\n        uint64s[1].set(t.i1, uint64(t.v1));\n        assertEq(uint64s[0].get(t.i0), uint64(t.v0));\n        assertEq(uint64s[1].get(t.i1), uint64(t.v1));\n    }\n\n    function testUint128MapSetAndGet(uint256) public {\n        uint128 u = uint128(_random());\n        uint128s[0].set(0, u);\n        assertEq(uint128s[0].map[0], u);\n        unchecked {\n            for (uint256 t; t < 8; ++t) {\n                uint256 r = _random();\n                uint128 casted;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    casted := r\n                }\n                uint256 index = _random() % 32;\n                uint128s[0].set(index, casted);\n                assertEq(uint128s[0].get(index), casted);\n            }\n        }\n    }\n\n    function testUint128MapSetAndGet() public {\n        unchecked {\n            for (uint256 t; t < 16; ++t) {\n                uint256 n = 64;\n                uint128 casted;\n                uint256 r = _random();\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    uint128s[0].set(i, casted);\n                }\n                for (uint256 i; i < n; ++i) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        casted := or(add(mul(n, t), i), r)\n                    }\n                    assertEq(uint128s[0].get(i), casted);\n                }\n            }\n        }\n    }\n\n    function testUint128MapSetAndGet2(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint128s[0].set(t.i0, uint128(t.v0));\n        uint128s[1].set(t.i1, uint128(t.v1));\n        assertEq(uint128s[0].get(t.i0), uint128(t.v0));\n        assertEq(uint128s[1].get(t.i1), uint128(t.v1));\n    }\n\n    function testUint32Maps(uint256) public {\n        unchecked {\n            uint256 a0 = _random();\n            uint256 a1 = _random() % 2 == 0 ? a0 + _random() % 4 : a0 - _random() % 4;\n            uint256 b0 = _random();\n            uint256 b1 = _random() % 2 == 0 ? b0 + _random() % 4 : b0 - _random() % 4;\n            if (a0 == a1 && b1 == b0) {\n                if (_random() % 2 == 0) {\n                    if (_random() % 2 == 0) b1++;\n                    else a0++;\n                } else {\n                    if (_random() % 2 == 0) b1--;\n                    else a0--;\n                }\n            }\n            uint256 c0 = _random();\n            uint256 c1 = _random();\n            uint32 c0Casted;\n            uint32 c1Casted;\n            /// @solidity memory-safe-assembly\n            assembly {\n                c0Casted := c0\n                c1Casted := c1\n            }\n            assertEq(uint32Maps[a0].get(b0), 0);\n            assertEq(uint32Maps[a1].get(b1), 0);\n            uint32Maps[a0].set(b0, c0Casted);\n            uint32Maps[a1].set(b1, c1Casted);\n            assertEq(uint32Maps[a0].get(b0), uint32(c0));\n            assertEq(uint32Maps[a1].get(b1), uint32(c1));\n        }\n    }\n\n    struct _SearchSortedTestVars {\n        uint256 o;\n        uint256 n;\n        uint256 end;\n        bool found;\n        uint256 index;\n        uint256 randomIndex;\n        uint256 randomIndexValue;\n        uint256[] values;\n    }\n\n    function _searchSortedTestVars(mapping(uint256 => uint256) storage map, uint256 bitWidth)\n        internal\n        returns (_SearchSortedTestVars memory t)\n    {\n        unchecked {\n            t.n = 1 + _random() % 7 + (_random() % 8 == 0 ? _random() % 64 : 0);\n            if (_random() % 2 == 0) {\n                t.o = type(uint256).max - t.n;\n                t.end = t.o + t.n;\n                assertEq(t.end, type(uint256).max);\n            } else {\n                t.o = _random() % 4 + (_random() % 8 == 0 ? type(uint256).max - 256 : 0);\n                t.end = t.o + t.n;\n            }\n            uint256 v = _random() % 4;\n            uint256 b = (_random() % 2) * (_random() << 7);\n            uint256 valueMask = (1 << bitWidth) - 1;\n            for (uint256 i; i != t.n; ++i) {\n                map.set(t.o + i, b | v, bitWidth);\n                filled.set((b | v) & valueMask, 1, 1);\n                v += 1 + _random() % 2;\n            }\n            t.randomIndex = t.o + _random() % t.n;\n            t.randomIndexValue = map.get(t.randomIndex, bitWidth);\n\n            if (t.o > 0) map.set(t.o - 1, _random(), bitWidth);\n            if (t.end < type(uint256).max) map.set(t.end, _random(), bitWidth);\n\n            uint256 notFoundValue = _generateNotFoundValue(t.o);\n\n            (t.found, t.index) = map.searchSorted(notFoundValue, t.o, t.end, bitWidth);\n            assertFalse(t.found);\n            assertEq(t.index, _nearestIndexBefore(map, notFoundValue, t.o, t.n, bitWidth));\n\n            uint256 end = t.o - (t.o > 0 ? _random() % t.o : 0);\n            (t.found, t.index) = map.searchSorted(t.randomIndexValue, t.o, end, bitWidth);\n            assertFalse(t.found);\n            assertEq(t.index, t.o);\n\n            (t.found, t.index) = map.searchSorted(t.randomIndexValue, t.o, t.end, bitWidth);\n            assertTrue(t.found);\n            assertEq(t.index, t.randomIndex);\n        }\n    }\n\n    function _generateNotFoundValue(uint256 o) internal returns (uint256 notFoundValue) {\n        unchecked {\n            uint256 max = 32;\n            do {\n                notFoundValue = o + _random() % max;\n                max += 8;\n            } while (filled.get(notFoundValue, 1) == 1);\n        }\n    }\n\n    function _nearestIndexBefore(\n        mapping(uint256 => uint256) storage map,\n        uint256 x,\n        uint256 o,\n        uint256 n,\n        uint256 bitWidth\n    ) internal view returns (uint256 nearestIndex) {\n        unchecked {\n            nearestIndex = o;\n            uint256 nearestDist = type(uint256).max;\n            for (uint256 i; i != n; ++i) {\n                uint256 y = map.get(o + i, bitWidth);\n                if (y > x) continue;\n                uint256 dist = x - y;\n                if (dist < nearestDist) {\n                    nearestIndex = o + i;\n                    nearestDist = dist;\n                }\n            }\n        }\n    }\n\n    function testUint8MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint8Map storage m = uint8s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 8);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint8(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testUint16MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint16Map storage m = uint16s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 16);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint16(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testUint32MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint32Map storage m = uint32s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 32);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint32(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testUint40MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint40Map storage m = uint40s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 40);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint40(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testUint64MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint64Map storage m = uint64s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 64);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint64(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testUint128MapSearchSorted(uint256) public {\n        unchecked {\n            LibMap.Uint128Map storage m = uint128s[0];\n            _SearchSortedTestVars memory t = _searchSortedTestVars(m.map, 128);\n            assertEq(m.get(t.randomIndex), t.randomIndexValue);\n            (bool found, uint256 index) = m.searchSorted(uint128(t.randomIndexValue), t.o, t.end);\n            assertTrue(found == t.found && index == t.index);\n        }\n    }\n\n    function testGeneralMapSearchSorted(uint256) public {\n        unchecked {\n            mapping(uint256 => uint256) storage m = generalMaps[0];\n            uint256 bitWidth = _bound(_random(), 8, 256);\n            _searchSortedTestVars(m, bitWidth);\n        }\n    }\n\n    function testGeneralMapFunctionsWithSmallBitWidths(uint256) public {\n        unchecked {\n            uint256 bitWidth = 1 + _random() % 6;\n            uint256 valueMask = (1 << bitWidth) - 1;\n            uint256 o = _random() % 64 + (_random() % 8 == 0 ? type(uint256).max - 256 : 0);\n            uint256 n = _random() % 9;\n            for (uint256 k; k != 2; ++k) {\n                for (uint256 i; i != n; ++i) {\n                    uint256 j = o + i * 2;\n                    generalMaps[k].set(j, _hash(j), bitWidth);\n                }\n            }\n            for (uint256 k; k != 2; ++k) {\n                for (uint256 i; i != n; ++i) {\n                    uint256 j = o + i * 2 + 1;\n                    generalMaps[k].set(j, _hash(j), bitWidth);\n                }\n            }\n            for (uint256 k; k != 2; ++k) {\n                for (uint256 i; i != n; ++i) {\n                    uint256 j = o + i * 2;\n                    assertEq(generalMaps[k].get(j, bitWidth), _hash(j) & valueMask);\n                    j = j + 1;\n                    assertEq(generalMaps[k].get(j, bitWidth), _hash(j) & valueMask);\n                }\n            }\n        }\n    }\n\n    function _hash(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, x)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    function testGeneralMapFunctionsWithZeroBitWidth() public {\n        unchecked {\n            mapping(uint256 => uint256) storage m = generalMaps[0];\n            for (uint256 j; j < 3; ++j) {\n                for (uint256 i; i < 3; ++i) {\n                    m.set(i, j + 1, 0);\n                    assertEq(m.get(i, 0), 0);\n                    (bool found, uint256 index) = m.searchSorted(i, j, j + 2, 0);\n                    assertFalse(found);\n                    assertEq(index, j);\n                }\n            }\n        }\n    }\n\n    function testGeneralMapFunctionsGas() public {\n        unchecked {\n            mapping(uint256 => uint256) storage m = generalMaps[0];\n            for (uint256 i; i != 1000; ++i) {\n                m.set(i, i + 1, 32);\n                assertEq(m.get(i, 32), i + 1);\n            }\n            for (uint256 j = 1; j < 900; j += 37) {\n                (bool found, uint256 index) = m.searchSorted(j, 0, 1000, 32);\n                assertTrue(found);\n                assertEq(index, j - 1);\n            }\n        }\n    }\n\n    function testFoundStatementDifferential(uint256 t, uint256 needle, uint256 index) public {\n        bool a;\n        bool b;\n        /// @solidity memory-safe-assembly\n        assembly {\n            a := and(eq(t, needle), iszero(iszero(index)))\n            b := iszero(or(xor(t, needle), iszero(index)))\n        }\n        assertEq(a, b);\n    }\n}\n",
        "contractname": "LibMap.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibBit} from \"./LibBit.sol\";\n\n/// @notice Library for storage of packed unsigned booleans.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\nlibrary LibBitmap {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The constant returned when a bitmap scan does not find a result.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A bitmap in storage.\n    struct Bitmap {\n        mapping(uint256 => uint256) map;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            isSet := b\n        }\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to true.\n    function set(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to false.\n    function unset(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\n    }\n\n    /// @dev Flips the bit at `index` in `bitmap`.\n    /// Returns the boolean result of the flipped bit.\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := and(1, shr(shift, storageValue))\n            sstore(storageSlot, storageValue)\n        }\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }\n\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), max)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\n        }\n    }\n\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), 0)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\n            )\n        }\n    }\n\n    /// @dev Returns number of set bits within a range by\n    /// scanning `amount` of bits starting from the bit at `start`.\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\n        internal\n        view\n        returns (uint256 count)\n    {\n        unchecked {\n            uint256 bucket = start >> 8;\n            uint256 shift = start & 0xff;\n            if (!(amount + shift < 257)) {\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\n                amount = (amount + shift) & 0xff;\n                shift = 0;\n                for (++bucket; bucket != bucketEnd; ++bucket) {\n                    count += LibBit.popCount(bitmap.map[bucket]);\n                }\n            }\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\n        }\n    }\n\n    /// @dev Returns the index of the most significant set bit in `[0..upTo]`.\n    /// If no set bit is found, returns `NOT_FOUND`.\n    function findLastSet(Bitmap storage bitmap, uint256 upTo)\n        internal\n        view\n        returns (uint256 setBitIndex)\n    {\n        uint256 bucket;\n        uint256 bucketBits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            setBitIndex := not(0)\n            bucket := shr(8, upTo)\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, not(upTo)) // `256 - (255 & upTo) - 1`.\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\n            if iszero(or(bucketBits, iszero(bucket))) {\n                for {} 1 {} {\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\n                    mstore(0x00, bucket)\n                    bucketBits := sload(keccak256(0x00, 0x40))\n                    if or(bucketBits, iszero(bucket)) { break }\n                }\n            }\n        }\n        if (bucketBits != 0) {\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, upTo)))\n            }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibBitmap} from \"../src/utils/LibBitmap.sol\";\nimport {LibBit} from \"../src/utils/LibBit.sol\";\n\ncontract LibBitmapTest is SoladyTest {\n    using LibBitmap for LibBitmap.Bitmap;\n\n    error AlreadyClaimed();\n\n    LibBitmap.Bitmap bitmap;\n\n    function get(uint256 index) public view returns (bool result) {\n        result = bitmap.get(index);\n    }\n\n    function set(uint256 index) public {\n        bitmap.set(index);\n    }\n\n    function unset(uint256 index) public {\n        bitmap.unset(index);\n    }\n\n    function toggle(uint256 index) public {\n        bitmap.toggle(index);\n    }\n\n    function setTo(uint256 index, bool shouldSet) public {\n        bitmap.setTo(index, shouldSet);\n    }\n\n    function claimWithGetSet(uint256 index) public {\n        if (bitmap.get(index)) {\n            revert AlreadyClaimed();\n        }\n        bitmap.set(index);\n    }\n\n    function claimWithToggle(uint256 index) public {\n        if (bitmap.toggle(index) == false) {\n            revert AlreadyClaimed();\n        }\n    }\n\n    function testBitmapGet() public {\n        testBitmapGet(111111);\n    }\n\n    function testBitmapGet(uint256 index) public {\n        assertFalse(get(index));\n    }\n\n    function testBitmapSetAndGet(uint256 index) public {\n        set(index);\n        bool result = get(index);\n        bool resultIsOne;\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultIsOne := eq(result, 1)\n        }\n        assertTrue(result);\n        assertTrue(resultIsOne);\n    }\n\n    function testBitmapSet() public {\n        testBitmapSet(222222);\n    }\n\n    function testBitmapSet(uint256 index) public {\n        set(index);\n        assertTrue(get(index));\n    }\n\n    function testBitmapUnset() public {\n        testBitmapSet(333333);\n    }\n\n    function testBitmapUnset(uint256 index) public {\n        set(index);\n        assertTrue(get(index));\n        unset(index);\n        assertFalse(get(index));\n    }\n\n    function testBitmapSetTo() public {\n        testBitmapSetTo(555555, true, 0);\n        testBitmapSetTo(555555, false, 0);\n    }\n\n    function testBitmapSetTo(uint256 index, bool shouldSet, uint256 randomness) public {\n        bool shouldSetBrutalized;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shouldSet { shouldSetBrutalized := or(iszero(randomness), randomness) }\n        }\n        setTo(index, shouldSetBrutalized);\n        assertEq(get(index), shouldSet);\n    }\n\n    function testBitmapSetTo(uint256 index, uint256 randomness) public {\n        randomness = _random();\n        unchecked {\n            for (uint256 i; i < 5; ++i) {\n                bool shouldSet;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    shouldSet := and(shr(i, randomness), 1)\n                }\n                testBitmapSetTo(index, shouldSet, _random());\n            }\n        }\n    }\n\n    function testBitmapToggle() public {\n        testBitmapToggle(777777, true);\n        testBitmapToggle(777777, false);\n    }\n\n    function testBitmapToggle(uint256 index, bool initialValue) public {\n        setTo(index, initialValue);\n        assertEq(get(index), initialValue);\n        toggle(index);\n        assertEq(get(index), !initialValue);\n    }\n\n    function testBitmapClaimWithGetSet() public {\n        uint256 index = 888888;\n        this.claimWithGetSet(index);\n        vm.expectRevert(AlreadyClaimed.selector);\n        this.claimWithGetSet(index);\n    }\n\n    function testBitmapClaimWithToggle() public {\n        uint256 index = 999999;\n        this.claimWithToggle(index);\n        vm.expectRevert(AlreadyClaimed.selector);\n        this.claimWithToggle(index);\n    }\n\n    function testBitmapSetBatchWithinSingleBucket() public {\n        _testBitmapSetBatch(257, 30);\n    }\n\n    function testBitmapSetBatchAcrossMultipleBuckets() public {\n        _testBitmapSetBatch(10, 512);\n    }\n\n    function testBitmapSetBatch() public {\n        unchecked {\n            for (uint256 i; i < 8; ++i) {\n                uint256 start = _random();\n                uint256 amount = _random();\n                _testBitmapSetBatch(start, amount);\n            }\n        }\n    }\n\n    function testBitmapUnsetBatchWithinSingleBucket() public {\n        _testBitmapUnsetBatch(257, 30);\n    }\n\n    function testBitmapUnsetBatchAcrossMultipleBuckets() public {\n        _testBitmapUnsetBatch(10, 512);\n    }\n\n    function testBitmapUnsetBatch() public {\n        unchecked {\n            for (uint256 i; i < 8; ++i) {\n                uint256 start = _random();\n                uint256 amount = _random();\n                _testBitmapUnsetBatch(start, amount);\n            }\n        }\n    }\n\n    function testBitmapPopCountWithinSingleBucket() public {\n        _testBitmapPopCount(1, 150);\n    }\n\n    function testBitmapPopCountAcrossMultipleBuckets() public {\n        _testBitmapPopCount(10, 512);\n    }\n\n    function testBitmapPopCount(uint256, uint256 start, uint256 amount) public {\n        unchecked {\n            uint256 n = 1000;\n            uint256 expectedCount;\n            _resetBitmap(0, n / 256 + 1);\n\n            (start, amount) = _boundStartAndAmount(start, amount, n);\n\n            uint256 jPrev = 0xff + 1;\n            uint256 j = _random() & 0xff;\n            while (true) {\n                bitmap.set(j);\n                if (j != jPrev && start <= j && j < start + amount) {\n                    expectedCount += 1;\n                }\n                if (start + amount <= j && _random() & 7 == 0) break;\n                jPrev = j;\n                j += _random() & 0xff;\n            }\n            assertEq(bitmap.popCount(start, amount), expectedCount);\n        }\n    }\n\n    function testBitmapPopCount() public {\n        unchecked {\n            for (uint256 i; i < 8; ++i) {\n                uint256 start = _random();\n                uint256 amount = _random();\n                testBitmapPopCount(start, amount, _random());\n            }\n        }\n    }\n\n    function testBitmapFindLastSet() public {\n        unchecked {\n            bitmap.unsetBatch(0, 2000);\n            bitmap.set(1000);\n            for (uint256 i = 0; i < 1000; ++i) {\n                assertEq(bitmap.findLastSet(i), LibBitmap.NOT_FOUND);\n            }\n            bitmap.set(100);\n            bitmap.set(10);\n            for (uint256 i = 0; i < 10; ++i) {\n                assertEq(bitmap.findLastSet(i), LibBitmap.NOT_FOUND);\n            }\n            for (uint256 i = 10; i < 100; ++i) {\n                assertEq(bitmap.findLastSet(i), 10);\n            }\n            for (uint256 i = 100; i < 600; ++i) {\n                assertEq(bitmap.findLastSet(i), 100);\n            }\n            for (uint256 i = 1000; i < 1100; ++i) {\n                assertEq(bitmap.findLastSet(i), 1000);\n            }\n            bitmap.set(0);\n            for (uint256 i = 0; i < 10; ++i) {\n                assertEq(bitmap.findLastSet(i), 0);\n            }\n        }\n    }\n\n    function testBitmapFindLastSet2() public {\n        unchecked {\n            assertEq(bitmap.findLastSet(100), LibBitmap.NOT_FOUND);\n            bitmap.set(0);\n            assertEq(bitmap.findLastSet(100), 0);\n            assertEq(bitmap.findLastSet(0), 0);\n        }\n    }\n\n    function testBitmapFindLastSet(uint256 upTo, uint256 randomness) public {\n        uint256 n = 1000;\n        unchecked {\n            _resetBitmap(0, n / 256 + 1);\n            upTo = upTo % n;\n            randomness = _random() % n;\n        }\n        bitmap.set(randomness);\n        if (randomness <= upTo) {\n            assertEq(bitmap.findLastSet(upTo), randomness);\n            uint256 nextLcg = _random();\n            bitmap.set(nextLcg);\n            if (nextLcg <= upTo) {\n                assertEq(bitmap.findLastSet(upTo), (randomness < nextLcg ? nextLcg : randomness));\n            }\n        } else {\n            assertEq(bitmap.findLastSet(upTo), LibBitmap.NOT_FOUND);\n            uint256 nextLcg = _random();\n            bitmap.set(nextLcg);\n            if (nextLcg <= upTo) {\n                assertEq(bitmap.findLastSet(upTo), nextLcg);\n            } else {\n                assertEq(bitmap.findLastSet(upTo), LibBitmap.NOT_FOUND);\n            }\n        }\n    }\n\n    function _testBitmapSetBatch(uint256 start, uint256 amount) internal {\n        uint256 n = 1000;\n        (start, amount) = _boundStartAndAmount(start, amount, n);\n\n        unchecked {\n            _resetBitmap(0, n / 256 + 1);\n            bitmap.setBatch(start, amount);\n            for (uint256 i; i < n; ++i) {\n                if (i < start) {\n                    assertFalse(bitmap.get(i));\n                } else if (i < start + amount) {\n                    assertTrue(bitmap.get(i));\n                } else {\n                    assertFalse(bitmap.get(i));\n                }\n            }\n        }\n    }\n\n    function _testBitmapUnsetBatch(uint256 start, uint256 amount) internal {\n        uint256 n = 1000;\n        (start, amount) = _boundStartAndAmount(start, amount, n);\n\n        unchecked {\n            _resetBitmap(type(uint256).max, n / 256 + 1);\n            bitmap.unsetBatch(start, amount);\n            for (uint256 i; i < n; ++i) {\n                if (i < start) {\n                    assertTrue(bitmap.get(i));\n                } else if (i < start + amount) {\n                    assertFalse(bitmap.get(i));\n                } else {\n                    assertTrue(bitmap.get(i));\n                }\n            }\n        }\n    }\n\n    function _testBitmapPopCount(uint256 start, uint256 amount) internal {\n        uint256 n = 1000;\n        (start, amount) = _boundStartAndAmount(start, amount, n);\n\n        unchecked {\n            _resetBitmap(0, n / 256 + 1);\n            bitmap.setBatch(start, amount);\n            assertEq(bitmap.popCount(0, n), amount);\n            if (start > 0) {\n                assertEq(bitmap.popCount(0, start - 1), 0);\n            }\n            if (start + amount < n) {\n                assertEq(bitmap.popCount(start + amount, n - (start + amount)), 0);\n            }\n        }\n    }\n\n    function _boundStartAndAmount(uint256 start, uint256 amount, uint256 n)\n        private\n        pure\n        returns (uint256 boundedStart, uint256 boundedAmount)\n    {\n        unchecked {\n            boundedStart = start % n;\n            uint256 end = boundedStart + (amount % n);\n            if (end > n) end = n;\n            boundedAmount = end - boundedStart;\n        }\n    }\n\n    function _resetBitmap(uint256 bucketValue, uint256 bucketEnd) private {\n        unchecked {\n            for (uint256 i; i < bucketEnd; ++i) {\n                bitmap.map[i] = bucketValue;\n            }\n        }\n    }\n}\n",
        "contractname": "LibBitmap.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing a min-heap in storage or memory.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MinHeapLib.sol)\nlibrary MinHeapLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The heap is empty.\n    error HeapIsEmpty();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A heap in storage.\n    struct Heap {\n        uint256[] data;\n    }\n\n    /// @dev A heap in memory.\n    struct MemHeap {\n        uint256[] data;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Tips:\n    // - To use as a max-heap, bitwise negate the input and output values (e.g. `heap.push(~x)`).\n    // - To use on tuples, pack the tuple values into a single integer.\n    // - To use on signed integers, convert the signed integers into\n    //   their ordered unsigned counterparts via `uint256(x) + (1 << 255)`.\n\n    /// @dev Returns the minimum value of the heap.\n    /// Reverts if the heap is empty.\n    function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns the minimum value of the heap.\n    /// Reverts if the heap is empty.\n    function root(MemHeap memory heap) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(heap)\n            if iszero(mload(result)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(0x20, result))\n        }\n    }\n\n    /// @dev Reserves at least `minimum` slots of memory for the heap.\n    /// Helps avoid reallocation if you already know the max size of the heap.\n    function reserve(MemHeap memory heap, uint256 minimum) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let prime := 5936628702318599\n            let cap := mload(add(mload(heap), w))\n            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {\n                let data := mload(heap)\n                let n := mload(data)\n                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.\n                mstore(mload(0x40), mul(newCap, prime))\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                mstore(heap, m) // Update `heap.data`.\n                if n {\n                    for { let i := shl(5, n) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns an array of the `k` smallest items in the heap,\n    /// sorted in ascending order, without modifying the heap.\n    /// If the heap has less than `k` items, all items in the heap will be returned.\n    function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := sload(heap.slot) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns an array of the `k` smallest items in the heap,\n    /// sorted in ascending order, without modifying the heap.\n    /// If the heap has less than `k` items, all items in the heap will be returned.\n    function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            let sOffset := add(mload(heap), 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := mload(mload(heap)) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the number of items in the heap.\n    function length(Heap storage heap) internal view returns (uint256) {\n        return heap.data.length;\n    }\n\n    /// @dev Returns the number of items in the heap.\n    function length(MemHeap memory heap) internal pure returns (uint256) {\n        return heap.data.length;\n    }\n\n    /// @dev Pushes the `value` onto the min-heap.\n    function push(Heap storage heap, uint256 value) internal {\n        _set(heap, value, 0, 3);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap.\n    function push(MemHeap memory heap, uint256 value) internal pure {\n        _set(heap, value, 0, 3);\n    }\n\n    /// @dev Pops the minimum value from the min-heap.\n    /// Reverts if the heap is empty.\n    function pop(Heap storage heap) internal returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }\n\n    /// @dev Pops the minimum value from the min-heap.\n    /// Reverts if the heap is empty.\n    function pop(MemHeap memory heap) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.\n    function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.\n    function pushPop(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }\n\n    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.\n    /// Reverts if the heap is empty.\n    function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }\n\n    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.\n    /// Reverts if the heap is empty.\n    function replace(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value\n    /// if the length of the heap exceeds `maxLength`.\n    ///\n    /// Reverts if `maxLength` is zero.\n    ///\n    /// - If the queue is not full:\n    ///   (`success` = true, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is not greater than the minimum value:\n    ///   (`success` = false, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is greater than the minimum value:\n    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)\n    ///\n    /// Useful for implementing a bounded priority queue.\n    function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value\n    /// if the length of the heap exceeds `maxLength`.\n    ///\n    /// Reverts if `maxLength` is zero.\n    ///\n    /// - If the queue is not full:\n    ///   (`success` = true, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is not greater than the minimum value:\n    ///   (`success` = false, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is greater than the minimum value:\n    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)\n    ///\n    /// Useful for implementing a bounded priority queue.\n    function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)\n        internal\n        pure\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper function for heap operations.\n    /// Designed for code conciseness, bytecode compactness, and decent performance.\n    function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        sstore(heap.slot, add(pos, 1))\n                        childPos := sOffset\n                        break\n                    }\n                    let r := sload(sOffset)\n                    if iszero(lt(r, value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := r\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        sstore(heap.slot, n)\n                        // Set the `value` to the last item.\n                        value := sload(add(sOffset, n))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := sOffset\n                    break\n                }\n                // Mode: `pushPop`.\n                popped := value\n                if iszero(n) { break }\n                let r := sload(sOffset)\n                if iszero(lt(r, value)) { break }\n                popped := r\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }\n\n    /// @dev Helper function for heap operations.\n    /// Designed for code conciseness, bytecode compactness, and decent performance.\n    function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        pure\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let data := mload(heap)\n            let n := mload(data)\n            // Allocation / reallocation. Abuse `cap` being a multiple of 32 to early skip.\n            for {} iszero(and(n, 0x1f)) {} {\n                let cap := mload(sub(data, 0x20))\n                let prime := 5936628702318599\n                cap := mul(iszero(mod(cap, prime)), div(cap, prime))\n                if lt(n, cap) { break }\n                let newCap := add(shl(1, cap), shl(5, iszero(cap)))\n                mstore(mload(0x40), mul(newCap, prime)) // Update `heap.capacity`.\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                if cap {\n                    let w := not(0x1f)\n                    for { let i := shl(5, cap) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n                mstore(heap, m) // Update `heap.data`.\n                data := m\n                break\n            }\n            let sOffset := add(data, 0x20) // Array memory offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        mstore(data, add(pos, 1))\n                        childPos := 0xff0000000000000000\n                        break\n                    }\n                    if iszero(lt(mload(sOffset), value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := mload(sOffset)\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        mstore(data, n)\n                        // Set the `value` to the last item.\n                        value := mload(add(sOffset, shl(5, n)))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := mload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                // Mode: `pushPop`.\n                if iszero(mul(n, lt(mload(sOffset), value))) {\n                    popped := value\n                    break\n                }\n                popped := mload(sOffset)\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := mload(add(sOffset, shl(5, childPos)))\n                let rightPos := add(childPos, 1)\n                let right := mload(add(sOffset, shl(5, rightPos)))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    mstore(add(sOffset, shl(5, pos)), child)\n                    pos := childPos\n                    childPos := add(shl(1, pos), 1)\n                    continue\n                }\n                mstore(add(sOffset, shl(5, pos)), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := mload(add(sOffset, shl(5, parentPos)))\n                if iszero(lt(value, parent)) { break }\n                mstore(add(sOffset, shl(5, pos)), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MinHeapLib} from \"../src/utils/MinHeapLib.sol\";\nimport {LibSort} from \"../src/utils/LibSort.sol\";\nimport {LibPRNG} from \"../src/utils/LibPRNG.sol\";\n\ncontract MinHeapLibTest is SoladyTest {\n    using MinHeapLib for *;\n    using LibPRNG for *;\n\n    MinHeapLib.Heap heap0;\n\n    MinHeapLib.Heap heap1;\n\n    function testHeapRoot(uint256 x) public {\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            heap0.root();\n        }\n        heap0.data.push(x);\n        assertEq(heap0.length(), 1);\n        assertEq(heap0.root(), x);\n    }\n\n    function testHeapPushAndPop(uint256) public {\n        unchecked {\n            uint256 n = _random() % 8;\n            uint256[] memory a = new uint256[](n);\n\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                a[i] = r;\n                heap0.push(r);\n            }\n            LibSort.insertionSort(a);\n            for (uint256 i; i < n; ++i) {\n                assertEq(heap0.pop(), a[i]);\n            }\n            assertEq(heap0.length(), 0);\n        }\n    }\n\n    function testHeapPushPop(uint256) public {\n        unchecked {\n            uint256 n = _random() % 8;\n            uint256[] memory a = new uint256[](n + 1);\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                heap0.push(r);\n                heap1.push(r);\n                a[i + 1] = r;\n            }\n            n = _random() % 8;\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                a[0] = r;\n                LibSort.insertionSort(a);\n                uint256 popped0 = heap0.pushPop(r);\n                heap1.push(r);\n                uint256 popped1 = heap1.pop();\n                assertEq(popped0, popped1);\n            }\n            LibSort.insertionSort(a);\n            n = heap0.length();\n            for (uint256 i; i < n; ++i) {\n                assertEq(heap0.pop(), a[i + 1]);\n            }\n        }\n    }\n\n    function testHeapPushPopLength(uint256) public brutalizeMemory {\n        unchecked {\n            uint256 heap0Length;\n            uint256 heap1Length;\n            do {\n                if (_random() % 2 == 0) {\n                    heap0.push(_random());\n                    assertEq(heap0.data.length, ++heap0Length);\n                }\n                if (heap0Length != 0 && _random() % 2 == 0) {\n                    heap0.pop();\n                    assertEq(heap0.data.length, --heap0Length);\n                }\n                if (_random() % 2 == 0) {\n                    heap1.push(_random());\n                    assertEq(heap1.data.length, ++heap1Length);\n                }\n                if (heap1Length != 0 && _random() % 2 == 0) {\n                    heap1.pop();\n                    assertEq(heap1.data.length, --heap1Length);\n                }\n            } while (_random() % 16 > 0);\n        }\n    }\n\n    function testHeapReplace(uint256) public {\n        unchecked {\n            uint256 n = _random() % 8 + 1;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                heap0.push(r);\n                heap1.push(r);\n                a[i] = r;\n            }\n            n = _random() % 8;\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                LibSort.insertionSort(a);\n                a[0] = r;\n                uint256 popped0 = heap0.replace(r);\n                uint256 popped1 = heap1.pop();\n                heap1.push(r);\n                assertEq(popped0, popped1);\n            }\n            LibSort.insertionSort(a);\n            n = heap0.length();\n            for (uint256 i; i < n; ++i) {\n                assertEq(heap0.pop(), a[i]);\n            }\n        }\n    }\n\n    function testHeapSmallest(uint256) public brutalizeMemory {\n        unchecked {\n            uint256 n = _random() & 15 == 0 ? _random() % 256 : _random() % 32;\n            for (uint256 i; i < n; ++i) {\n                heap0.push(_random());\n            }\n            if (_random() & 7 == 0) {\n                n = _random() % 32;\n                for (uint256 i; i < n; ++i) {\n                    heap0.pushPop(_random());\n                    if (_random() & 1 == 0) {\n                        heap0.push(_random());\n                        if (_random() & 1 == 0) heap0.pop();\n                    }\n                    if (_random() & 1 == 0) if (heap0.length() != 0) heap0.replace(_random());\n                }\n            }\n            uint256 k = _random() & 15 == 0 ? _random() % 256 : _random() % 32;\n            k = _random() & 31 == 0 ? 1 << 255 : k;\n            if (_random() & 7 == 0) _brutalizeMemory();\n            uint256[] memory computed = heap0.smallest(k);\n            _checkMemory();\n            if (_random() & 7 == 0) _brutalizeMemory();\n            assertEq(computed, _smallest(heap0.data, k));\n        }\n    }\n\n    function testHeapSmallestGas() public {\n        unchecked {\n            for (uint256 i; i < 2048; ++i) {\n                heap0.push(_random());\n            }\n            uint256 gasBefore = gasleft();\n            heap0.smallest(512);\n            uint256 gasUsed = gasBefore - gasleft();\n            emit LogUint(\"gasUsed\", gasUsed);\n        }\n    }\n\n    function _smallest(uint256[] memory a, uint256 n)\n        internal\n        view\n        returns (uint256[] memory result)\n    {\n        result = _copy(a);\n        LibSort.insertionSort(result);\n        uint256 k = _min(n, result.length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, k)\n        }\n    }\n\n    function _copy(uint256[] memory a) private view returns (uint256[] memory b) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := mload(0x40)\n            let n := add(shl(5, mload(a)), 0x20)\n            pop(staticcall(gas(), 4, a, n, b, n))\n            mstore(0x40, add(b, n))\n        }\n    }\n\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function testHeapPSiftTrick(uint256 c, uint256 h, uint256 e) public {\n        assertEq(_heapPSiftTrick(c, h, e), _heapPSiftTrickOriginal(c, h, e));\n    }\n\n    function _heapPSiftTrick(uint256 c, uint256 h, uint256 e)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pValue(h_, p_) -> _v {\n                mstore(0x00, h_)\n                mstore(0x20, p_)\n                _v := keccak256(0x00, 0x40)\n            }\n            if lt(c, e) {\n                c := add(c, gt(pValue(h, c), pValue(h, add(c, lt(add(c, 1), e)))))\n                result := c\n            }\n        }\n    }\n\n    function _heapPSiftTrickOriginal(uint256 childPos, uint256 sOffset, uint256 n)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pValue(h_, p_) -> _v {\n                mstore(0x00, h_)\n                mstore(0x20, p_)\n                _v := keccak256(0x00, 0x40)\n            }\n            if lt(childPos, n) {\n                let child := pValue(sOffset, childPos)\n                let rightPos := add(childPos, 1)\n                let right := pValue(sOffset, rightPos)\n                if or(iszero(lt(rightPos, n)), lt(child, right)) {\n                    right := child\n                    rightPos := childPos\n                }\n                result := rightPos\n            }\n        }\n    }\n\n    function testHeapEnqueue(uint256) public {\n        unchecked {\n            uint256 maxLength = _random() % 8 + 1;\n            uint256 m = _random() % 32 + maxLength;\n            uint256[] memory a = new uint256[](m);\n            uint256[] memory rejected = new uint256[](m);\n            uint256 numRejected;\n            for (uint256 i; i < m; ++i) {\n                uint256 r = _random();\n                (bool success, bool hasPopped, uint256 popped) = heap0.enqueue(r, maxLength);\n                if (hasPopped) {\n                    assertEq(heap0.length(), maxLength);\n                    assertEq(success, true);\n                    rejected[numRejected++] = popped;\n                }\n                if (!success) {\n                    assertEq(heap0.length(), maxLength);\n                    rejected[numRejected++] = r;\n                }\n                a[i] = r;\n            }\n            LibSort.insertionSort(a);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(rejected, numRejected)\n            }\n            LibSort.insertionSort(rejected);\n            for (uint256 i; i < maxLength; ++i) {\n                assertEq(a[m - maxLength + i], heap0.pop());\n            }\n            assertEq(numRejected + maxLength, m);\n            for (uint256 i; i < numRejected; ++i) {\n                assertEq(a[i], rejected[i]);\n            }\n        }\n    }\n\n    function testHeapEnqueue2(uint256) public {\n        unchecked {\n            uint256 maxLength = _random() & 31 == 0 ? 1 << 255 : _random() % 32 + 1;\n            uint256 m = _random() % 32 + 1;\n            for (uint256 i; i < m; ++i) {\n                uint256 r = _random();\n                heap0.enqueue(r, maxLength);\n                heap1.push(r);\n                if (heap1.length() > maxLength) heap1.pop();\n            }\n            uint256 k = _random() % m;\n            k = _random() & 31 == 0 ? 1 << 255 : k;\n            assertEq(heap0.smallest(k), heap1.smallest(k));\n        }\n    }\n\n    function testHeapEnqueueGas() public {\n        unchecked {\n            for (uint256 t = 8; t < 16; ++t) {\n                uint256 maxLength = t;\n                for (uint256 i; i < 16; ++i) {\n                    heap0.enqueue(i, maxLength);\n                }\n                for (uint256 i; i < 16; ++i) {\n                    heap0.enqueue(_random() % 16, maxLength);\n                }\n            }\n            while (heap0.length() != 0) heap0.pop();\n        }\n    }\n\n    function testHeapEnqueueZeroMaxLengthReverts(uint256) public {\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            heap0.enqueue(_random(), 0);\n        }\n        heap0.enqueue(_random(), 1);\n    }\n\n    function testHeapReplaceOrPopEmptyHeapReverts(uint256) public {\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            if (_random() % 2 == 0) {\n                heap0.replace(_random());\n            } else {\n                heap0.pop();\n            }\n        }\n        heap0.push(_random());\n        if (_random() % 2 == 0) {\n            heap0.replace(_random());\n        } else {\n            heap0.pop();\n        }\n    }\n\n    function testMemHeapRoot(uint256 x) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            heapA.root();\n        }\n        heapA.push(x);\n        assertEq(heapA.length(), 1);\n        assertEq(heapA.root(), x);\n    }\n\n    function testMemHeapPushAndPop(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        unchecked {\n            uint256 n = _random() % 64;\n            uint256[] memory a = new uint256[](n);\n\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                a[i] = r;\n                if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                heapA.push(r);\n                _checkMemory();\n                if (_random() % 32 == 0) _brutalizeMemory();\n                if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n            }\n            LibSort.insertionSort(a);\n            for (uint256 i; i < n; ++i) {\n                assertEq(heapA.pop(), a[i]);\n            }\n            assertEq(heapA.length(), 0);\n        }\n    }\n\n    function testMemHeapPushPop(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        MinHeapLib.MemHeap memory heapB;\n        unchecked {\n            uint256 n = _random() % 64;\n            uint256[] memory a = new uint256[](n + 1);\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                heapA.push(r);\n                _checkMemory();\n                if (_random() % 32 == 0) _brutalizeMemory();\n                if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                heapB.push(r);\n                _checkMemory();\n                if (_random() % 32 == 0) _brutalizeMemory();\n                if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                a[i + 1] = r;\n            }\n            n = _random() % 8;\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                a[0] = r;\n                LibSort.insertionSort(a);\n                uint256 popped0 = heapA.pushPop(r);\n                heapB.push(r);\n                uint256 popped1 = heapB.pop();\n                assertEq(popped0, popped1);\n            }\n            LibSort.insertionSort(a);\n            n = heapA.length();\n            for (uint256 i; i < n; ++i) {\n                assertEq(heapA.pop(), a[i + 1]);\n            }\n        }\n    }\n\n    function testMemHeapPushPopLength(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        MinHeapLib.MemHeap memory heapB;\n        unchecked {\n            uint256 heapALength;\n            uint256 heapBLength;\n            do {\n                if (_random() % 2 == 0) {\n                    if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                    heapA.push(_random());\n                    assertEq(heapA.data.length, ++heapALength);\n                    if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                }\n                if (heapALength != 0 && _random() % 2 == 0) {\n                    if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                    heapA.pop();\n                    assertEq(heapA.data.length, --heapALength);\n                    if (_random() % 16 == 0) heapA.reserve(_random() % 256);\n                }\n                if (_random() % 2 == 0) {\n                    if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                    heapB.push(_random());\n                    assertEq(heapB.data.length, ++heapBLength);\n                    if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                }\n                if (heapBLength != 0 && _random() % 2 == 0) {\n                    if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                    heapB.pop();\n                    assertEq(heapB.data.length, --heapBLength);\n                    if (_random() % 16 == 0) heapB.reserve(_random() % 256);\n                }\n            } while (_random() % 16 > 0);\n        }\n    }\n\n    function testMemHeapReplace(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        MinHeapLib.MemHeap memory heapB;\n        unchecked {\n            uint256 n = _random() % 64 + 1;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                heapA.push(r);\n                heapB.push(r);\n                a[i] = r;\n            }\n            n = _random() % 8;\n            for (uint256 i; i < n; ++i) {\n                uint256 r = _random();\n                LibSort.insertionSort(a);\n                a[0] = r;\n                uint256 popped0 = heapA.replace(r);\n                uint256 popped1 = heapB.pop();\n                heapB.push(r);\n                assertEq(popped0, popped1);\n            }\n            LibSort.insertionSort(a);\n            n = heapA.length();\n            for (uint256 i; i < n; ++i) {\n                assertEq(heapA.pop(), a[i]);\n            }\n        }\n    }\n\n    function testMemHeapSmallest(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        unchecked {\n            uint256 n = _random() & 15 == 0 ? _random() % 256 : _random() % 64;\n            for (uint256 i; i < n; ++i) {\n                heapA.push(_random());\n            }\n            if (_random() & 7 == 0) {\n                n = _random() % 32;\n                for (uint256 i; i < n; ++i) {\n                    heapA.pushPop(_random());\n                    if (_random() & 1 == 0) {\n                        heapA.push(_random());\n                        if (_random() & 1 == 0) heapA.pop();\n                    }\n                    if (_random() & 1 == 0) if (heapA.length() != 0) heapA.replace(_random());\n                }\n            }\n            uint256 k = _random() & 15 == 0 ? _random() % 256 : _random() % 64;\n            k = _random() & 31 == 0 ? 1 << 255 : k;\n            if (_random() & 7 == 0) _brutalizeMemory();\n            uint256[] memory computed = heapA.smallest(k);\n            _checkMemory();\n            if (_random() & 7 == 0) _brutalizeMemory();\n            assertEq(computed, _smallest(heapA.data, k));\n        }\n    }\n\n    function testMemHeapSmallestGas() public {\n        MinHeapLib.MemHeap memory heapA;\n        LibPRNG.PRNG memory prng;\n        unchecked {\n            for (uint256 i; i < 2048; ++i) {\n                heapA.push(prng.next());\n            }\n            uint256 gasBefore = gasleft();\n            heapA.smallest(512);\n            uint256 gasUsed = gasBefore - gasleft();\n            emit LogUint(\"gasUsed\", gasUsed);\n        }\n    }\n\n    function testMemHeapEnqueue(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        unchecked {\n            uint256 maxLength = _random() % 64 + 1;\n            uint256 m = _random() % 32 + maxLength;\n            uint256[] memory a = new uint256[](m);\n            uint256[] memory rejected = new uint256[](m);\n            uint256 numRejected;\n            for (uint256 i; i < m; ++i) {\n                uint256 r = _random();\n                (bool success, bool hasPopped, uint256 popped) = heapA.enqueue(r, maxLength);\n                if (hasPopped) {\n                    assertEq(heapA.length(), maxLength);\n                    assertEq(success, true);\n                    rejected[numRejected++] = popped;\n                }\n                if (!success) {\n                    assertEq(heapA.length(), maxLength);\n                    rejected[numRejected++] = r;\n                }\n                a[i] = r;\n            }\n            LibSort.insertionSort(a);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(rejected, numRejected)\n            }\n            LibSort.insertionSort(rejected);\n            for (uint256 i; i < maxLength; ++i) {\n                assertEq(a[m - maxLength + i], heapA.pop());\n            }\n            assertEq(numRejected + maxLength, m);\n            for (uint256 i; i < numRejected; ++i) {\n                assertEq(a[i], rejected[i]);\n            }\n        }\n    }\n\n    function testMemHeapEnqueue2(uint256) public brutalizeMemory {\n        MinHeapLib.MemHeap memory heapA;\n        MinHeapLib.MemHeap memory heapB;\n        unchecked {\n            uint256 maxLength = _random() & 31 == 0 ? 1 << 255 : _random() % 64 + 1;\n            uint256 m = _random() % 64 + 1;\n            for (uint256 i; i < m; ++i) {\n                uint256 r = _random();\n                heapA.enqueue(r, maxLength);\n                heapB.push(r);\n                if (heapB.length() > maxLength) heapB.pop();\n            }\n            uint256 k = _random() % m;\n            k = _random() & 31 == 0 ? 1 << 255 : k;\n            assertEq(heapA.smallest(k), heapB.smallest(k));\n        }\n    }\n\n    function testMemHeapPushGas() public pure {\n        MinHeapLib.MemHeap memory heapA;\n        unchecked {\n            for (uint256 i; i < 64; ++i) {\n                heapA.push(i);\n            }\n        }\n    }\n\n    function testMemHeapEnqueueZeroMaxLengthReverts(uint256) public {\n        MinHeapLib.MemHeap memory heapA;\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            heapA.enqueue(_random(), 0);\n        }\n        heapA.enqueue(_random(), 1);\n    }\n\n    function testMemHeapReplaceOrPopEmptyHeapReverts(uint256) public {\n        MinHeapLib.MemHeap memory heapA;\n        if (_random() % 2 == 0) {\n            vm.expectRevert(MinHeapLib.HeapIsEmpty.selector);\n            if (_random() % 2 == 0) {\n                heapA.replace(_random());\n            } else {\n                heapA.pop();\n            }\n        }\n        heapA.push(_random());\n        if (_random() % 2 == 0) {\n            heapA.replace(_random());\n        } else {\n            heapA.pop();\n        }\n    }\n\n    function testMemHeapEnqueueGas() public pure {\n        MinHeapLib.MemHeap memory heapA;\n        LibPRNG.PRNG memory prng;\n        unchecked {\n            for (uint256 t = 8; t < 16; ++t) {\n                uint256 maxLength = t;\n                for (uint256 i; i < 16; ++i) {\n                    heapA.enqueue(i, maxLength);\n                }\n                for (uint256 i; i < 16; ++i) {\n                    heapA.enqueue(prng.next() % 16, maxLength);\n                }\n            }\n            while (heapA.length() != 0) heapA.pop();\n        }\n    }\n}\n",
        "contractname": "MinHeapLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Reentrancy guard mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unauthorized reentrant call.\n    error Reentrancy();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to: `uint72(bytes9(keccak256(\"_REENTRANCY_GUARD_SLOT\")))`.\n    /// 9 bytes is large enough to avoid collisions with lower slots,\n    /// but not too large to result in excessive bytecode bloat.\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      REENTRANCY GUARD                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Guards a function from reentrancy.\n    modifier nonReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_REENTRANCY_GUARD_SLOT, address())\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, codesize())\n        }\n    }\n\n    /// @dev Guards a view function from read-only reentrancy.\n    modifier nonReadReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {ReentrancyGuard} from \"../src/utils/ReentrancyGuard.sol\";\nimport {MockReentrancyGuard, ReentrancyAttack} from \"./utils/mocks/MockReentrancyGuard.sol\";\n\ncontract ReentrancyGuardTest is SoladyTest {\n    MockReentrancyGuard immutable target = new MockReentrancyGuard();\n    ReentrancyAttack immutable reentrancyAttack = new ReentrancyAttack();\n\n    // Before and after each test, the reentrancy guard should be unlocked.\n    modifier expectBeforeAfterReentrancyGuardUnlocked() {\n        assertEq(target.isReentrancyGuardLocked(), false);\n        _;\n        assertEq(target.isReentrancyGuardLocked(), false);\n    }\n\n    function testRevertGuardLocked() external expectBeforeAfterReentrancyGuardUnlocked {\n        // Attempt to call a `nonReentrant` methiod with an unprotected method.\n        // Expect a success.\n        target.callUnguardedToGuarded();\n        assertEq(target.enterTimes(), 1);\n\n        // Attempt to call a `nonReentrant` method within a `nonReentrant` method.\n        // Expect a revert with the `Reentrancy` error.\n        vm.expectRevert(ReentrancyGuard.Reentrancy.selector);\n        target.callGuardedToGuarded();\n    }\n\n    function testRevertReadGuardLocked() external expectBeforeAfterReentrancyGuardUnlocked {\n        // Attempt to call a `nonReadReentrant` methiod with an unprotected method.\n        // Expect a success.\n        target.callUnguardedToReadGuarded();\n        assertEq(target.enterTimes(), 1);\n\n        // Attempt to call a `nonReadReentrant` method within a `nonReentrant` method.\n        // Expect a revert with the `Reentrancy` error.\n        vm.expectRevert(ReentrancyGuard.Reentrancy.selector);\n        target.callGuardedToReadGuarded();\n    }\n\n    function testRevertRemoteCallback() external expectBeforeAfterReentrancyGuardUnlocked {\n        // Attempt to reenter a `nonReentrant` method from a remote contract.\n        vm.expectRevert(ReentrancyAttack.ReentrancyAttackFailed.selector);\n        target.countAndCall(reentrancyAttack);\n    }\n\n    function testRecursiveDirectUnguardedCall() external expectBeforeAfterReentrancyGuardUnlocked {\n        // Expect to be able to call unguarded methods recursively.\n        // Expect a success.\n        target.countUnguardedDirectRecursive(10);\n        assertEq(target.enterTimes(), 10);\n    }\n\n    function testRevertRecursiveDirectGuardedCall()\n        external\n        expectBeforeAfterReentrancyGuardUnlocked\n    {\n        // Attempt to reenter a `nonReentrant` method from a direct call.\n        // Expect a revert with the `Reentrancy` error.\n        vm.expectRevert(ReentrancyGuard.Reentrancy.selector);\n        target.countGuardedDirectRecursive(10);\n        assertEq(target.enterTimes(), 0);\n    }\n\n    function testRecursiveIndirectUnguardedCall()\n        external\n        expectBeforeAfterReentrancyGuardUnlocked\n    {\n        // Expect to be able to call unguarded methods recursively.\n        // Expect a success.\n        target.countUnguardedIndirectRecursive(10);\n        assertEq(target.enterTimes(), 10);\n    }\n\n    function testRevertRecursiveIndirectGuardedCall()\n        external\n        expectBeforeAfterReentrancyGuardUnlocked\n    {\n        // Attempt to reenter a `nonReentrant` method from an indirect call.\n        vm.expectRevert(ReentrancyGuard.Reentrancy.selector);\n        target.countGuardedIndirectRecursive(10);\n        assertEq(target.enterTimes(), 0);\n    }\n}\n",
        "contractname": "ReentrancyGuard.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {Base64} from \"../src/utils/Base64.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract Base64Test is SoladyTest {\n    function testBase64EncodeEmptyString() public {\n        _testBase64Encode(\"\", \"\");\n    }\n\n    function testBase64EncodeShortStrings() public {\n        _testBase64Encode(\"M\", \"TQ==\");\n        _testBase64Encode(\"Mi\", \"TWk=\");\n        _testBase64Encode(\"Mil\", \"TWls\");\n        _testBase64Encode(\"Mila\", \"TWlsYQ==\");\n        _testBase64Encode(\"Milad\", \"TWlsYWQ=\");\n        _testBase64Encode(\"Milady\", \"TWlsYWR5\");\n    }\n\n    function testBase64EncodeToStringWithDoublePadding() public {\n        _testBase64Encode(\"test\", \"dGVzdA==\");\n    }\n\n    function testBase64EncodeToStringWithSinglePadding() public {\n        _testBase64Encode(\"test1\", \"dGVzdDE=\");\n    }\n\n    function testBase64EncodeToStringWithNoPadding() public {\n        _testBase64Encode(\"test12\", \"dGVzdDEy\");\n    }\n\n    function testBase64EncodeSentence() public {\n        _testBase64Encode(\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n            \"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdC4=\"\n        );\n    }\n\n    function testBase64WordBoundary() public {\n        // Base64.encode allocates memory in multiples of 32 bytes.\n        // This checks if the amount of memory allocated is enough.\n        _testBase64Encode(\"012345678901234567890\", \"MDEyMzQ1Njc4OTAxMjM0NTY3ODkw\");\n        _testBase64Encode(\"0123456789012345678901\", \"MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMQ==\");\n        _testBase64Encode(\"01234567890123456789012\", \"MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=\");\n        _testBase64Encode(\"012345678901234567890123\", \"MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIz\");\n        _testBase64Encode(\"0123456789012345678901234\", \"MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNA==\");\n    }\n\n    function _testBase64Encode(string memory input, string memory output) private {\n        assertEq(Base64.encode(_withDirtyEndBits(bytes(input))), output);\n    }\n\n    function _withDirtyEndBits(bytes memory input) private view returns (bytes memory output) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            output := mload(0x40)\n            let n := mload(input)\n\n            mstore(0x00, gas())\n            let r := keccak256(0x00, 0x60)\n            mstore(add(output, add(0x20, n)), r)\n            mstore(add(output, add(0x40, n)), r)\n\n            pop(staticcall(gas(), 4, input, add(0x20, n), output, add(0x20, n)))\n\n            mstore(0x40, add(output, add(0x40, n)))\n        }\n    }\n\n    function testBase64EncodeDecode(bytes memory input) public {\n        string memory encoded = Base64.encode(input);\n        bytes memory decoded = Base64.decode(encoded);\n\n        assertEq(input, decoded);\n    }\n\n    function testBase64DecodeShortStringGas() public {\n        assertEq(Base64.decode(\"TWlsYWR5\").length, 6);\n    }\n\n    function testBase64DecodeSentenceGas() public {\n        assertEq(\n            Base64.decode(\n                \"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdC4=\"\n            ).length,\n            56\n        );\n    }\n\n    function testBase64EncodeDecodeAltModes(bytes memory input) public brutalizeMemory {\n        for (uint256 i; i < 2; ++i) {\n            _misalignFreeMemoryPointer();\n            if (_random() % 2 == 0) {\n                input = _withDirtyEndBits(input);\n            }\n            string memory encoded = Base64.encode(input);\n            _checkMemory(encoded);\n\n            if (_random() & 1 == 0) {\n                encoded = LibString.replace(encoded, \"=\", \"\");\n            }\n            if (_random() & 1 == 0) {\n                encoded = LibString.replace(encoded, \"/\", \",\");\n            }\n            if (_random() & 1 == 0) {\n                encoded = LibString.replace(encoded, \"/\", \"_\");\n            }\n            if (_random() & 1 == 0) {\n                encoded = LibString.replace(encoded, \"+\", \"-\");\n            }\n\n            _misalignFreeMemoryPointer();\n            bytes memory decoded = Base64.decode(encoded);\n            _checkMemory(decoded);\n\n            assertEq(input, decoded);\n\n            input = abi.encode(encoded);\n        }\n    }\n\n    function testBase64EncodeFileSafeAndNoPadding(bytes memory input, bool fileSafe, bool noPadding)\n        public\n    {\n        string memory expectedEncoded = Base64.encode(input);\n\n        if (fileSafe) {\n            expectedEncoded = LibString.replace(expectedEncoded, \"+\", \"-\");\n            expectedEncoded = LibString.replace(expectedEncoded, \"/\", \"_\");\n        }\n        if (noPadding) {\n            expectedEncoded = LibString.replace(expectedEncoded, \"=\", \"\");\n        }\n\n        assertEq(Base64.encode(input, fileSafe, noPadding), expectedEncoded);\n    }\n}\n",
        "contractname": "Base64.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for parsing JSONs.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\nlibrary JSONParserLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The input is invalid.\n    error ParsingFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // There are 6 types of variables in JSON (excluding undefined).\n\n    /// @dev For denoting that an item has not been initialized.\n    /// A item returned from `parse` will never be of an undefined type.\n    /// Parsing a invalid JSON string will simply revert.\n    uint8 internal constant TYPE_UNDEFINED = 0;\n\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\n    uint8 internal constant TYPE_ARRAY = 1;\n\n    /// @dev Type representing an object (e.g. `{\"a\":\"A\",\"b\":\"B\"}`).\n    uint8 internal constant TYPE_OBJECT = 2;\n\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\n    uint8 internal constant TYPE_NUMBER = 3;\n\n    /// @dev Type representing a string (e.g. `\"hello\"`).\n    uint8 internal constant TYPE_STRING = 4;\n\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\n    uint8 internal constant TYPE_BOOLEAN = 5;\n\n    /// @dev Type representing null (i.e. `null`).\n    uint8 internal constant TYPE_NULL = 6;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A pointer to a parsed JSON node.\n    struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }\n\n    // Private constants for packing `_data`.\n\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\n    uint256 private constant _BITMASK_TYPE = 7;\n    uint256 private constant _KEY_INITED = 1 << 3;\n    uint256 private constant _VALUE_INITED = 1 << 4;\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   JSON PARSING OPERATION                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Parses the JSON string `s`, and returns the root.\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\n    /// in the same order which they appear in the JSON string.\n    ///\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\n    /// The parsed tree WILL contain offsets to `s`.\n    /// Do NOT pass in a string that WILL be modified later on.\n    function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    JSON ITEM OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Note:\n    // - An item is a node in the JSON tree.\n    // - The value of a string item WILL be double-quoted, JSON encoded.\n    // - We make a distinction between `index` and `key`.\n    //   - Items in arrays are located by `index` (uint256).\n    //   - Items in objects are located by `key` (string).\n    // - Keys are always strings, double-quoted, JSON encoded.\n    //\n    // These design choices are made to balance between efficiency and ease-of-use.\n\n    /// @dev Returns the string value of the item.\n    /// This is its exact string representation in the original JSON string.\n    /// The returned string WILL have leading and trailing whitespace trimmed.\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the index of the item in the array.\n    /// It the item's parent is not an array, returns 0.\n    function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item's parent is not an object, returns an empty string.\n    /// The returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item is neither an array nor object, returns an empty array.\n    ///\n    /// Note: This function lazily instantiates and caches the returned array.\n    /// Do NOT modify the returned array.\n    function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the number of children.\n    /// It the item is neither an array nor object, returns zero.\n    function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }\n\n    /// @dev Returns the item at index `i` for (array).\n    /// If `item` is not an array, the result's type WILL be undefined.\n    /// If there is no item with the index, the result's type WILL be undefined.\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the item at key `k` for (object).\n    /// If `item` is not an object, the result's type WILL be undefined.\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\n    /// - Correct : `item.at('\"k\"')`.\n    /// - Wrong   : `item.at(\"k\")`.\n    /// For duplicated keys, the last item with the key WILL be returned.\n    /// If there is no item with the key, the result's type WILL be undefined.\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the item's type.\n    function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }\n\n    /// Note: All types are mutually exclusive.\n\n    /// @dev Returns whether the item is of type undefined.\n    function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }\n\n    /// @dev Returns whether the item is of type array.\n    function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }\n\n    /// @dev Returns whether the item is of type object.\n    function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }\n\n    /// @dev Returns whether the item is of type number.\n    function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }\n\n    /// @dev Returns whether the item is of type string.\n    function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }\n\n    /// @dev Returns whether the item is of type boolean.\n    function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }\n\n    /// @dev Returns whether the item is of type null.\n    function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }\n\n    /// @dev Returns the item's parent.\n    /// If the item does not have a parent, the result's type will be undefined.\n    function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     UTILITY FUNCTIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\n    /// or if the parsed number is too big for a uint256.\n    function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\n    function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }\n\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Decodes a JSON encoded string.\n    /// The string MUST be double-quoted, JSON encoded.\n    /// Reverts if the string is invalid.\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\n    function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Performs a query on the input with the given mode.\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {JSONParserLib} from \"../src/utils/JSONParserLib.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\nimport {Base64} from \"../src/utils/Base64.sol\";\n\ncontract JSONParserLibTest is SoladyTest {\n    using JSONParserLib for *;\n\n    function testParseInvalidReverts() public {\n        _checkParseReverts(\"\");\n        _checkParseReverts(\"e\");\n        _checkParseReverts(\"abc\");\n        _checkParseReverts(\"1,2\");\n        _checkParseReverts(\"[\");\n        _checkParseReverts(\"]\");\n        _checkParseReverts(\"{\");\n        _checkParseReverts(\"}\");\n        _checkParseReverts(\"[[]\");\n        _checkParseReverts(\"[][\");\n        _checkParseReverts(\"[][]\");\n        _checkParseReverts(\"[],[]\");\n        _checkParseReverts(\"[1,2\");\n        _checkParseReverts(\"1,2]\");\n        _checkParseReverts(\"[1\");\n        _checkParseReverts(\"1]\");\n        _checkParseReverts(\"[1,\");\n        _checkParseReverts(\"{}{\");\n        _checkParseReverts(\"{}{}\");\n        _checkParseReverts(\"{},{}\");\n        _checkParseReverts(\"{]\");\n        _checkParseReverts(\"{{}\");\n        _checkParseReverts(\"{}}\");\n        _checkParseReverts(\"[,]\");\n        _checkParseReverts(\"[0,]\");\n        _checkParseReverts(\"[0,1,]\");\n        _checkParseReverts(\"[0,,]\");\n        _checkParseReverts(\"[0,,1]\");\n        _checkParseReverts(\"[,0]\");\n        _checkParseReverts(\"{,}\");\n        _checkParseReverts('{\"a\"}');\n        _checkParseReverts('{\"a\":\"A\",}');\n        _checkParseReverts('{\"a\":\"A\",\"b\":\"B\",}');\n        _checkParseReverts('{\"a\":\"A\"b\":\"B\"}');\n        _checkParseReverts('{\"a\":\"A\",,\"b\":\"B\"}');\n        _checkParseReverts('{,\"a\":\"A\",\"b\":\"B\"}');\n        _checkParseReverts('{\"a\"::\"A\"}');\n        _checkParseReverts('{\"a\",\"A\"}');\n        _checkParseReverts(\"{1}\");\n        _checkParseReverts(\"{:}\");\n    }\n\n    function testParseInvalidNumberReverts() public {\n        _checkParseReverts(\"01234567890\");\n        _checkParseReverts(\"-1.234567890e-a\");\n        _checkParseReverts(\"-1.234567890e-\");\n        _checkParseReverts(\"-1.234567890e+a\");\n        _checkParseReverts(\"-1.234567890e+\");\n        _checkParseReverts(\"-1.234567890z\");\n        _checkParseReverts(\"-1.234567890e\");\n        _checkParseReverts(\"-00.234567890\");\n        _checkParseReverts(\"-.234567890\");\n        _checkParseReverts(\"-00\");\n        _checkParseReverts(\"--0\");\n        _checkParseReverts(\"00\");\n        _checkParseReverts(\"0.\");\n        _checkParseReverts(\"0..12\");\n        _checkParseReverts(\"0.0e\");\n        _checkParseReverts(\".\");\n        _checkParseReverts(\"-\");\n        _checkParseReverts(\"+\");\n        _checkParseReverts(\"e\");\n        _checkParseReverts(\"+123\");\n        _checkParseReverts(\".123\");\n        _checkParseReverts(\"e123\");\n        _checkParseReverts(\"1 e 1\");\n        _checkParseReverts(\"-1.e+0\");\n        _checkParseReverts(\"0x\");\n    }\n\n    function _checkParseReverts(string memory trimmed) internal {\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parsedValue(trimmed);\n        string memory s = trimmed;\n        for (uint256 i; i != 4; ++i) {\n            vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n            this.parsedValue(_padWhiteSpace(s, i));\n        }\n    }\n\n    function parsedValue(string memory s) public view miniBrutalizeMemory returns (string memory) {\n        s = s.parse().value();\n        _checkMemory(s);\n        return s;\n    }\n\n    function testParseNumber() public {\n        _checkParseNumber(\"0\");\n        _checkParseNumber(\"-0\");\n        _checkParseNumber(\"-1.2e+0\");\n        _checkParseNumber(\"-1.2e+00\");\n        _checkParseNumber(\"-1.2e+001\");\n        _checkParseNumber(\"-1.2e+22\");\n        _checkParseNumber(\"-1.2e-22\");\n        _checkParseNumber(\"-1.2e22\");\n        _checkParseNumber(\"0.1\");\n        _checkParseNumber(\"0.123\");\n        _checkParseNumber(\"12345678901234567890123456789012345678901234567890\");\n        _checkParseNumber(\"12345e12345678901234567890123456789012345678901234567890\");\n        _checkParseNumber(\"1234567890\");\n        _checkParseNumber(\"123\");\n        _checkParseNumber(\"1\");\n    }\n\n    function _checkParseNumber(string memory trimmed) internal {\n        _checkSoloNumber(trimmed.parse(), trimmed);\n        string memory s = trimmed;\n        for (uint256 i; i != 4; ++i) {\n            _checkSoloNumber(_padWhiteSpace(s, i).parse(), trimmed);\n        }\n    }\n\n    function _checkSoloNumber(JSONParserLib.Item memory item, string memory trimmed) internal {\n        for (uint256 i; i != 2; ++i) {\n            assertEq(item.getType(), JSONParserLib.TYPE_NUMBER);\n            assertEq(item.isNumber(), true);\n            assertEq(item.value(), trimmed);\n            _checkItemIsSolo(item);\n        }\n    }\n\n    function testParseEmptyArrays() public {\n        _checkParseEmptyArray(\"[]\");\n        _checkParseEmptyArray(\"[ ]\");\n        _checkParseEmptyArray(\"[  ]\");\n    }\n\n    function _checkParseEmptyArray(string memory trimmed) internal {\n        _checkSoloEmptyArray(trimmed.parse(), trimmed);\n        string memory s = trimmed;\n        for (uint256 i; i != 16; ++i) {\n            _checkSoloEmptyArray(_padWhiteSpace(s, i).parse(), trimmed);\n        }\n    }\n\n    function _checkSoloEmptyArray(JSONParserLib.Item memory item, string memory trimmed) internal {\n        for (uint256 i; i != 2; ++i) {\n            assertEq(item.getType(), JSONParserLib.TYPE_ARRAY);\n            assertEq(item.isArray(), true);\n            assertEq(item.value(), trimmed);\n            _checkItemIsSolo(item);\n        }\n    }\n\n    function testParseEmptyObjects() public {\n        _checkParseEmptyObject(\"{}\");\n        _checkParseEmptyObject(\"{ }\");\n        _checkParseEmptyObject(\"{  }\");\n    }\n\n    function _checkParseEmptyObject(string memory trimmed) internal {\n        _checkSoloEmptyObject(trimmed.parse(), trimmed);\n        string memory s = trimmed;\n        for (uint256 i; i != 16; ++i) {\n            _checkSoloEmptyObject(_padWhiteSpace(s, i).parse(), trimmed);\n        }\n    }\n\n    function _checkSoloEmptyObject(JSONParserLib.Item memory item, string memory trimmed)\n        internal\n    {\n        for (uint256 i; i != 2; ++i) {\n            assertEq(item.getType(), JSONParserLib.TYPE_OBJECT);\n            assertEq(item.isObject(), true);\n            assertEq(item.value(), trimmed);\n            _checkItemIsSolo(item);\n        }\n    }\n\n    function _padWhiteSpace(string memory s, uint256 r) internal pure returns (string memory) {\n        unchecked {\n            uint256 q = r;\n            r = r % 3;\n            string memory p = r == 0 ? \" \" : r == 1 ? \"\\t\" : r == 2 ? \"\\r\" : \"\\n\";\n            q = 1 + q / 3;\n            for (uint256 i; i != q; ++i) {\n                s = string(abi.encodePacked(p, s, p));\n            }\n            return s;\n        }\n    }\n\n    function testParseSimpleUintArray() public {\n        string memory s;\n        JSONParserLib.Item memory item;\n\n        for (uint256 k; k != 9; ++k) {\n            uint256 o = k == 0 ? 0 : 1 << (17 * k);\n            string memory p = _padWhiteSpace(\"\", k);\n            for (uint256 j; j != 5; ++j) {\n                s = \"[\";\n                for (uint256 i; i != j; ++i) {\n                    string memory x = LibString.toString(o + i);\n                    if (i == 0) {\n                        s = string(abi.encodePacked(s, p, x));\n                    } else {\n                        s = string(abi.encodePacked(s, p, \",\", p, x));\n                    }\n                }\n                s = string(abi.encodePacked(s, \"]\"));\n                item = s.parse();\n                assertEq(item.isArray(), true);\n                assertEq(item.size(), j);\n                for (uint256 i; i != j; ++i) {\n                    string memory x = LibString.toString(o + i);\n                    assertEq(item.children()[i].value(), x);\n                    assertEq(item.children()[i].parent()._data, item._data);\n                    assertEq(item.children()[i].parent().isArray(), true);\n                    assertEq(item.at(i)._data, item.children()[i]._data);\n                    assertEq(item.at(LibString.toString(i))._data, 0);\n                }\n            }\n        }\n    }\n\n    function testEmptyItem() public {\n        JSONParserLib.Item memory item;\n        assertEq(item.value(), \"\");\n        assertEq(item.isUndefined(), true);\n        assertEq(item.parent().isUndefined(), true);\n        assertEq(item.parent().parent().isUndefined(), true);\n        assertEq(item.key(), \"\");\n        assertEq(item.at(0).isUndefined(), true);\n        assertEq(item.at(0).at(0).isUndefined(), true);\n    }\n\n    function testParseSimpleArray() public {\n        string memory s = '[\"hehe\",12,\"haha\"]';\n        JSONParserLib.Item memory item = s.parse();\n\n        assertEq(item.isArray(), true);\n        assertEq(item.size(), 3);\n        _checkItemHasNoParent(item);\n\n        assertEq(item.children()[0].value(), '\"hehe\"');\n        assertEq(item.children()[0].index(), 0);\n        assertEq(item.children()[0].getType(), JSONParserLib.TYPE_STRING);\n        assertEq(item.children()[0].key(), \"\");\n        assertEq(item.children()[0].parent()._data, item._data);\n        assertEq(item.children()[0].parent().isArray(), true);\n\n        assertEq(item.children()[1].value(), \"12\");\n        assertEq(item.children()[1].index(), 1);\n        assertEq(item.children()[1].key(), \"\");\n        assertEq(item.children()[1].getType(), JSONParserLib.TYPE_NUMBER);\n        assertEq(item.children()[1].parent()._data, item._data);\n        assertEq(item.children()[1].parent().isArray(), true);\n\n        assertEq(item.children()[2].value(), '\"haha\"');\n        assertEq(item.children()[2].index(), 2);\n        assertEq(item.children()[2].getType(), JSONParserLib.TYPE_STRING);\n        assertEq(item.children()[2].key(), \"\");\n        assertEq(item.children()[2].parent()._data, item._data);\n        assertEq(item.children()[2].parent().isArray(), true);\n\n        assertEq(item.at(0)._data, item.children()[0]._data);\n        assertEq(item.at(1)._data, item.children()[1]._data);\n        assertEq(item.at(2)._data, item.children()[2]._data);\n        assertEq(item.at(3)._data, 0);\n    }\n\n    function testParseSpecials() public miniBrutalizeMemory {\n        string memory s;\n        JSONParserLib.Item memory item;\n\n        for (uint256 k; k < 9; ++k) {\n            s = _padWhiteSpace(\"true\", k);\n            item = s.parse();\n            assertEq(item.getType(), JSONParserLib.TYPE_BOOLEAN);\n            assertEq(item.isBoolean(), true);\n            assertEq(item.isNull(), false);\n            assertEq(item.value(), \"true\");\n            assertEq(item.parent().isUndefined(), true);\n            _checkItemIsSolo(item);\n\n            s = _padWhiteSpace(\"false\", k);\n            item = s.parse();\n            assertEq(item.getType(), JSONParserLib.TYPE_BOOLEAN);\n            assertEq(item.isBoolean(), true);\n            assertEq(item.isNull(), false);\n            assertEq(item.value(), \"false\");\n            _checkItemIsSolo(item);\n\n            s = _padWhiteSpace(\"null\", k);\n            item = s.parse();\n            assertEq(item.getType(), JSONParserLib.TYPE_NULL);\n            assertEq(item.isBoolean(), false);\n            assertEq(item.isNull(), true);\n            assertEq(item.value(), \"null\");\n            _checkItemIsSolo(item);\n        }\n\n        for (uint256 k; k != 4; ++k) {\n            if (k == 0) s = \"[true,false,null]\";\n            if (k == 1) s = \"[ true , false , null ]\";\n            if (k == 2) s = '{\"A\":true,\"B\":false,\"C\":null}';\n            if (k == 3) s = '{ \"A\" : true , \"B\" : false , \"C\" : null }';\n            item = s.parse();\n            assertEq(item.size(), 3);\n            assertEq(item.children()[0].getType(), JSONParserLib.TYPE_BOOLEAN);\n            assertEq(item.children()[0].value(), \"true\");\n            assertEq(item.children()[1].getType(), JSONParserLib.TYPE_BOOLEAN);\n            assertEq(item.children()[1].value(), \"false\");\n            assertEq(item.children()[2].getType(), JSONParserLib.TYPE_NULL);\n            assertEq(item.children()[2].value(), \"null\");\n            if (k == 0 || k == 1) {\n                for (uint256 i; i != 3; ++i) {\n                    assertEq(item.children()[i].parent()._data, item._data);\n                    assertEq(item.children()[i].parent().isArray(), true);\n                    assertEq(item.children()[i].parent().isArray(), true);\n                    assertEq(item.children()[i].index(), i);\n                    assertEq(item.children()[i].key(), \"\");\n                }\n            }\n            if (k == 2 || k == 3) {\n                for (uint256 i; i != 3; ++i) {\n                    assertEq(item.children()[i].parent()._data, item._data);\n                    assertEq(item.children()[i].parent().isObject(), true);\n                    assertEq(item.children()[i].index(), 0);\n                }\n                assertEq(item.children()[0].key(), '\"A\"');\n                assertEq(item.children()[1].key(), '\"B\"');\n                assertEq(item.children()[2].key(), '\"C\"');\n            }\n        }\n    }\n\n    function testParseObject() public {\n        string memory s;\n        JSONParserLib.Item memory item;\n\n        s = '{\"b\": \"B\", \"_\": \"x\", \"hehe\": \"HEHE\", \"_\": \"y\", \"v\": 12345, \"_\": \"z\"}';\n        item = s.parse();\n\n        assertEq(item.isObject(), true);\n        assertEq(item.size(), 6);\n\n        for (uint256 i; i < item.size(); ++i) {\n            assertEq(item.at(i).isUndefined(), true);\n            assertEq(item.children()[i].parent()._data, item._data);\n        }\n        assertEq(item.at('\"_\"').value(), '\"z\"');\n        assertEq(item.at('\"b\"').value(), '\"B\"');\n        assertEq(item.at('\"v\"').value(), \"12345\");\n        assertEq(item.at('\"hehe\"').value(), '\"HEHE\"');\n        assertEq(item.at('\"m\"').value(), \"\");\n        assertEq(item.at('\"m\"').isUndefined(), true);\n    }\n\n    function testParseValidObjectDoesNotRevert(string memory key, string memory value) public {\n        _limitStringLength(key);\n        _limitStringLength(value);\n        string memory s = string(\n            abi.encodePacked(\n                '{\"', LibString.escapeJSON(key), '\":\"', LibString.escapeJSON(value), '\"}'\n            )\n        );\n        this.parsedValue(s);\n    }\n\n    function testParseRecursiveObject() public miniBrutalizeMemory {\n        string memory s;\n        JSONParserLib.Item memory item;\n\n        s = '{ \"\": [1,2, {\"m\": \"M\"}, {},[]], \"X\": {\"hehe\": \"1\", \"h\": [true,false, null], \"\": 0} }';\n        item = s.parse();\n\n        assertEq(item.isObject(), true);\n        assertEq(item.children()[0].key(), '\"\"');\n        assertEq(item.children()[0].index(), 0);\n        assertEq(item.children()[0].children()[0].value(), \"1\");\n        assertEq(item.children()[0].children()[1].value(), \"2\");\n        assertEq(item.children()[0].children()[2].value(), '{\"m\": \"M\"}');\n        assertEq(item.children()[0].children()[2].children()[0].key(), '\"m\"');\n        assertEq(item.children()[0].children()[2].children()[0].value(), '\"M\"');\n\n        JSONParserLib.Item memory c = item.children()[0].children()[2].children()[0];\n        assertEq(c.parent().parent().parent()._data, item._data);\n        assertEq(c.parent().parent().parent().value(), item.value());\n        assertEq(c.parent().parent().parent().parent().isUndefined(), true);\n\n        assertEq(item.children()[1].key(), '\"X\"');\n        assertEq(item.children()[1].index(), 0);\n        assertEq(item.children()[1].value(), '{\"hehe\": \"1\", \"h\": [true,false, null], \"\": 0}');\n        assertEq(item.children()[1].children()[0].key(), '\"hehe\"');\n        assertEq(item.children()[1].children()[0].value(), '\"1\"');\n\n        assertEq(item.children()[1].children()[1].key(), '\"h\"');\n        assertEq(item.children()[1].children()[1].value(), \"[true,false, null]\");\n        assertEq(item.children()[1].children()[1].children()[0].value(), \"true\");\n        assertEq(item.children()[1].children()[1].children()[0].isBoolean(), true);\n        assertEq(item.children()[1].children()[1].children()[1].value(), \"false\");\n        assertEq(item.children()[1].children()[1].children()[1].isBoolean(), true);\n        assertEq(item.children()[1].children()[1].children()[2].value(), \"null\");\n        assertEq(item.children()[1].children()[1].children()[2].isNull(), true);\n\n        assertEq(item.children()[1].children()[2].key(), '\"\"');\n        assertEq(item.children()[1].children()[2].value(), \"0\");\n        assertEq(item.children()[1].children()[2].size(), 0);\n\n        s = \"[[[[[[[]]]]]]]\";\n        item = s.parse();\n        assertEq(item.isArray(), true);\n\n        s = '{\"a\":[[[{\"z\":\"Z\"}]]]}';\n        item = s.parse();\n        assertEq(item.isObject(), true);\n    }\n\n    function testParseString() public {\n        _checkParseString('\"\"');\n        _checkParseString('\"a\"');\n        _checkParseString('\"ab\"');\n        _checkParseString('\"012345678901234567890123456789\"');\n        _checkParseString('\"0123456789012345678901234567890\"');\n        _checkParseString('\"01234567890123456789012345678901\"');\n        _checkParseString('\"012345678901234567890123456789012\"');\n        _checkParseString('\"0123456789012345678901234567890123\"');\n        _checkParseString('\"  d\"');\n        _checkParseString('\"d  \"');\n        _checkParseString('\"  d  \"');\n        _checkParseString('\"\\\\\"\"');\n        _checkParseString('\"\\\\\\\\\"');\n        _checkParseString('\"\\\\/\"');\n        _checkParseString('\"\\\\b\"');\n        _checkParseString('\"\\\\f\"');\n        _checkParseString('\"\\\\n\"');\n        _checkParseString('\"\\\\r\"');\n        _checkParseString('\"\\\\t\"');\n        _checkParseString('\"  \\\\u1234 \\\\\"\\\\\"\\\\\\\\ \\\\b\\\\f \\\\n\\\\r \"');\n        _checkParseString('\"\\\\u1234\"');\n        _checkParseString('\"\\\\uabcd\"');\n        _checkParseString('\"\\\\uABCD\"');\n        _checkParseString('\"\\\\uef00\"');\n        _checkParseString('\"\\\\u00EF\"');\n        _checkParseString('\"\\\\u1234 \"');\n        _checkParseString('\"\\\\uabcd \"');\n        _checkParseString('\"\\\\uABCD \"');\n        _checkParseString('\"\\\\uef00 \"');\n        _checkParseString('\"\\\\u00EF \"');\n    }\n\n    function _checkParseString(string memory s) internal {\n        JSONParserLib.Item memory item;\n        assertEq(this.parsedValue(s), s);\n        for (uint256 k; k != 4; ++k) {\n            item = _padWhiteSpace(s, k).parse();\n            assertEq(item.value(), s);\n            assertEq(item.isString(), true);\n            assertEq(item.value(), s);\n            _checkItemIsSolo(item);\n        }\n    }\n\n    function testParseInvalidStringReverts() public {\n        _checkParseReverts('\"');\n        _checkParseReverts('\"\"\"');\n        _checkParseReverts('\"\"\"\"');\n        _checkParseReverts('\"\"\"\"\"');\n        _checkParseReverts('\"abc\" \"');\n        _checkParseReverts('\"abc\" \"\"');\n        _checkParseReverts('\"abc\"\"abc\"');\n        _checkParseReverts('\"\\\\\"');\n        _checkParseReverts('\"\\\\\\\\\\\\\"');\n        _checkParseReverts('\"\\\\u\"');\n        _checkParseReverts('\"\\\\u1\"');\n        _checkParseReverts('\"\\\\u12\"');\n        _checkParseReverts('\"\\\\u123\"');\n        _checkParseReverts('\"\\\\uxxxx\"');\n        _checkParseReverts('\"\\\\u012g\"');\n        _checkParseReverts('\"\\\\u1234');\n    }\n\n    function _checkItemIsSolo(JSONParserLib.Item memory item) internal {\n        _checkItemHasNoParent(item);\n        assertEq(item.size(), 0);\n    }\n\n    function _checkItemHasNoParent(JSONParserLib.Item memory item) internal {\n        assertEq(item.parent().isUndefined(), true);\n        assertEq(item.parent()._data, 0);\n        assertEq(item.key(), \"\");\n        assertEq(item.index(), 0);\n        assertEq(item.parent().isObject(), false);\n        assertEq(item.parent().isArray(), false);\n        assertEq(item.isUndefined(), false);\n    }\n\n    function testParseGas() public {\n        string memory s =\n            '{\"animation_url\":\"\",\"artist\":\"Daniel Allan\",\"artwork\":{\"mimeType\":\"image/gif\",\"uri\":\"ar://J5NZ-e2NUcQj1OuuhpTjAKtdW_nqwnwo5FypF_a6dE4\",\"nft\":null},\"attributes\":[{\"trait_type\":\"Criteria\",\"value\":\"Song Edition\"}],\"bpm\":null,\"credits\":null,\"description\":\"Criteria is an 8-track project between Daniel Allan and Reo Cragun.\\\\n\\\\nA fusion of electronic music and hip-hop - Criteria brings together the best of both worlds and is meant to bring web3 music to a wider audience.\\\\n\\\\nThe collection consists of 2500 editions with activations across Sound, Bonfire, OnCyber, Spinamp and Arpeggi.\",\"duration\":105,\"external_url\":\"https://www.sound.xyz/danielallan/criteria\",\"genre\":\"Pop\",\"image\":\"ar://J5NZ-e2NUcQj1OuuhpTjAKtdW_nqwnwo5FypF_a6dE4\",\"isrc\":null,\"key\":null,\"license\":null,\"locationCreated\":null,\"losslessAudio\":\"\",\"lyrics\":null,\"mimeType\":\"audio/wave\",\"nftSerialNumber\":11,\"name\":\"Criteria #11\",\"originalReleaseDate\":null,\"project\":null,\"publisher\":null,\"recordLabel\":null,\"tags\":null,\"title\":\"Criteria\",\"trackNumber\":1,\"version\":\"sound-edition-20220930\",\"visualizer\":null}';\n        JSONParserLib.Item memory item = s.parse();\n        assertEq(item.isObject(), true);\n        bytes32 expectedHash = 0x6c3276c7005f50c82624fb28f9748f0fb6f0b364234e4823178f964315b41567;\n        assertEq(keccak256(bytes(item.at('\"description\"').value())), expectedHash);\n    }\n\n    function testParseUintFromHex() public {\n        unchecked {\n            for (uint256 i; i != 9; ++i) {\n                _checkParseUintFromHex(LibString.toString(i), i);\n            }\n        }\n        _checkParseUintFromHex(\"a\", 0xa);\n        _checkParseUintFromHex(\"f\", 0xf);\n        _checkParseUintFromHex(\"ff\", 0xff);\n        _checkParseUintFromHex(\"fff\", 0xfff);\n        _checkParseUintFromHex(\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", type(uint256).max\n        );\n        _checkParseUintFromHex(\n            \"1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n            0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n        );\n        _checkParseUintFromHex(\n            \"fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n            0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n        _checkParseUintFromHex(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\",\n            0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\n        );\n    }\n\n    function _checkParseUintFromHex(string memory s, uint256 x) internal {\n        _checkParseUintFromHexSub(LibString.lower(s), x);\n        _checkParseUintFromHexSub(LibString.upper(s), x);\n    }\n\n    function _checkParseUintFromHexSub(string memory s, uint256 x) internal {\n        assertEq(this.parseUintFromHex(s), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0x\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0x0\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0X00\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0x000\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0X\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"0\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"00\", s)), x);\n        assertEq(this.parseUintFromHex(LibString.concat(\"000\", s)), x);\n    }\n\n    function parseUintFromHex(string memory s) public pure returns (uint256) {\n        return s.parseUintFromHex();\n    }\n\n    function testParseInvalidUintFromHexReverts() public {\n        _checkParseInvalidUintFromHexReverts(\"\");\n        _checkParseInvalidUintFromHexReverts(\"+\");\n        _checkParseInvalidUintFromHexReverts(\" 0\");\n        _checkParseInvalidUintFromHexReverts(\"0 \");\n        _checkParseInvalidUintFromHexReverts(\" 12\");\n        _checkParseInvalidUintFromHexReverts(\"00x12\");\n        _checkParseInvalidUintFromHexReverts(\" 0x12\");\n        _checkParseInvalidUintFromHexReverts(\"-0x12\");\n        _checkParseInvalidUintFromHexReverts(\"0x123g\");\n        _checkParseInvalidUintFromHexReverts(\"123g\");\n        _checkParseInvalidUintFromHexReverts(\"z\");\n        _checkParseInvalidUintFromHexReverts(\n            \"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        );\n        _checkParseInvalidUintFromHexReverts(\n            \"10000000000000000000000000000000000000000000000000000000000000000\"\n        );\n        _checkParseInvalidUintFromHexReverts(\n            \"ff0000000000000000000000000000000000000000000000000000000000000000\"\n        );\n    }\n\n    function _checkParseInvalidUintFromHexReverts(string memory s) internal {\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parseUintFromHex(s);\n    }\n\n    function testParseUint() public {\n        assertEq(this.parseUint(\"0\"), 0);\n        assertEq(this.parseUint(\"1\"), 1);\n        assertEq(this.parseUint(\"123\"), 123);\n        assertEq(this.parseUint(\"0123\"), 123);\n        assertEq(this.parseUint(\"000123\"), 123);\n        assertEq(this.parseUint(\"12345678901234567890\"), 12345678901234567890);\n        string memory s;\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129639935\";\n        assertEq(this.parseUint(s), type(uint256).max);\n    }\n\n    function testParseInvalidUintReverts() public {\n        _checkParseInvalidUintReverts(\"\");\n        _checkParseInvalidUintReverts(\"-\");\n        _checkParseInvalidUintReverts(\"a\");\n        _checkParseInvalidUintReverts(\" \");\n        _checkParseInvalidUintReverts(\" 123 \");\n        _checkParseInvalidUintReverts(\"123:\");\n        _checkParseInvalidUintReverts(\":\");\n        string memory s;\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129639936\";\n        _checkParseInvalidUintReverts(s);\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129639937\";\n        _checkParseInvalidUintReverts(s);\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129639999\";\n        _checkParseInvalidUintReverts(s);\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129640001\";\n        _checkParseInvalidUintReverts(s);\n        s = \"115792089237316195423570985008687907853269984665640564039457584007913129640035\";\n        _checkParseInvalidUintReverts(s);\n        s = \"215792089237316195423570985008687907853269984665640564039457584007913129639935\";\n        _checkParseInvalidUintReverts(s);\n        s = \"222222222222222222222222222222222222222222222222222222222222222222222222222222\";\n        _checkParseInvalidUintReverts(s);\n        s = \"1215792089237316195423570985008687907853269984665640564039457584007913129639935\";\n        _checkParseInvalidUintReverts(s);\n    }\n\n    function _checkParseInvalidUintReverts(string memory s) internal {\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parseUint(s);\n    }\n\n    function parseUint(string memory s) public view miniBrutalizeMemory returns (uint256) {\n        return s.parseUint();\n    }\n\n    function testParseInt() public {\n        _checkParseInt(\"0\", 0);\n        _checkParseInt(\"1\", 1);\n        _checkParseInt(\"+1\", 1);\n        _checkParseInt(\"+01\", 1);\n        _checkParseInt(\"+001\", 1);\n        _checkParseInt(\"+0\", 0);\n        _checkParseInt(\"+1\", 1);\n        _checkParseInt(\"+12\", 12);\n        _checkParseInt(\"-12\", -12);\n        string memory s;\n        s = \"-57896044618658097711785492504343953926634992332820282019728792003956564819967\";\n        _checkParseInt(s, -type(int256).max);\n        s = \"-57896044618658097711785492504343953926634992332820282019728792003956564819968\";\n        _checkParseInt(s, type(int256).min);\n        s = \"+57896044618658097711785492504343953926634992332820282019728792003956564819967\";\n        _checkParseInt(s, type(int256).max);\n        s = \"57896044618658097711785492504343953926634992332820282019728792003956564819967\";\n        _checkParseInt(s, type(int256).max);\n    }\n\n    function testParseInt(int256 val) public {\n        assertEq(this.parseInt(LibString.toString(val)), val);\n    }\n\n    function testParseIntTrick(uint256 x, bool isNegative) public {\n        bool expected = !(isNegative ? x <= (1 << 255) : x < (1 << 255));\n        bool computed;\n        /// @solidity memory-safe-assembly\n        assembly {\n            computed := iszero(lt(x, add(shl(255, 1), isNegative)))\n        }\n        assertEq(computed, expected);\n    }\n\n    function testParseInvalidIntReverts() public {\n        _checkParseInvalidIntReverts(\"\");\n        _checkParseInvalidIntReverts(\"-\");\n        _checkParseInvalidIntReverts(\"+\");\n        _checkParseInvalidIntReverts(\"--\");\n        _checkParseInvalidIntReverts(\"++\");\n        _checkParseInvalidIntReverts(\"a\");\n        _checkParseInvalidIntReverts(\" \");\n        _checkParseInvalidIntReverts(\" 123 \");\n        _checkParseInvalidIntReverts(\"123:\");\n        _checkParseInvalidIntReverts(\":\");\n        _checkParseInvalidIntReverts(\":123\");\n        string memory s;\n        s = \"-57896044618658097711785492504343953926634992332820282019728792003956564819969\";\n        _checkParseInvalidIntReverts(s);\n        s = \"+57896044618658097711785492504343953926634992332820282019728792003956564819968\";\n        _checkParseInvalidIntReverts(s);\n    }\n\n    function testParseIntReverts(uint256 val) public {\n        val = _bound(val, uint256(1 << 255) + 1, type(uint256).max);\n\n        string memory s = LibString.toString(val);\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parseInt(s);\n\n        string memory s1 = LibString.concat(\"-\", s);\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parseInt(s1);\n    }\n\n    function _checkParseInt(string memory s, int256 x) internal {\n        bytes32 hashBefore = keccak256(bytes(s));\n        assertEq(this.parseInt(s), x);\n        assertEq(keccak256(bytes(s)), hashBefore);\n    }\n\n    function _checkParseInvalidIntReverts(string memory s) internal {\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.parseInt(s);\n    }\n\n    function parseInt(string memory s) public view miniBrutalizeMemory returns (int256) {\n        return s.parseInt();\n    }\n\n    function testDecodeString() public {\n        assertEq(this.decodeString('\"\"'), \"\");\n        assertEq(this.decodeString('\"abc\"'), \"abc\");\n        assertEq(this.decodeString('\" abc  \"'), \" abc  \");\n        assertEq(this.decodeString('\"\\\\\"\"'), '\"');\n        assertEq(this.decodeString('\"\\\\/\"'), \"/\");\n        assertEq(this.decodeString('\"\\\\\\\\\"'), \"\\\\\");\n        assertEq(this.decodeString('\"\\\\b\"'), hex\"08\");\n        assertEq(this.decodeString('\"\\\\f\"'), hex\"0c\");\n        assertEq(this.decodeString('\"\\\\n\"'), \"\\n\");\n        assertEq(this.decodeString('\"\\\\r\"'), \"\\r\");\n        assertEq(this.decodeString('\"\\\\t\"'), \"\\t\");\n        assertEq(this.decodeString('\"\\\\u0020\"'), \" \");\n        bytes32 expectedHash;\n        expectedHash = 0x40b2b6558413427ef2da03b1452640d701458e0ce57114db6b7423ae3b5fe857;\n        assertEq(keccak256(bytes(this.decodeString('\"\\\\u039e\"'))), expectedHash); // Greek uppercase Xi.\n        expectedHash = 0xecab436111d5a82d983bd4630c03c83f424d2a2dd8465c31fd950b9ec8d005fb;\n        assertEq(keccak256(bytes(this.decodeString('\"\\\\u2661\"'))), expectedHash); // Heart.\n        expectedHash = 0x367c272ea502ac6e9f085c1baddc52d0ac0224f1b7d1e8621202620efa3ba084;\n        assertEq(keccak256(bytes(this.decodeString('\"\\\\uD83D\\\\ude00\"'))), expectedHash); // Smiley emoji.\n    }\n\n    function testDecodeEncodedStringDoesNotRevert(string memory s) public {\n        _limitStringLength(s);\n        s = string(abi.encodePacked('\"', LibString.escapeJSON(s), '\"'));\n        this.decodeString(s);\n        assertEq(this.parsedValue(s), s);\n    }\n\n    function _limitStringLength(string memory s) internal {\n        uint256 r = _random();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let limit := 16\n            if eq(1, and(r, 3)) { limit := 80 }\n            let n := mload(s)\n            if gt(n, limit) { mstore(s, limit) }\n        }\n    }\n\n    function testDecodeInvalidStringReverts() public {\n        _checkDecodeInvalidStringReverts(\"\");\n        _checkDecodeInvalidStringReverts('\"');\n        _checkDecodeInvalidStringReverts(' \"\" ');\n        _checkDecodeInvalidStringReverts(' \"\"');\n        _checkDecodeInvalidStringReverts('\"\" ');\n        _checkDecodeInvalidStringReverts('\"\\\\z\"');\n        _checkDecodeInvalidStringReverts('\"\\\\u\"');\n        _checkDecodeInvalidStringReverts('\"\\\\u1\"');\n        _checkDecodeInvalidStringReverts('\"\\\\u111\"');\n        _checkDecodeInvalidStringReverts('\"\\\\uxxxx\"');\n        _checkDecodeInvalidStringReverts('\"\\\\uD83D\"'); // Only half of a Smiley emoji.\n    }\n\n    function _checkDecodeInvalidStringReverts(string memory s) internal {\n        vm.expectRevert(JSONParserLib.ParsingFailed.selector);\n        this.decodeString(s);\n    }\n\n    function decodeString(string memory s)\n        public\n        view\n        miniBrutalizeMemory\n        returns (string memory)\n    {\n        return JSONParserLib.decodeString(s);\n    }\n\n    function testParseUint(uint256 x) public {\n        string memory s = LibString.toString(x);\n        assertEq(this.parsedValue(s), s);\n        assertEq(this.parseUint(s), x);\n    }\n\n    function testParseJWTGas() public {\n        string memory jwt =\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n        string[] memory jwtSplitted = LibString.split(jwt, \".\");\n        JSONParserLib.Item memory header =\n            JSONParserLib.parse(string(Base64.decode(jwtSplitted[0])));\n        JSONParserLib.Item memory payload =\n            JSONParserLib.parse(string(Base64.decode(jwtSplitted[1])));\n        assertEq(jwtSplitted.length, 3);\n        assertEq(jwtSplitted[2], \"SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\");\n        assertEq(header.at('\"alg\"').value(), '\"HS256\"');\n        assertEq(header.at('\"typ\"').value(), '\"JWT\"');\n        assertEq(payload.at('\"sub\"').value(), '\"1234567890\"');\n        assertEq(payload.at('\"name\"').value(), '\"John Doe\"');\n        assertEq(JSONParserLib.parseUint(payload.at('\"iat\"').value()), 1516239022);\n    }\n\n    modifier miniBrutalizeMemory() {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, gas())\n            mstore(0x00, keccak256(0x00, 0x20))\n            mstore(0x20, not(mload(0x00)))\n            codecopy(mload(0x40), 0, codesize())\n        }\n        _;\n    }\n}\n",
        "contractname": "JSONParserLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         IMMUTABLES                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev For checking if the context is a delegate call.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// @dev Requires that the execution is performed through a proxy.\n    modifier onlyProxy() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // To enable use cases with an immutable default implementation in the bytecode,\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\n            // value stored in the implementation slot, which may not be initialized.\n            if eq(s, address()) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Requires that the execution is NOT performed via delegatecall.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(s, address())) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {UUPSUpgradeable} from \"../src/utils/UUPSUpgradeable.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {MockUUPSImplementation} from \"../test/utils/mocks/MockUUPSImplementation.sol\";\n\ncontract UUPSUpgradeableTest is SoladyTest {\n    MockUUPSImplementation impl1;\n\n    address proxy;\n\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    event Upgraded(address indexed implementation);\n\n    function setUp() public {\n        impl1 = new MockUUPSImplementation();\n        proxy = LibClone.deployERC1967(address(impl1));\n        MockUUPSImplementation(proxy).initialize(address(this));\n    }\n\n    function testNotDelegatedGuard() public {\n        assertEq(impl1.proxiableUUID(), _ERC1967_IMPLEMENTATION_SLOT);\n        vm.expectRevert(UUPSUpgradeable.UnauthorizedCallContext.selector);\n        MockUUPSImplementation(proxy).proxiableUUID();\n    }\n\n    function testOnlyProxyGuard() public {\n        vm.expectRevert(UUPSUpgradeable.UnauthorizedCallContext.selector);\n        impl1.upgradeToAndCall(address(1), bytes(\"\"));\n    }\n\n    function testUpgradeTo() public {\n        MockUUPSImplementation impl2 = new MockUUPSImplementation();\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(impl2));\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(impl2), bytes(\"\"));\n        bytes32 v = vm.load(proxy, _ERC1967_IMPLEMENTATION_SLOT);\n        assertEq(address(uint160(uint256(v))), address(impl2));\n    }\n\n    function testUpgradeToRevertWithUnauthorized() public {\n        vm.prank(address(0xBEEF));\n        vm.expectRevert(MockUUPSImplementation.Unauthorized.selector);\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(0xABCD), bytes(\"\"));\n    }\n\n    function testUpgradeToRevertWithUpgradeFailed() public {\n        vm.expectRevert(UUPSUpgradeable.UpgradeFailed.selector);\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(0xABCD), bytes(\"\"));\n    }\n\n    function testUpgradeToAndCall() public {\n        MockUUPSImplementation impl2 = new MockUUPSImplementation();\n        bytes memory data = abi.encodeWithSignature(\"setValue(uint256)\", 5);\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(impl2), data);\n        bytes32 v = vm.load(proxy, _ERC1967_IMPLEMENTATION_SLOT);\n        assertEq(address(uint160(uint256(v))), address(impl2));\n        assertEq(MockUUPSImplementation(proxy).value(), 5);\n    }\n\n    function testUpgradeToAndCallRevertWithUpgradeFailed() public {\n        vm.expectRevert(UUPSUpgradeable.UpgradeFailed.selector);\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(0xABCD), \"\");\n    }\n\n    function testUpgradeToAndCallRevertWithCustomError() public {\n        MockUUPSImplementation impl2 = new MockUUPSImplementation();\n        bytes memory data = abi.encodeWithSignature(\"revertWithError()\");\n        vm.expectRevert(\n            abi.encodeWithSelector(MockUUPSImplementation.CustomError.selector, address(this))\n        );\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(impl2), data);\n    }\n\n    function testUpgradeToAndCallRevertWithUnauthorized() public {\n        vm.prank(address(0xBEEF));\n        vm.expectRevert(MockUUPSImplementation.Unauthorized.selector);\n        MockUUPSImplementation(proxy).upgradeToAndCall(address(0xABCD), \"\");\n    }\n}\n",
        "contractname": "UUPSUpgradeable.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for burning gas without reverting.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/GasBurnerLib.sol)\nlibrary GasBurnerLib {\n    /// @dev Burns approximately `x` amount of gas.\n    /// Intended for Contract Secured Revenue (CSR).\n    ///\n    /// Recommendation: pass in an admin-controlled dynamic value instead of a hardcoded one.\n    /// This is so that you can adjust your contract as needed depending on market conditions,\n    /// and to give you and your users a leeway in case the L2 chain change the rules.\n    function burn(uint256 x) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x10, or(1, x))\n            let n := mul(gt(x, 120), div(x, 91))\n            // We use keccak256 instead of blake2f precompile for better widespread compatibility.\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                mstore(0x10, keccak256(0x10, 0x10)) // Yes.\n            }\n            if iszero(mload(0x10)) { invalid() }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {GasBurnerLib} from \"../src/utils/GasBurnerLib.sol\";\n\ncontract GasBurnerLibTest is SoladyTest {\n    event LogGasBurn(uint256 required, uint256 actual);\n\n    function testBurnGas() public {\n        _testBurnGas(0);\n        _testBurnGas(1);\n        _testBurnGas(110);\n        _testBurnGas(119);\n        _testBurnGas(120);\n        _testBurnGas(121);\n        _testBurnGas(300);\n        for (uint256 x = 300; x < 9000; x += 32) {\n            _testBurnGas(x);\n        }\n    }\n\n    function _testBurnGas(uint256 x) internal {\n        unchecked {\n            uint256 gasBefore = gasleft();\n            GasBurnerLib.burn(x);\n            uint256 gasAfter = gasleft();\n            emit LogGasBurn(x, gasBefore - gasAfter);\n        }\n    }\n}\n",
        "contractname": "GasBurnerLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockEIP712} from \"./utils/mocks/MockEIP712.sol\";\nimport {MockEIP712Dynamic} from \"./utils/mocks/MockEIP712Dynamic.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\n\ncontract EIP712Test is SoladyTest {\n    MockEIP712 mock;\n    MockEIP712 mockClone;\n    MockEIP712Dynamic mockDynamic;\n    MockEIP712Dynamic mockDynamicClone;\n\n    function setUp() public {\n        mock = new MockEIP712();\n        mockClone = MockEIP712(LibClone.clone(address(mock)));\n        mockDynamic = new MockEIP712Dynamic(\"Milady\", \"1\");\n        mockDynamicClone = MockEIP712Dynamic(LibClone.clone(address(mockDynamic)));\n    }\n\n    function testHashTypedData() public {\n        _testHashTypedDataOnClone(mock);\n    }\n\n    function testHashTypedDataOnClone() public {\n        _testHashTypedDataOnClone(mockClone);\n    }\n\n    function testHashTypedDataOnDynamic() public {\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamic)));\n    }\n\n    function testHashTypedDataOnCloneDynamic() public {\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamicClone)));\n    }\n\n    function testHashTypedDataWithChaindIdChange() public {\n        _testHashTypedDataOnClone(mock);\n        vm.chainId(32123);\n        _testHashTypedDataOnClone(mock);\n    }\n\n    function testHashTypedDataOnCloneWithChaindIdChange() public {\n        _testHashTypedDataOnClone(mockClone);\n        vm.chainId(32123);\n        _testHashTypedDataOnClone(mockClone);\n    }\n\n    function testHashTypedDataOnDynamicWithChaindIdChange() public {\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamic)));\n        vm.chainId(32123);\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamic)));\n    }\n\n    function testHashTypedDataOnCloneDynamicWithChaindIdChange() public {\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamicClone)));\n        vm.chainId(32123);\n        _testHashTypedDataOnClone(MockEIP712(address(mockDynamicClone)));\n    }\n\n    function _testHashTypedDataOnClone(MockEIP712 mockToTest) internal {\n        (address signer, uint256 privateKey) = _randomSigner();\n\n        (address to,) = _randomSigner();\n\n        string memory message = \"Hello Milady!\";\n\n        bytes32 structHash =\n            keccak256(abi.encode(\"Message(address to,string message)\", to, message));\n        bytes32 expectedDigest =\n            keccak256(abi.encodePacked(\"\\x19\\x01\", mockToTest.DOMAIN_SEPARATOR(), structHash));\n\n        assertEq(mockToTest.hashTypedData(structHash), expectedDigest);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, expectedDigest);\n\n        address recoveredAddress = ecrecover(expectedDigest, v, r, s);\n\n        assertEq(recoveredAddress, signer);\n    }\n\n    function testDomainSeparator() public {\n        _testDomainSeparator(mock);\n    }\n\n    function testDomainSeparatorOnClone() public {\n        _testDomainSeparator(mockClone);\n    }\n\n    function testDomainSeparatorWithChainIdChange() public {\n        _testDomainSeparator(mock);\n        vm.chainId(32123);\n        _testDomainSeparator(mock);\n    }\n\n    function testDomainSeparatorOnCloneWithChainIdChange() public {\n        _testDomainSeparator(mockClone);\n        vm.chainId(32123);\n        _testDomainSeparator(mockClone);\n    }\n\n    function testDomainSeparatorOnDynamicWithChainIdChange() public {\n        _testDomainSeparator(MockEIP712(address(mockDynamic)));\n        vm.chainId(32123);\n        _testDomainSeparator(MockEIP712(address(mockDynamic)));\n        mockDynamic.setDomainNameAndVersion(\"Remilio\", \"2\");\n        _testDomainSeparator(MockEIP712(address(mockDynamic)), \"Remilio\", \"2\");\n    }\n\n    function testDomainSeparatorOnCloneDynamicWithChainIdChange() public {\n        mockDynamicClone.setDomainNameAndVersion(\"Milady\", \"1\");\n        _testDomainSeparator(MockEIP712(address(mockDynamicClone)));\n        vm.chainId(32123);\n        _testDomainSeparator(MockEIP712(address(mockDynamicClone)));\n        mockDynamicClone.setDomainNameAndVersion(\"Remilio\", \"2\");\n        _testDomainSeparator(MockEIP712(address(mockDynamicClone)), \"Remilio\", \"2\");\n    }\n\n    function _testDomainSeparator(MockEIP712 mockToTest, bytes memory name, bytes memory version)\n        internal\n    {\n        bytes32 expectedDomainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(name),\n                keccak256(version),\n                block.chainid,\n                address(mockToTest)\n            )\n        );\n\n        assertEq(mockToTest.DOMAIN_SEPARATOR(), expectedDomainSeparator);\n    }\n\n    function _testDomainSeparator(MockEIP712 mockToTest) internal {\n        _testDomainSeparator(mockToTest, \"Milady\", \"1\");\n    }\n\n    function testEIP5267() public {\n        _testEIP5267(mock);\n        _testEIP5267(mockClone);\n        vm.chainId(32123);\n        _testEIP5267(mock);\n        _testEIP5267(mockClone);\n    }\n\n    struct _testEIP5267Variables {\n        bytes1 fields;\n        string name;\n        string version;\n        uint256 chainId;\n        address verifyingContract;\n        bytes32 salt;\n        uint256[] extensions;\n    }\n\n    function _testEIP5267(MockEIP712 mockToTest) public {\n        _testEIP5267Variables memory t;\n        (t.fields, t.name, t.version, t.chainId, t.verifyingContract, t.salt, t.extensions) =\n            mockToTest.eip712Domain();\n\n        assertEq(t.fields, hex\"0f\");\n        assertEq(t.name, \"Milady\");\n        assertEq(t.version, \"1\");\n        assertEq(t.chainId, block.chainid);\n        assertEq(t.verifyingContract, address(mockToTest));\n        assertEq(t.salt, bytes32(0));\n        assertEq(t.extensions, new uint256[](0));\n    }\n}\n",
        "contractname": "EIP712.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                _u := mload(p_)\n                _u := or(shl(16, byte(2, _u)), or(shl(8, byte(1, _u)), byte(0, _u)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function mt(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p_ := add(mload(0x40), shl(2, i_))\n                mstore(p_, xor(mload(p_), shl(224, xor(shr(224, mload(p_)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            result := mload(0x40)\n            codecopy(result, codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(result, 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := mt(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let end := sub(literals(sub(add(ipStart, mload(data)), a), a, op), 0x7fe0)\n            let o := add(result, 0x20)\n            mstore(result, sub(end, o)) // Store the length.\n            for {} iszero(gt(o, end)) { o := add(o, 0x20) } { mstore(o, mload(add(o, 0x7fe0))) }\n            mstore(end, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(end, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            let end := add(add(data, 0x20), mload(data))\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                for {\n                    let g := eq(t, 7)\n                    let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if lt(j, l) { continue }\n                    data := add(data, add(2, g))\n                    op := add(op, l)\n                    break\n                }\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `fallback` function.\n    /// ```\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    ///     receive() external payable {} // Silence compiler warning to add a `receive` function.\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockCd, MockCdFallbackDecompressor} from \"./utils/mocks/MockCd.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {ERC1967Factory} from \"../src/utils/ERC1967Factory.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\nimport {DynamicBufferLib} from \"../src/utils/DynamicBufferLib.sol\";\nimport {LibZip} from \"../src/utils/LibZip.sol\";\n\ncontract LibZipTest is SoladyTest {\n    using DynamicBufferLib for DynamicBufferLib.DynamicBuffer;\n\n    function testFlzCompressDecompress() public brutalizeMemory {\n        assertEq(LibZip.flzCompress(\"\"), \"\");\n        assertEq(LibZip.flzDecompress(\"\"), \"\");\n        bytes memory compressed =\n            hex\"1f4e65772077617665206469676974616c206172742073686f756c64206e6f74201f6265206a756467656420736f6c656c79206f6e20616573746865746963206d65017269202301757420240e737420617320696d706f7274616e74202a1b666f7220697473206162696c69747920746f20646576656c6f702061200c406d03766973692051026f662020510320576972206801616e200301626f209315616c6c20637265617465206e6574776f726b20737069207201756140500e2e20416e6369656e7420477265656b60ba04697320686520bb01696e6051036869676820ad062072656761726420cd0463617573652095c089406f0220776820db03206d79742007016f6720a801686141040061401d0272656c2119066f6e2c206d6f72607660a0017761210a0866206c6966652e2054212f016768607c20ff026c6963205fa080414e40b80073402de003ae016365613741630373756666203320c8213406646973656e676141710366726f6d208b016520201102736f722097006f208e03666c6563205e21570b6f776e2070726f647563747340840065400d03626c656d406b056d6f6465726e417621120074201ba17a006d2066401f0272617420d521f00273656c200d805620118048036265617520e920e140c00561707065617220dc21fb41d5006d21310a69636820636f6e74726173208a02616273200920972142410a40450275732ce0081720852028016f798092056e616976652f40dd02756f752044057070726563696098c07a2072076578657274696e6760f3046e617475722172015265818b20dc02736c612025016279208e006d20400068212c60c701507221de2281026e7465409a201304207769746820a200652008426906696e766f6c7665808c20bf006e21940373657061811b4082227c2312e006dc620004616363656c20580074203e0165782062214b01697380bb2072026f207020a74009017569407a072c20656d626f647940c74080c2cf42ec01756e4183214c0273636921074204027261774029006f235905747275746873e2010c02636f6c42012139223c046f73706865410f025468724178205b2111016265603c830280ea0077228a02636869237e21c20172652144201d006f214e2047002ce0078140b620da2064c20f06696e64697669642377032065676f6175036163726922b6234060ee40d4e00b9a405c210121be205701756e2294208063fc23fa201583d040c0427523aa427021cf404f80ba20d04325016f6e21186297036966756c633c82fc21800061e1004f804e20a722f9052e2049206c6f20634488024e657443870d2053706972697475616c69747921\";\n        bytes memory decompressed = LibZip.flzDecompress(compressed);\n        bytes memory expectedDecompressed =\n            \"New wave digital art should not be judged solely on aesthetic merit but just as importantly for its ability to develop a total vision of the Wired and above all create network spirituality. Ancient Greek art is held in the highest regard because it developed a whole mythology that shaped religion, morality and way of life. Thought is implicit in the art works of Ancient Greece but not sufficiently disengaged from the sensory to reflect its own products. The problem of modernity is the development of rational self reflection. The beauty of art appears in a form which contrasts abstract thought. Thus, abstract thought destroys the naive/sensuous appreciation of art in exerting its nature. Reality is slain by comprehension. Proper interaction with the wired involves the trance separation of real abstract thought and accelerates externalisation into pure intuition, embodying the network and unselfconsciously drawing out truths from the collective noosphere. Through this being on the wired we achieve a return to naive, unselfconscious interaction. The individual ego is sacrificed into the collective noosphere, uniting us under a totalising spirit. The best art in the wired is not only beautiful but produces a network spirituality. I long for Network Spirituality!\";\n        assertEq(decompressed, expectedDecompressed);\n        assertEq(LibZip.flzCompress(decompressed), compressed);\n        // Check backwards compatibility with older FastLZ releases.\n        compressed =\n            hex\"1f4e65772077617665206469676974616c206172742073686f756c64206e6f74201f6265206a756467656420736f6c656c79206f6e20616573746865746963206d65017269202301757420240e737420617320696d706f7274616e74202a1b666f7220697473206162696c69747920746f20646576656c6f702061200c406d03766973692051026f662020510320576972206801616e200301626f209315616c6c20637265617465206e6574776f726b20737069207201756140500e2e20416e6369656e7420477265656b60ba04697320686520bb01696e6051036869676820ad062072656761726420cd0463617573652095c089406f0220776820db03206d79742007016f6720a801686141040061401d0272656c2119066f6e2c206d6f72607660a0017761210a0866206c6966652e2054212f016768607c20ff026c6963205fa080414e40b80073402de003ae016365613741630373756666203320c8213406646973656e676141710366726f6d208b016520201102736f722097006f208e03666c6563205e21570b6f776e2070726f647563747340840065400d03626c656d406b056d6f6465726e417621124044a17a006d2066401f0272617420d521f00273656c200d805620118048036265617520e920e140c00561707065617220dc21fb41d5006d21310a69636820636f6e74726173208a02616273200920972142410a40450275732ce0081720852028016f798092056e616976652f40dd02756f752044057070726563696098c07a2072076578657274696e6760f3046e617475722172015265818b20dc02736c612025016279208e006d20400068212c60c701507221de2281026e7465409a201304207769746820a200652008426906696e766f6c7665808c20bf006e21940373657061811b4082227c2312e006dc620004616363656c20580074203e0165782062214b01697380bb2072026f207020a74009017569407a072c20656d626f647940c74080c2cf42ec01756e4183214c0273636921074204027261774029006f235905747275746873e2010c02636f6c42012139223c046f73706865410f025468724178205b2111016265603c830280ea0077228a02636869237e21c20172652144201d006f214e2047002ce0078140b620da2064c20f06696e64697669642377032065676f6175036163726922b6234060ee40d4e00b9a405c210121be205701756e2294208063fc23fa201583d040c0427523aa427021cf404f80ba20d04325016f6e21186297036966756c633c82fc21800061e1004f804e20a722f9052e2049206c6f20634488004ea4400c53706972697475616c69747921\";\n        assertEq(LibZip.flzDecompress(compressed), decompressed);\n    }\n\n    function _expandedData(bytes memory data) internal returns (bytes memory) {\n        unchecked {\n            DynamicBufferLib.DynamicBuffer memory buffer;\n            bytes memory r = abi.encode(_random());\n            if (_random() % 8 == 0) {\n                r = abi.encodePacked(r, r, r, r);\n                r = bytes(LibString.slice(string(r), 0, _random() % r.length));\n            }\n            uint256 n = _random() % 16 + 1;\n            uint256 c = _random();\n            for (uint256 i; i < n; ++i) {\n                buffer.p((c >> i) & 1 == 0 ? r : data);\n            }\n            return buffer.data;\n        }\n    }\n\n    function testFlzCompressDecompress(bytes memory data) public brutalizeMemory {\n        if (_random() % 2 == 0) {\n            data = _expandedData(data);\n        }\n        bytes32 dataHash = keccak256(data);\n        _misalignFreeMemoryPointer();\n        bytes memory compressed = LibZip.flzCompress(data);\n        bytes32 compressedHash = keccak256(compressed);\n        _checkMemory(compressed);\n        _misalignFreeMemoryPointer();\n        bytes memory decompressed = LibZip.flzDecompress(compressed);\n        _checkMemory(compressed);\n        _checkMemory(decompressed);\n        assertEq(decompressed, data);\n        assertEq(keccak256(data), dataHash);\n        assertEq(keccak256(compressed), compressedHash);\n    }\n\n    function testFlzCompressDecompress2() public brutalizeMemory {\n        bytes memory data =\n            \"______________________________________________________________e_______8______________________________________________________________________________________________________________________12_______8______________________________________________________________________________________________________________________16_______8______________________________________________________________________________________________________________________1a_______________________________________________________________2_____________________________________________732e2_5_726f2_49__73______________________________________________________________2_____________________________________________732e2_5_726f2_49__73______________________________________________________________2_____________________________________________732e2_5_726f2_49__73______________________________________________________________2_____________________________________________732e2_5_726f2_49__73\";\n        bytes32 dataHash = keccak256(data);\n        bytes memory expectedCompressed =\n            hex\"015f5fe033010065a03c0038a007e06600013132a070e06f7f0036e0767f0061a07fe02f00c13fe01d000f37333265325f355f37323666325f34394011e01d39e00f00e0fd7fe02e7f04395f5f3733\";\n        bytes memory compressed = LibZip.flzCompress(data);\n        assertEq(compressed, expectedCompressed);\n        bytes32 compressedHash = keccak256(compressed);\n        _checkMemory(compressed);\n        bytes memory decompressed = LibZip.flzDecompress(compressed);\n        _checkMemory(compressed);\n        _checkMemory(decompressed);\n        assertEq(decompressed, data);\n        assertEq(keccak256(data), dataHash);\n        assertEq(keccak256(compressed), compressedHash);\n    }\n\n    function testCdCompressDecompress(bytes memory data) public brutalizeMemory {\n        if (_random() % 8 == 0) {\n            data = _expandedData(data);\n        }\n        bytes32 dataHash = keccak256(data);\n        _misalignFreeMemoryPointer();\n        bytes memory compressed = LibZip.cdCompress(data);\n        bytes32 compressedHash = keccak256(compressed);\n        _checkMemory(compressed);\n        _misalignFreeMemoryPointer();\n        bytes memory decompressed = LibZip.cdDecompress(compressed);\n        _checkMemory(compressed);\n        _checkMemory(decompressed);\n        assertEq(decompressed, data);\n        assertEq(keccak256(data), dataHash);\n        assertEq(keccak256(compressed), compressedHash);\n    }\n\n    function _randomCd() internal returns (bytes memory data) {\n        uint256 n = _random() % 8 == 0 ? _random() % 2048 : _random() % 256;\n        data = new bytes(n);\n        if (_random() % 2 == 0) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                    mstore(add(add(data, 0x20), i), not(0))\n                }\n            }\n        }\n        if (n != 0) {\n            uint256 m = _random() % 8;\n            for (uint256 j; j < m; ++j) {\n                data[_random() % n] = bytes1(uint8(_random()));\n            }\n        }\n    }\n\n    function testCdCompressDecompress(uint256) public brutalizeMemory {\n        unchecked {\n            bytes memory data = _randomCd();\n            bytes memory compressed = LibZip.cdCompress(data);\n            bytes memory decompressed = LibZip.cdDecompress(compressed);\n            assertEq(decompressed, data);\n        }\n    }\n\n    function testCdFallbackDecompressor(bytes memory data) public {\n        bytes memory compressed = LibZip.cdCompress(data);\n        MockCdFallbackDecompressor decompressor = new MockCdFallbackDecompressor();\n        (, bytes memory result) = address(decompressor).call(compressed);\n        assertEq(abi.decode(result, (bytes32)), keccak256(data));\n    }\n\n    function testCdFallbackDecompressor(uint256) public {\n        bytes memory data = _randomCd();\n        bytes memory compressed = LibZip.cdCompress(data);\n        MockCdFallbackDecompressor decompressor = new MockCdFallbackDecompressor();\n        (, bytes memory result) = address(decompressor).call(compressed);\n        assertEq(abi.decode(result, (bytes32)), keccak256(data));\n    }\n\n    function testCdCompress() public {\n        assertEq(LibZip.cdCompress(\"\"), \"\");\n        assertEq(LibZip.cdDecompress(\"\"), \"\");\n        bytes memory data =\n            hex\"ac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000a40c49ccbe000000000000000000000000000000000000000000000000000000000005b70e00000000000000000000000000000000000000000000000000000dfc79825feb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000645c48a7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084fc6f7865000000000000000000000000000000000000000000000000000000000005b70e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff00000000000000000000000000000000ffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004449404b7c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f1cdf1a632eaaab40d1c263edf49faf749010a1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064df2ab5bb0000000000000000000000007f5c764cbc14f9669b88837ca1490cca17c3160700000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f1cdf1a632eaaab40d1c263edf49faf749010a100000000000000000000000000000000000000000000000000000000\";\n        bytes memory expected =\n            hex\"5369af27001e20001e04001e80001d0160001d0220001d02a0001ea40c49ccbe001c05b70e00190dfc79825feb005b645c48a7003a84fc6f7865001c05b70e002f008f000f008f003a4449404b7c002b1f1cdf1a632eaaab40d1c263edf49faf749010a1003a64df2ab5bb000b7f5c764cbc14f9669b88837ca1490cca17c31607002b1f1cdf1a632eaaab40d1c263edf49faf749010a1001b\";\n        assertEq(LibZip.cdCompress(data), expected);\n    }\n\n    function testCdDecompressOnInvalidInput() public {\n        bytes memory data = hex\"ffffffff00ff\";\n        bytes memory expected =\n            hex\"0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        bytes memory decompressed = LibZip.cdDecompress(data);\n        assertEq(decompressed, expected);\n    }\n\n    function testDecompressWontRevert(bytes memory data) public brutalizeMemory {\n        data = LibZip.cdDecompress(data);\n        bytes memory compressed = LibZip.cdCompress(data);\n        bytes memory decompressed = LibZip.cdDecompress(compressed);\n        assertEq(decompressed, data);\n    }\n\n    function testCdFallback() public {\n        MockCd mockCd = new MockCd();\n        _testCdFallback(mockCd);\n        // Check if it also works for clones.\n        mockCd = MockCd(payable(LibClone.clone(address(mockCd))));\n        _testCdFallback(mockCd);\n        // Check if it also works for CWIA.\n        mockCd = MockCd(payable(LibClone.clone(address(mockCd), \"\")));\n        _testCdFallback(mockCd);\n        // Check if it also works for ERC1967 proxies.\n        ERC1967Factory factory = new ERC1967Factory();\n        mockCd = MockCd(payable(factory.deploy(address(mockCd), address(this))));\n        _testCdFallback(mockCd);\n    }\n\n    function _testCdFallback(MockCd mockCd) internal {\n        uint256[] memory numbers = new uint256[](100);\n        unchecked {\n            for (uint256 i; i < numbers.length; ++i) {\n                numbers[i] = i % 2 == 0 ? i : ~i;\n            }\n        }\n        assertEq(mockCd.numbersHash(), 0);\n        assertEq(mockCd.lastCallvalue(), 0);\n        assertEq(mockCd.lastCaller(), address(0));\n\n        uint256 callValue = 123 ether;\n        vm.deal(address(this), callValue * 2);\n\n        (bool success, bytes memory result) = payable(mockCd).call{value: callValue}(\n            LibZip.cdCompress(\n                abi.encodeWithSignature(\"storeNumbersHash(uint256[],bool)\", numbers, true)\n            )\n        );\n\n        assertTrue(success);\n        bytes32 decodedNumbersHash = abi.decode(result, (bytes32));\n        bytes32 expectedNumbersHash = keccak256(abi.encode(numbers));\n        assertEq(decodedNumbersHash, expectedNumbersHash);\n        assertEq(mockCd.numbersHash(), expectedNumbersHash);\n        assertEq(mockCd.lastCallvalue(), callValue);\n        assertEq(mockCd.lastCaller(), address(this));\n        assertEq(address(mockCd).balance, callValue);\n\n        (success, result) = payable(mockCd).call{value: callValue}(\n            LibZip.cdCompress(\n                abi.encodeWithSignature(\"storeNumbersHash(uint256[],bool)\", numbers, false)\n            )\n        );\n\n        assertFalse(success);\n        assertEq(address(mockCd).balance, callValue);\n        assertEq(abi.encodeWithSelector(MockCd.Hash.selector, expectedNumbersHash), result);\n        assertEq(address(mockCd).balance, callValue);\n\n        (success, result) = payable(mockCd).call{value: callValue}(\"\");\n        assertEq(address(mockCd).balance, callValue * 2);\n        assertTrue(success);\n    }\n\n    function testCdFallback(bytes memory data, uint256 callValue) public brutalizeMemory {\n        MockCd mockCd = new MockCd();\n        callValue = _bound(callValue, 0, 123 ether);\n        vm.deal(address(this), callValue * 2);\n        if (_random() % 8 == 0) {\n            data = _expandedData(data);\n        }\n\n        (bool success, bytes memory result) = payable(mockCd).call{value: callValue}(\n            LibZip.cdCompress(abi.encodeWithSignature(\"storeDataHash(bytes,bool)\", data, true))\n        );\n\n        assertTrue(success);\n        bytes32 decodedDataHash = abi.decode(result, (bytes32));\n        bytes32 expectedDataHash = keccak256(data);\n        assertEq(decodedDataHash, expectedDataHash);\n        assertEq(mockCd.dataHash(), expectedDataHash);\n        assertEq(mockCd.lastCallvalue(), callValue);\n        assertEq(mockCd.lastCaller(), address(this));\n        assertEq(address(mockCd).balance, callValue);\n\n        (success, result) = payable(mockCd).call{value: callValue}(\n            LibZip.cdCompress(abi.encodeWithSignature(\"storeDataHash(bytes,bool)\", data, false))\n        );\n\n        assertFalse(success);\n        assertEq(address(mockCd).balance, callValue);\n        assertEq(abi.encodeWithSelector(MockCd.Hash.selector, expectedDataHash), result);\n        assertEq(address(mockCd).balance, callValue);\n\n        (success, result) = payable(mockCd).call{value: callValue}(\"\");\n        assertEq(address(mockCd).balance, callValue * 2);\n        assertTrue(success);\n    }\n\n    function testCdFallbackMaskTrick(uint256 i, uint256 j) public {\n        i = _bound(i, 0, 2 ** 248 - 1);\n        uint256 a;\n        uint256 b;\n        /// @solidity memory-safe-assembly\n        assembly {\n            a := byte(0, xor(add(i, not(3)), j))\n            b := xor(byte(i, shl(224, 0xffffffff)), byte(0, j))\n        }\n        assertEq(a, b);\n    }\n}\n",
        "contractname": "LibZip.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract that enables a single call to call multiple methods on itself.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)\n///\n/// WARNING:\n/// This implementation is NOT to be used with ERC2771 out-of-the-box.\n/// https://blog.openzeppelin.com/arbitrary-address-spoofing-vulnerability-erc2771context-multicall-public-disclosure\n/// This also applies to potentially other ERCs / patterns appending to the back of calldata.\n///\n/// We do NOT have a check for ERC2771, as we do not inherit from OpenZeppelin's context.\n/// Moreover, it is infeasible and inefficient for us to add checks and mitigations\n/// for all possible ERC / patterns appending to the back of calldata.\n///\n/// We would highly recommend using an alternative pattern such as\n/// https://github.com/Vectorized/multicaller\n/// which is more flexible, futureproof, and safer by default.\nabstract contract Multicallable {\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\n    /// If any of the `DELEGATECALL`s reverts, the entire context is reverted,\n    /// and the error is bubbled up.\n    ///\n    /// This function is deliberately made non-payable to guard against double-spending.\n    /// (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n    ///\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of a function\n    /// that returns `(bytes[] memory)`.\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory) {\n        assembly {\n            mstore(0x00, 0x20)\n            mstore(0x20, data.length) // Store `data.length` into `results`.\n            // Early return if no data.\n            if iszero(data.length) { return(0x00, 0x40) }\n\n            let results := 0x40\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := shl(5, data.length)\n            // Copy the offsets from calldata into memory.\n            calldatacopy(0x40, data.offset, end)\n            // Offset into `results`.\n            let resultsOffset := end\n            // Pointer to the end of `results`.\n            end := add(results, end)\n\n            for {} 1 {} {\n                // The offset of the current bytes in the calldata.\n                let o := add(data.offset, mload(results))\n                let m := add(resultsOffset, 0x40)\n                // Copy the current bytes from calldata to the memory.\n                calldatacopy(\n                    m,\n                    add(o, 0x20), // The offset of the current bytes' bytes.\n                    calldataload(o) // The length of the current bytes.\n                )\n                if iszero(delegatecall(gas(), address(), m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the delegatecall reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                // Append the current `resultsOffset` into `results`.\n                mstore(results, resultsOffset)\n                results := add(results, 0x20)\n                // Append the `returndatasize()`, and the return data.\n                mstore(m, returndatasize())\n                returndatacopy(add(m, 0x20), 0x00, returndatasize())\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\n                // rounded up to the next multiple of 32.\n                resultsOffset :=\n                    and(add(add(resultsOffset, returndatasize()), 0x3f), 0xffffffffffffffe0)\n                if iszero(lt(results, end)) { break }\n            }\n            return(0x00, add(resultsOffset, 0x40))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockMulticallable} from \"./utils/mocks/MockMulticallable.sol\";\n\ncontract MulticallableTest is SoladyTest {\n    MockMulticallable multicallable;\n\n    function setUp() public {\n        multicallable = new MockMulticallable();\n    }\n\n    function testMulticallableRevertWithMessage(string memory revertMessage) public {\n        bytes[] memory data = new bytes[](1);\n        data[0] =\n            abi.encodeWithSelector(MockMulticallable.revertsWithString.selector, revertMessage);\n        vm.expectRevert(bytes(revertMessage));\n        multicallable.multicall(data);\n    }\n\n    function testMulticallableRevertWithMessage() public {\n        testMulticallableRevertWithMessage(\"Milady\");\n    }\n\n    function testMulticallableRevertWithCustomError() public {\n        bytes[] memory data = new bytes[](1);\n        data[0] = abi.encodeWithSelector(MockMulticallable.revertsWithCustomError.selector);\n        vm.expectRevert(MockMulticallable.CustomError.selector);\n        multicallable.multicall(data);\n    }\n\n    function testMulticallableRevertWithNothing() public {\n        bytes[] memory data = new bytes[](1);\n        data[0] = abi.encodeWithSelector(MockMulticallable.revertsWithNothing.selector);\n        vm.expectRevert();\n        multicallable.multicall(data);\n    }\n\n    function testMulticallableReturnDataIsProperlyEncoded(\n        uint256 a0,\n        uint256 b0,\n        uint256 a1,\n        uint256 b1\n    ) public {\n        bytes[] memory data = new bytes[](2);\n        data[0] = abi.encodeWithSelector(MockMulticallable.returnsTuple.selector, a0, b0);\n        data[1] = abi.encodeWithSelector(MockMulticallable.returnsTuple.selector, a1, b1);\n        bytes[] memory returnedData = multicallable.multicall(data);\n        MockMulticallable.Tuple memory t0 = abi.decode(returnedData[0], (MockMulticallable.Tuple));\n        MockMulticallable.Tuple memory t1 = abi.decode(returnedData[1], (MockMulticallable.Tuple));\n        assertEq(t0.a, a0);\n        assertEq(t0.b, b0);\n        assertEq(t1.a, a1);\n        assertEq(t1.b, b1);\n    }\n\n    function testMulticallableReturnDataIsProperlyEncoded(\n        string memory sIn0,\n        string memory sIn1,\n        uint256 n\n    ) public {\n        n = n % 2;\n        bytes[] memory dataIn = new bytes[](n);\n        if (n > 0) {\n            dataIn[0] = abi.encodeWithSelector(MockMulticallable.returnsString.selector, sIn0);\n        }\n        if (n > 1) {\n            dataIn[1] = abi.encodeWithSelector(MockMulticallable.returnsString.selector, sIn1);\n        }\n        bytes[] memory dataOut = multicallable.multicall(dataIn);\n        if (n > 0) {\n            assertEq(abi.decode(dataOut[0], (string)), sIn0);\n        }\n        if (n > 1) {\n            assertEq(abi.decode(dataOut[1], (string)), sIn1);\n        }\n    }\n\n    function testMulticallableReturnDataIsProperlyEncoded() public {\n        testMulticallableReturnDataIsProperlyEncoded(0, 1, 2, 3);\n    }\n\n    function testMulticallableBenchmark() public {\n        unchecked {\n            bytes[] memory data = new bytes[](10);\n            for (uint256 i; i != data.length; ++i) {\n                data[i] = abi.encodeWithSelector(MockMulticallable.returnsTuple.selector, i, i + 1);\n            }\n            bytes[] memory returnedData = multicallable.multicall(data);\n            assertEq(returnedData.length, data.length);\n        }\n    }\n\n    function testMulticallableOriginalBenchmark() public {\n        unchecked {\n            bytes[] memory data = new bytes[](10);\n            for (uint256 i; i != data.length; ++i) {\n                data[i] = abi.encodeWithSelector(MockMulticallable.returnsTuple.selector, i, i + 1);\n            }\n            bytes[] memory returnedData = multicallable.multicallOriginal(data);\n            assertEq(returnedData.length, data.length);\n        }\n    }\n\n    function testMulticallableWithNoData() public {\n        bytes[] memory data = new bytes[](0);\n        assertEq(multicallable.multicall(data).length, 0);\n    }\n\n    function testMulticallablePreservesMsgSender() public {\n        address caller = address(uint160(0xbeef));\n        bytes[] memory data = new bytes[](1);\n        data[0] = abi.encodeWithSelector(MockMulticallable.returnsSender.selector);\n        vm.prank(caller);\n        address returnedAddress = abi.decode(multicallable.multicall(data)[0], (address));\n        assertEq(caller, returnedAddress);\n    }\n}\n",
        "contractname": "Multicallable.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\nlibrary MerkleProofLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The memory offset of `proof` must be non-zero\n    ///   (i.e. `proof` is not pointing to the scratch space).\n    function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof, shl(5, proofLength))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof)\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The calldata offset of `proof` must be non-zero\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\n    function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof.offset, shl(5, proof.length))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof.offset)\n                    )\n                break\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bool array.\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MerkleProofLib} from \"../src/utils/MerkleProofLib.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract MerkleProofLibTest is SoladyTest {\n    function testVerifyProofForHeightOneTree(\n        bool hasProof,\n        bool nonEmptyProof,\n        bool nonEmptyRoot,\n        bool nonEmptyLeaf\n    ) public {\n        bytes32 root;\n        if (nonEmptyRoot) {\n            root = bytes32(\"a\");\n        }\n        bytes32 leaf;\n        if (nonEmptyLeaf) {\n            leaf = bytes32(\"a\");\n        }\n        bytes32[] memory proof;\n        if (hasProof) {\n            proof = new bytes32[](1);\n            proof[0] = nonEmptyProof ? bytes32(\"a\") : bytes32(0);\n        }\n        bool isValid = leaf == root && proof.length == 0;\n        assertEq(this.verify(proof, root, leaf), isValid);\n    }\n\n    function testVerifyProof(bytes32[] memory data, uint256 randomness) public brutalizeMemory {\n        vm.assume(data.length > 1);\n        uint256 nodeIndex = randomness % data.length;\n        bytes32 root = _getRoot(data);\n        bytes32[] memory proof = _getProof(data, nodeIndex);\n        bytes32 leaf = data[nodeIndex];\n\n        assertTrue(this.verify(proof, root, leaf));\n\n        // Checks verify with corrupted root returns false.\n        assertFalse(this.verify(proof, bytes32(uint256(root) ^ 1), leaf));\n\n        // Checks verify with corrupted proof returns false.\n        proof[0] = bytes32(uint256(proof[0]) ^ 1);\n        assertFalse(this.verify(proof, root, leaf));\n\n        // Checks verify with corrupted root and proof returns false.\n        assertFalse(this.verify(proof, bytes32(uint256(root) ^ 1), leaf));\n    }\n\n    function testVerifyProofBasicCaseIsValid() public {\n        testVerifyProofBasicCase(false, false, false, 0x00);\n    }\n\n    function testVerifyProofBasicCaseIsInvalid() public {\n        testVerifyProofBasicCase(false, false, true, 0x00);\n    }\n\n    function testVerifyMultiProofMalicious() public {\n        bytes32[] memory realLeaves = new bytes32[](2);\n        realLeaves[0] = bytes32(\"real leaf\");\n        realLeaves[1] = bytes32(0);\n        bytes32 root = _hashPair(realLeaves[0], realLeaves[1]);\n\n        bytes32[] memory maliciousLeaves = new bytes32[](2);\n        maliciousLeaves[0] = bytes32(\"malicious\");\n        maliciousLeaves[1] = bytes32(\"leaves\");\n        bytes32[] memory maliciousProof = new bytes32[](2);\n        maliciousProof[0] = realLeaves[0];\n        maliciousProof[1] = realLeaves[0];\n        bool[] memory maliciousFlags = new bool[](3);\n        maliciousFlags[0] = true;\n        maliciousFlags[1] = true;\n        maliciousFlags[2] = false;\n\n        assertFalse(this.verifyMultiProof(maliciousProof, root, maliciousLeaves, maliciousFlags));\n    }\n\n    function testVerifyProofBasicCase(\n        bool damageProof,\n        bool damageRoot,\n        bool damageLeaf,\n        bytes32 randomness\n    ) public {\n        bool noDamage = true;\n        uint256 ri; // Randomness index.\n\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = bytes32(\"b\");\n        proof[1] = _hashPair(bytes32(\"c\"), bytes32(0));\n        if (damageProof) {\n            noDamage = false;\n            uint256 i = uint256(uint8(randomness[ri++])) % proof.length;\n            proof[i] = bytes32(uint256(proof[i]) ^ 1); // Flip a bit.\n        }\n\n        bytes32 root =\n            _hashPair(_hashPair(bytes32(\"a\"), bytes32(\"b\")), _hashPair(bytes32(\"c\"), bytes32(0)));\n\n        if (damageRoot) {\n            noDamage = false;\n            root = bytes32(uint256(root) ^ 1); // Flip a bit.\n        }\n\n        bytes32 leaf = bytes32(\"a\");\n        if (damageLeaf) {\n            noDamage = false;\n            leaf = bytes32(uint256(leaf) ^ 1); // Flip a bit.\n        }\n\n        assertEq(this.verify(proof, root, leaf), noDamage);\n    }\n\n    function testVerifyMultiProofForSingleLeaf(bytes32[] memory data, uint256 randomness)\n        public\n        brutalizeMemory\n    {\n        vm.assume(data.length > 1);\n        uint256 nodeIndex = randomness % data.length;\n        bytes32 root = _getRoot(data);\n        bytes32[] memory proof = _getProof(data, nodeIndex);\n        bytes32[] memory leaves = new bytes32[](1);\n        leaves[0] = data[nodeIndex];\n        bool[] memory flags = new bool[](proof.length);\n\n        assertTrue(this.verifyMultiProof(proof, root, leaves, flags));\n\n        // Checks verify with corrupted root returns false.\n        assertFalse(this.verifyMultiProof(proof, bytes32(uint256(root) ^ 1), leaves, flags));\n\n        // Checks verify with corrupted proof returns false.\n        proof[0] = bytes32(uint256(proof[0]) ^ 1);\n        assertFalse(this.verifyMultiProof(proof, root, leaves, flags));\n\n        // Checks verify with corrupted root and proof returns false.\n        assertFalse(this.verifyMultiProof(proof, bytes32(uint256(root) ^ 1), leaves, flags));\n    }\n\n    function testVerifyMultiProofForHeightOneTree(\n        bool hasProof,\n        bool nonEmptyProof,\n        bool nonEmptyRoot,\n        bool hasLeaf,\n        bool nonEmptyLeaf,\n        bool[] memory flags\n    ) public {\n        bytes32 root;\n        if (nonEmptyRoot) {\n            root = bytes32(\"a\");\n        }\n        bytes32[] memory proof;\n        if (hasProof) {\n            proof = new bytes32[](1);\n            proof[0] = nonEmptyProof ? bytes32(\"a\") : bytes32(0);\n        }\n        bytes32[] memory leaves;\n        if (hasLeaf) {\n            leaves = new bytes32[](1);\n            leaves[0] = nonEmptyLeaf ? bytes32(\"a\") : bytes32(0);\n        }\n        bool leafSameAsRoot = leaves.length == 1 && leaves[0] == root;\n        bool proofSameAsRoot = proof.length == 1 && proof[0] == root;\n        bool isValid = flags.length == 0 && (leafSameAsRoot || proofSameAsRoot)\n            && (leaves.length + proof.length == 1);\n        assertEq(this.verifyMultiProof(proof, root, leaves, flags), isValid);\n    }\n\n    function testVerifyMultiProofForHeightTwoTree(\n        bool allLeaves,\n        bool damageRoot,\n        bool damageLeaves,\n        bool damageProof,\n        bool damageFlags,\n        bytes32 randomness\n    ) public {\n        bool noDamage = true;\n        uint256 ri; // Randomness index.\n\n        bytes32 root = _hashPair(bytes32(\"a\"), bytes32(\"b\"));\n\n        bytes32[] memory proof;\n        bytes32[] memory leaves;\n        bool[] memory flags = new bool[](1);\n        flags[0] = allLeaves;\n\n        if (allLeaves) {\n            leaves = new bytes32[](2);\n            leaves[0] = bytes32(\"a\");\n            leaves[1] = bytes32(\"b\");\n        } else {\n            leaves = new bytes32[](1);\n            leaves[0] = bytes32(\"a\");\n            proof = new bytes32[](1);\n            proof[0] = bytes32(\"b\");\n        }\n\n        if (damageRoot) {\n            noDamage = false;\n            root = bytes32(uint256(root) ^ 1); // Flip a bit.\n        }\n\n        if (damageFlags) {\n            noDamage = false;\n            flags[0] = !flags[0]; // Flip a bool.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete flags;\n        }\n\n        if (damageLeaves) {\n            noDamage = false;\n            uint256 i = uint256(uint8(randomness[ri++])) % leaves.length;\n            leaves[i] = bytes32(uint256(leaves[i]) ^ 1); // Flip a bit.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete leaves;\n        }\n\n        if (damageProof && proof.length != 0) {\n            noDamage = false;\n            proof[0] = bytes32(uint256(proof[0]) ^ 1); // Flip a bit.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete proof;\n        }\n\n        assertEq(this.verifyMultiProof(proof, root, leaves, flags), noDamage);\n    }\n\n    function testVerifyMultiProofIsValid() public {\n        testVerifyMultiProof(false, false, false, false, 0x00);\n    }\n\n    function testVerifyMultiProofIsInvalid() public {\n        testVerifyMultiProof(false, false, true, false, 0x00);\n    }\n\n    function testVerifyMultiProof(\n        bool damageRoot,\n        bool damageLeaves,\n        bool damageProof,\n        bool damageFlags,\n        bytes32 randomness\n    ) public brutalizeMemory {\n        bool noDamage = true;\n        uint256 ri; // Randomness index.\n\n        bytes32 root = _hashPair(\n            _hashPair(_hashPair(bytes32(\"a\"), bytes32(\"b\")), _hashPair(bytes32(\"c\"), bytes32(\"d\"))),\n            _hashPair(bytes32(\"e\"), bytes32(\"f\"))\n        );\n\n        bytes32[] memory leaves = new bytes32[](3);\n        leaves[0] = bytes32(\"d\");\n        leaves[1] = bytes32(\"e\");\n        leaves[2] = bytes32(\"f\");\n\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = bytes32(\"c\");\n        proof[1] = _hashPair(bytes32(\"b\"), bytes32(\"a\"));\n\n        bool[] memory flags = new bool[](4);\n        flags[0] = false;\n        flags[1] = true;\n        flags[2] = false;\n        flags[3] = true;\n\n        if (damageRoot) {\n            noDamage = false;\n            root = bytes32(uint256(root) ^ 1); // Flip a bit.\n        }\n\n        if (damageLeaves) {\n            noDamage = false;\n            uint256 i = uint256(uint8(randomness[ri++])) % leaves.length;\n            leaves[i] = bytes32(uint256(leaves[i]) ^ 1); // Flip a bit.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete leaves;\n        }\n\n        if (damageProof) {\n            noDamage = false;\n            uint256 i = uint256(uint8(randomness[ri++])) % proof.length;\n            proof[i] = bytes32(uint256(proof[i]) ^ 1); // Flip a bit.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete proof;\n        }\n\n        if (damageFlags) {\n            noDamage = false;\n            uint256 i = uint256(uint8(randomness[ri++])) % flags.length;\n            flags[i] = !flags[i]; // Flip a bool.\n            if (uint256(uint8(randomness[ri++])) & 1 == 0) delete flags;\n        }\n\n        assertEq(this.verifyMultiProof(proof, root, leaves, flags), noDamage);\n    }\n\n    function verify(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        external\n        returns (bool result)\n    {\n        result = MerkleProofLib.verifyCalldata(proof, root, leaf);\n        assertEq(MerkleProofLib.verify(proof, root, leaf), result);\n    }\n\n    function verifyMultiProof(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) external returns (bool result) {\n        uint256[] memory offsetsAndLengths = new uint256[](12);\n\n        // Basically, we want to demonstrate that the `verifyMultiProof` does not\n        // change the offsets and lengths.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(offsetsAndLengths, shl(5, add(1, 0))), proof.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 1))), leaves.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 2))), flags.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 3))), proof.length)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 4))), leaves.length)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 5))), flags.length)\n        }\n\n        result = MerkleProofLib.verifyMultiProofCalldata(proof, root, leaves, flags);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(offsetsAndLengths, shl(5, add(1, 6))), proof.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 7))), leaves.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 8))), flags.offset)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 9))), proof.length)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 10))), leaves.length)\n            mstore(add(offsetsAndLengths, shl(5, add(1, 11))), flags.length)\n        }\n\n        assertEq(offsetsAndLengths[0], offsetsAndLengths[6]);\n        assertEq(offsetsAndLengths[1], offsetsAndLengths[7]);\n        assertEq(offsetsAndLengths[2], offsetsAndLengths[8]);\n        assertEq(offsetsAndLengths[3], offsetsAndLengths[9]);\n        assertEq(offsetsAndLengths[4], offsetsAndLengths[10]);\n        assertEq(offsetsAndLengths[5], offsetsAndLengths[11]);\n\n        assertEq(MerkleProofLib.verifyMultiProof(proof, root, leaves, flags), result);\n    }\n\n    // Following code is adapted from https://github.com/dmfxyz/murky/blob/main/src/common/MurkyBase.sol.\n\n    function _getRoot(bytes32[] memory data) private pure returns (bytes32) {\n        require(data.length > 1);\n        while (data.length > 1) {\n            data = _hashLevel(data);\n        }\n        return data[0];\n    }\n\n    function _getProof(bytes32[] memory data, uint256 nodeIndex)\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        require(data.length > 1);\n\n        bytes32[] memory result = new bytes32[](64);\n        uint256 pos;\n\n        while (data.length > 1) {\n            unchecked {\n                if (nodeIndex & 0x1 == 1) {\n                    result[pos] = data[nodeIndex - 1];\n                } else if (nodeIndex + 1 == data.length) {\n                    result[pos] = bytes32(0);\n                } else {\n                    result[pos] = data[nodeIndex + 1];\n                }\n                ++pos;\n                nodeIndex /= 2;\n            }\n            data = _hashLevel(data);\n        }\n        // Resize the length of the array to fit.\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, pos)\n        }\n\n        return result;\n    }\n\n    function _hashLevel(bytes32[] memory data) private pure returns (bytes32[] memory) {\n        bytes32[] memory result;\n        unchecked {\n            uint256 length = data.length;\n            if (length & 0x1 == 1) {\n                result = new bytes32[](length / 2 + 1);\n                result[result.length - 1] = _hashPair(data[length - 1], bytes32(0));\n            } else {\n                result = new bytes32[](length / 2);\n            }\n            uint256 pos = 0;\n            for (uint256 i = 0; i < length - 1; i += 2) {\n                result[pos] = _hashPair(data[i], data[i + 1]);\n                ++pos;\n            }\n        }\n        return result;\n    }\n\n    function _hashPair(bytes32 left, bytes32 right) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch lt(left, right)\n            case 0 {\n                mstore(0x0, right)\n                mstore(0x20, left)\n            }\n            default {\n                mstore(0x0, left)\n                mstore(0x20, right)\n            }\n            result := keccak256(0x0, 0x40)\n        }\n    }\n\n    function testEmptyCalldataHelpers() public {\n        assertFalse(\n            MerkleProofLib.verifyMultiProofCalldata(\n                MerkleProofLib.emptyProof(),\n                bytes32(0),\n                MerkleProofLib.emptyLeaves(),\n                MerkleProofLib.emptyFlags()\n            )\n        );\n\n        assertFalse(\n            MerkleProofLib.verifyMultiProof(\n                MerkleProofLib.emptyProof(),\n                bytes32(0),\n                MerkleProofLib.emptyLeaves(),\n                MerkleProofLib.emptyFlags()\n            )\n        );\n    }\n}\n",
        "contractname": "MerkleProofLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, s) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {SignatureCheckerLib} from \"../src/utils/SignatureCheckerLib.sol\";\nimport {ECDSA} from \"../src/utils/ECDSA.sol\";\nimport {MockERC1271Wallet} from \"./utils/mocks/MockERC1271Wallet.sol\";\nimport {MockERC1271Malicious} from \"./utils/mocks/MockERC1271Malicious.sol\";\n\ncontract SignatureCheckerLibTest is SoladyTest {\n    bytes32 constant TEST_MESSAGE =\n        0x7dbaf558b0a1a5dc7a67202117ab143c1d8605a983e4a743bc06fcc03162dc0d;\n\n    bytes32 constant WRONG_MESSAGE =\n        0x2d0828dd7c97cff316356da3c16c68ba2316886a0e05ebafb8291939310d51a3;\n\n    address constant SIGNER = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;\n\n    address constant OTHER = address(uint160(1));\n\n    bytes32 constant TEST_SIGNED_MESSAGE_HASH =\n        0x7d768af957ef8cbf6219a37e743d5546d911dae3e46449d8a5810522db2ef65e;\n\n    bytes32 constant WRONG_SIGNED_MESSAGE_HASH =\n        0x8cd3e659093d21364c6330514aff328218aa29c2693c5b0e96602df075561952;\n\n    bytes constant SIGNATURE =\n        hex\"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n\n    bytes constant INVALID_SIGNATURE =\n        hex\"7688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n\n    MockERC1271Wallet mockERC1271Wallet;\n\n    MockERC1271Malicious mockERC1271Malicious;\n\n    function setUp() public {\n        mockERC1271Wallet = new MockERC1271Wallet(SIGNER);\n        mockERC1271Malicious = new MockERC1271Malicious();\n    }\n\n    function testSignatureCheckerOnEOAWithMatchingSignerAndSignature() public {\n        _checkSignature(SIGNER, TEST_SIGNED_MESSAGE_HASH, SIGNATURE, true);\n    }\n\n    function testSignatureCheckerOnEOAWithInvalidSigner() public {\n        _checkSignature(OTHER, TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);\n    }\n\n    function testSignatureCheckerOnEOAWithWrongSignedMessageHash() public {\n        _checkSignature(SIGNER, WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false);\n    }\n\n    function testSignatureCheckerOnEOAWithInvalidSignature() public {\n        _checkSignature(SIGNER, TEST_SIGNED_MESSAGE_HASH, INVALID_SIGNATURE, false);\n    }\n\n    function testSignatureCheckerOnWalletWithMatchingSignerAndSignature() public {\n        _checkSignatureBothModes(\n            address(mockERC1271Wallet), TEST_SIGNED_MESSAGE_HASH, SIGNATURE, true\n        );\n    }\n\n    function testSignatureCheckerOnWalletWithInvalidSigner() public {\n        _checkSignatureBothModes(address(this), TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);\n    }\n\n    function testSignatureCheckerOnWalletWithZeroAddressSigner() public {\n        _checkSignatureBothModes(address(0), TEST_SIGNED_MESSAGE_HASH, SIGNATURE, false);\n    }\n\n    function testSignatureCheckerOnWalletWithWrongSignedMessageHash() public {\n        _checkSignatureBothModes(\n            address(mockERC1271Wallet), WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false\n        );\n    }\n\n    function testSignatureCheckerOnWalletWithInvalidSignature() public {\n        _checkSignatureBothModes(\n            address(mockERC1271Wallet), TEST_SIGNED_MESSAGE_HASH, INVALID_SIGNATURE, false\n        );\n    }\n\n    function testSignatureCheckerOnMaliciousWallet() public {\n        _checkSignatureBothModes(\n            address(mockERC1271Malicious), WRONG_SIGNED_MESSAGE_HASH, SIGNATURE, false\n        );\n    }\n\n    function testSignatureChecker(bytes32 digest) public {\n        (address signer, uint256 privateKey) = _randomSigner();\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);\n        _checkSignature(signer, digest, abi.encodePacked(r, s, v), true);\n\n        if (_random() % 8 == 0) {\n            assertEq(\n                this.isValidSignatureNowCalldata(signer, digest, abi.encodePacked(r, s, v)), true\n            );\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encodePacked(r, s, v)),\n                true\n            );\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(\n                    signer, digest, abi.encodePacked(r, s, v + 1)\n                ),\n                false\n            );\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(\n                    signer, digest, abi.encodePacked(r, s, v - 1)\n                ),\n                false\n            );\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, v, r, s), true);\n        }\n\n        if (_random() % 8 == 0) {\n            bytes32 vs;\n            /// @solidity memory-safe-assembly\n            assembly {\n                vs := or(shl(255, sub(v, 27)), s)\n            }\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, r, vs), true);\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encode(r, vs)), true\n            );\n            assertEq(this.isValidSignatureNowCalldata(signer, digest, abi.encode(r, vs)), true);\n        }\n\n        if (_random() % 8 == 0) {\n            bytes32 vsc; // Corrupted `vs`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                vsc := or(shl(255, xor(1, sub(v, 27))), s)\n            }\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, r, vsc), false);\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encode(r, vsc)), false\n            );\n            assertEq(this.isValidSignatureNowCalldata(signer, digest, abi.encode(r, vsc)), false);\n        }\n\n        if (_random() % 8 == 0 && r != bytes32(0) && s != bytes32(0)) {\n            bytes32 rc = bytes32(uint256(r) - (_random() & 1)); // Corrupted `r`.\n            bytes32 sc = bytes32(uint256(s) - (_random() & 1)); // Corrupted `s`.\n            bool anyCorrupted = rc != r || sc != s;\n            _checkSignature(signer, digest, abi.encodePacked(rc, sc, v), !anyCorrupted);\n        }\n\n        if (_random() % 8 == 0) {\n            uint8 vc = uint8(_random()); // Corrupted `v`.\n            while (vc == 28 || vc == 27) vc = uint8(_random());\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, digest, vc, r, s), false);\n            assertEq(\n                SignatureCheckerLib.isValidSignatureNow(signer, digest, abi.encodePacked(r, s, vc)),\n                false\n            );\n            assertEq(\n                this.isValidSignatureNowCalldata(signer, digest, abi.encodePacked(r, s, vc)), false\n            );\n        }\n    }\n\n    function _checkSignatureBothModes(\n        address signer,\n        bytes32 hash,\n        bytes memory signature,\n        bool expectedResult\n    ) internal {\n        _checkSignature(false, signer, hash, signature, expectedResult);\n        _checkSignature(true, signer, hash, signature, expectedResult);\n    }\n\n    function _checkSignature(\n        address signer,\n        bytes32 hash,\n        bytes memory signature,\n        bool expectedResult\n    ) internal {\n        _checkSignature(false, signer, hash, signature, expectedResult);\n    }\n\n    function _checkSignature(\n        bool onlyERC1271,\n        address signer,\n        bytes32 hash,\n        bytes memory signature,\n        bool expectedResult\n    ) internal {\n        bool callResult;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n\n            // `bytes4(keccak256(\"isValidSignatureNow(address,bytes32,bytes)\"))`.\n            mstore(m, shl(224, 0x6ccea652))\n            if onlyERC1271 {\n                // `bytes4(keccak256(\"isValidERC1271SignatureNow(address,bytes32,bytes)\"))`.\n                mstore(m, shl(224, 0x3ae5d83c))\n            }\n            mstore(add(m, 0x04), signer)\n            mstore(add(m, 0x24), hash)\n            mstore(add(m, 0x44), 0x60) // Offset of signature in calldata.\n            mstore(add(m, 0x64), mload(signature))\n            mstore(add(m, 0x84), mload(add(signature, 0x20)))\n            mstore(add(m, 0xa4), mload(add(signature, 0x40)))\n            mstore(add(m, 0xc4), mload(add(signature, 0x60)))\n            // Brutalize the bytes following the 8-bit `v`. All ones will do.\n            mstore(add(m, 0xc5), not(0))\n\n            // We have to do the call in assembly to ensure that Solidity does not\n            // clean up the brutalized bits.\n            callResult :=\n                and(\n                    and(\n                        // Whether the returndata is equal to 1.\n                        eq(mload(0x00), 1),\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long .\n                        eq(returndatasize(), 0x20)\n                    ),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        address(), // The current contract's address.\n                        m, // Offset of calldata in memory.\n                        0xe4, // Length of calldata in memory.\n                        0x00, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n        }\n        assertEq(callResult, expectedResult);\n\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        bytes32 vs;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Contaminate the upper 96 bits.\n            signer := or(shl(160, 1), signer)\n            // Extract `r`, `s`, `v`.\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n            // Pack `vs`.\n            vs := or(shl(255, sub(v, 27)), s)\n\n            // Brutalize the memory. Just all ones will do.\n            let m := mload(0x40)\n            for { let i := 0 } lt(i, 30) { i := add(i, 1) } { mstore(add(m, shl(5, i)), not(0)) }\n        }\n\n        if (onlyERC1271) {\n            assertEq(\n                SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, r, vs), expectedResult\n            );\n            assertEq(\n                SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, v, r, s),\n                expectedResult\n            );\n        } else {\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, r, vs), expectedResult);\n            assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, v, r, s), expectedResult);\n        }\n    }\n\n    function isValidSignatureNow(address signer, bytes32 hash, bytes calldata signature)\n        external\n        returns (bool result)\n    {\n        bool signatureIsBrutalized;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Contaminate the upper 96 bits.\n            signer := or(shl(160, 1), signer)\n            // Ensure that the bytes right after the signature is brutalized.\n            signatureIsBrutalized := calldataload(add(signature.offset, signature.length))\n        }\n        if (!signatureIsBrutalized) revert(\"Signature is not brutalized.\");\n\n        result = SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature);\n        assertEq(SignatureCheckerLib.isValidSignatureNow(signer, hash, signature), result);\n    }\n\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes calldata signature)\n        external\n        returns (bool result)\n    {\n        bool signatureIsBrutalized;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Contaminate the upper 96 bits.\n            signer := or(shl(160, 1), signer)\n            // Ensure that the bytes right after the signature is brutalized.\n            signatureIsBrutalized := calldataload(add(signature.offset, signature.length))\n        }\n        if (!signatureIsBrutalized) revert(\"Signature is not brutalized.\");\n\n        result = SignatureCheckerLib.isValidERC1271SignatureNowCalldata(signer, hash, signature);\n        assertEq(SignatureCheckerLib.isValidERC1271SignatureNow(signer, hash, signature), result);\n    }\n\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        external\n        view\n        returns (bool result)\n    {\n        result = SignatureCheckerLib.isValidSignatureNowCalldata(signer, hash, signature);\n    }\n\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) external view returns (bool result) {\n        result = SignatureCheckerLib.isValidERC1271SignatureNowCalldata(signer, hash, signature);\n    }\n\n    function testEmptyCalldataHelpers() public {\n        assertFalse(\n            SignatureCheckerLib.isValidSignatureNow(\n                address(1), bytes32(0), SignatureCheckerLib.emptySignature()\n            )\n        );\n    }\n\n    function testToEthSignedMessageHashDifferential(bytes32 hash) public {\n        assertEq(\n            SignatureCheckerLib.toEthSignedMessageHash(hash), ECDSA.toEthSignedMessageHash(hash)\n        );\n    }\n\n    function testToEthSignedMessageHashDifferential(bytes memory s) public {\n        assertEq(SignatureCheckerLib.toEthSignedMessageHash(s), ECDSA.toEthSignedMessageHash(s));\n    }\n}\n",
        "contractname": "SignatureCheckerLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Factory for deploying and managing ERC1967 proxy contracts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ERC1967Factory.sol)\n/// @author jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\ncontract ERC1967Factory {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The proxy deployment failed.\n    error DeploymentFailed();\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The salt does not start with the caller.\n    error SaltDoesNotStartWithCaller();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 internal constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"DeploymentFailed()\")))`.\n    uint256 internal constant _DEPLOYMENT_FAILED_ERROR_SELECTOR = 0x30116425;\n\n    /// @dev `bytes4(keccak256(bytes(\"UpgradeFailed()\")))`.\n    uint256 internal constant _UPGRADE_FAILED_ERROR_SELECTOR = 0x55299b49;\n\n    /// @dev `bytes4(keccak256(bytes(\"SaltDoesNotStartWithCaller()\")))`.\n    uint256 internal constant _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR = 0x2f634836;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The admin of a proxy contract has been changed.\n    event AdminChanged(address indexed proxy, address indexed admin);\n\n    /// @dev The implementation for a proxy has been upgraded.\n    event Upgraded(address indexed proxy, address indexed implementation);\n\n    /// @dev A proxy has been deployed.\n    event Deployed(address indexed proxy, address indexed implementation, address indexed admin);\n\n    /// @dev `keccak256(bytes(\"AdminChanged(address,address)\"))`.\n    uint256 internal constant _ADMIN_CHANGED_EVENT_SIGNATURE =\n        0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f;\n\n    /// @dev `keccak256(bytes(\"Upgraded(address,address)\"))`.\n    uint256 internal constant _UPGRADED_EVENT_SIGNATURE =\n        0x5d611f318680d00598bb735d61bacf0c514c6b50e1e5ad30040a4df2b12791c7;\n\n    /// @dev `keccak256(bytes(\"Deployed(address,address,address)\"))`.\n    uint256 internal constant _DEPLOYED_EVENT_SIGNATURE =\n        0xc95935a66d15e0da5e412aca0ad27ae891d20b2fb91cf3994b6a3bf2b8178082;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // The admin slot for a `proxy` is `shl(96, proxy)`.\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    uint256 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ADMIN FUNCTIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the admin of the proxy.\n    function adminOf(address proxy) public view returns (address admin) {\n        assembly {\n            admin := sload(shl(96, proxy))\n        }\n    }\n\n    /// @dev Sets the admin of the proxy.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function changeAdmin(address proxy, address admin) public {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n            // Emit the {AdminChanged} event.\n            log3(0, 0, _ADMIN_CHANGED_EVENT_SIGNATURE, proxy, admin)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     UPGRADE FUNCTIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Upgrades the proxy to point to `implementation`.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function upgrade(address proxy, address implementation) public payable {\n        upgradeAndCall(proxy, implementation, _emptyData());\n    }\n\n    /// @dev Upgrades the proxy to point to `implementation`.\n    /// Then, calls the proxy with abi encoded `data`.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function upgradeAndCall(address proxy, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set up the calldata to upgrade the proxy.\n            let m := mload(0x40)\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try upgrading the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `UpgradeFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _UPGRADE_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            // Emit the {Upgraded} event.\n            log3(0, 0, _UPGRADED_EVENT_SIGNATURE, proxy, implementation)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      DEPLOY FUNCTIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`,\n    /// and returns its address.\n    /// The value passed into this function will be forwarded to the proxy.\n    function deploy(address implementation, address admin) public payable returns (address proxy) {\n        proxy = deployAndCall(implementation, admin, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`,\n    /// and returns its address.\n    /// The value passed into this function will be forwarded to the proxy.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = _deploy(implementation, admin, bytes32(0), false, data);\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    function deployDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = deployDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address proxy) {\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        proxy = _deploy(implementation, admin, salt, true, data);\n    }\n\n    /// @dev Deploys the proxy, with optionality to deploy deterministically with a `salt`.\n    function _deploy(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address proxy) {\n        bytes32 m = _initCode();\n        assembly {\n            // Create the proxy.\n            switch useSalt\n            case 0 { proxy := create(0, add(m, 0x13), 0x88) }\n            default { proxy := create2(0, add(m, 0x13), 0x88, salt) }\n            // Revert if the creation fails.\n            if iszero(proxy) {\n                mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n\n            // Set up the calldata to set the implementation of the proxy.\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try setting the implementation on the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n\n            // Emit the {Deployed} event.\n            log4(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation, admin)\n        }\n    }\n\n    /// @dev Returns the address of the proxy deployed with `salt`.\n    function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\n        bytes32 hash = initCodeHash();\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            // Note: `predicted` has dirty upper 96 bits. We won't clean it here\n            // as it will be automatically cleaned when it is copied into the returndata.\n            // Please clean as needed if used in other inline assembly blocks.\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the proxy.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash() public view returns (bytes32 result) {\n        bytes32 m = _initCode();\n        assembly {\n            result := keccak256(add(m, 0x13), 0x88)\n        }\n    }\n\n    /// @dev Returns a pointer to the initialization code of a proxy created via this factory.\n    function _initCode() internal view returns (bytes32 m) {\n        assembly {\n            /**\n             * -------------------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                                   |\n             * -------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\n             * 81         | DUP2            | r 0 r               |                                 |\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\n             * -------------------------------------------------------------------------------------|\n             * RUNTIME (127 bytes)                                                                  |\n             * -------------------------------------------------------------------------------------|\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             *                                                                                      |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 33          | CALLER         | c 0 0               |                                 |\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\n             * 14          | EQ             | isf 0 0             |                                 |\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\n             * 57          | JUMPI          | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 54          | SLOAD          | i 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 5a          | GAS            | g i 0 cds 0 0       | [0..calldatasize): calldata     |\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\n             * 60 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\n             * 55          | SSTORE         | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\n             * 11          | GT             | gt 2w 0 0           |                                 |\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\n             * 57          | JUMPI          | 2w 0 0              |                                 |\n             *                                                                                      |\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\n             * 03          | SUB            | t 0 0               |                                 |\n             * 80          | DUP1           | t t 0 0             |                                 |\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\n             * 35          | CALLDATALOAD   | i 0 t 0 0           | [0..t): extra calldata          |\n             * 5a          | GAS            | g i 0 t 0 0         | [0..t): extra calldata          |\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             * -------------------------------------------------------------------------------------+\n             */\n            m := mload(0x40)\n            // forgefmt: disable-start\n            switch shr(112, address())\n            case 0 {\n                // If the factory's address has six or more leading zero bytes.\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x0e), address()) // 14\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\n            }\n            default {\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x14), address()) // 20\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\n            }\n            // forgefmt: disable-end\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          HELPERS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper function to return an empty bytes calldata.\n    function _emptyData() internal pure returns (bytes calldata data) {\n        assembly {\n            data.length := 0\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockImplementation} from \"./utils/mocks/MockImplementation.sol\";\nimport {ERC1967Factory} from \"../src/utils/ERC1967Factory.sol\";\nimport {ERC1967FactoryConstants} from \"../src/utils/ERC1967FactoryConstants.sol\";\n\ncontract ERC1967FactoryTest is SoladyTest {\n    event AdminChanged(address indexed proxy, address indexed admin);\n\n    event Upgraded(address indexed proxy, address indexed implementation);\n\n    event Deployed(address indexed proxy, address indexed implementation, address indexed admin);\n\n    ERC1967Factory factory;\n    address implementation0;\n    address implementation1;\n\n    struct _TestTemps {\n        uint256 key;\n        uint256 value;\n        uint256 msgValue;\n        bytes32 salt;\n        address predictedProxy;\n        address proxy;\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        t.key = _random();\n        t.value = _random();\n        t.msgValue = _bound(_random(), 0, uint256(type(uint96).max));\n        t.salt = bytes32(_random() & uint256(type(uint96).max));\n    }\n\n    function setUp() public {\n        factory = new ERC1967Factory();\n        implementation0 = address(new MockImplementation());\n        implementation1 = address(new MockImplementation());\n    }\n\n    modifier withFactories() {\n        _;\n        {\n            address minedFactoryAddress = 0x0000000000001122334455667788990011223344;\n            vm.etch(minedFactoryAddress, address(factory).code);\n            factory = ERC1967Factory(minedFactoryAddress);\n        }\n        _;\n    }\n\n    function testDeploy() public withFactories {\n        (address admin,) = _randomSigner();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n        _checkProxyBytecode(proxy);\n\n        assertEq(factory.adminOf(proxy), admin);\n        assertTrue(proxy != address(0));\n        assertTrue(proxy.code.length > 0);\n        _checkImplementationSlot(proxy, implementation0);\n    }\n\n    function testDeployBrutalized(uint256) public withFactories {\n        (address admin,) = _randomSigner();\n        address implementation = implementation0;\n        bool brutalized;\n        bool success;\n        address f = address(factory);\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(0x00, 0x00, 0x40)\n            brutalized := eq(and(mload(0x00), 1), 0)\n            if brutalized {\n                // Extremely unlikely that all 96 upper bits will be zero.\n                admin := or(shl(160, keccak256(0x00, 0x20)), admin)\n                implementation := or(shl(160, keccak256(0x00, 0x40)), implementation)\n            }\n            let m := mload(0x40)\n            mstore(m, 0x545e7c61) // `deploy(address, address)`.\n            mstore(add(m, 0x20), implementation)\n            mstore(add(m, 0x40), admin)\n            mstore(0x00, 0)\n            // Basically, we want to demonstrate that Solidity has checks\n            // to reject dirty upper bits for addresses.\n            success := call(gas(), f, 0, add(m, 0x1c), 0x44, 0x00, 0x20)\n            // If the call is successful, there will be a deployment.\n            if and(success, iszero(mload(0x00))) { revert(0, 0) }\n        }\n        assertEq(brutalized, !success);\n    }\n\n    function testDeployAndCall(uint256) public withFactories {\n        (address admin,) = _randomSigner();\n        _TestTemps memory t = _testTemps();\n\n        bytes memory data = abi.encodeWithSignature(\"setValue(uint256,uint256)\", t.key, t.value);\n        vm.deal(admin, type(uint128).max);\n        vm.prank(admin);\n        address proxy = factory.deployAndCall{value: t.msgValue}(implementation0, admin, data);\n\n        assertEq(factory.adminOf(proxy), admin);\n        assertTrue(proxy != address(0));\n        assertTrue(proxy.code.length > 0);\n        _checkImplementationSlot(proxy, implementation0);\n        assertEq(MockImplementation(proxy).getValue(t.key), t.value);\n        assertEq(proxy.balance, t.msgValue);\n    }\n\n    function testDeployDeterministicAndCall(uint256) public withFactories {\n        (address admin,) = _randomSigner();\n        _TestTemps memory t = _testTemps();\n\n        t.predictedProxy = factory.predictDeterministicAddress(t.salt);\n        bytes memory data = abi.encodeWithSignature(\"setValue(uint256,uint256)\", t.key, t.value);\n        vm.deal(admin, type(uint128).max);\n        vm.prank(admin);\n        if (_random() % 8 == 0) {\n            t.salt = keccak256(abi.encode(_random()));\n            vm.expectRevert(ERC1967Factory.SaltDoesNotStartWithCaller.selector);\n            t.proxy = factory.deployDeterministicAndCall{value: t.msgValue}(\n                implementation0, admin, t.salt, data\n            );\n            return;\n        } else {\n            vm.expectEmit(true, true, true, true);\n            emit Deployed(t.predictedProxy, implementation0, admin);\n            t.proxy = factory.deployDeterministicAndCall{value: t.msgValue}(\n                implementation0, admin, t.salt, data\n            );\n            assertEq(t.proxy, t.predictedProxy);\n        }\n\n        assertEq(factory.adminOf(t.proxy), admin);\n        assertTrue(t.proxy != address(0));\n        assertTrue(t.proxy.code.length > 0);\n        _checkImplementationSlot(t.proxy, implementation0);\n        assertEq(MockImplementation(t.proxy).getValue(t.key), t.value);\n        assertEq(t.proxy.balance, t.msgValue);\n    }\n\n    function testDeployAndCallWithRevert() public withFactories {\n        (address admin,) = _randomSigner();\n\n        bytes memory data = abi.encodeWithSignature(\"fails()\");\n        vm.expectRevert(MockImplementation.Fail.selector);\n        factory.deployAndCall(implementation0, admin, data);\n    }\n\n    function testProxySucceeds() public withFactories {\n        (address admin,) = _randomSigner();\n        uint256 a = 1;\n\n        MockImplementation proxy = MockImplementation(factory.deploy(implementation0, admin));\n\n        assertEq(proxy.succeeds(a), a);\n    }\n\n    function testProxyFails() public withFactories {\n        (address admin,) = _randomSigner();\n\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectRevert(MockImplementation.Fail.selector);\n        MockImplementation(proxy).fails();\n    }\n\n    function testChangeAdmin() public withFactories {\n        (address admin, address newAdmin) = _randomAccounts();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectEmit(true, true, true, true, address(factory));\n        emit AdminChanged(proxy, newAdmin);\n\n        vm.prank(admin);\n        factory.changeAdmin(proxy, newAdmin);\n\n        assertEq(factory.adminOf(proxy), newAdmin);\n    }\n\n    function testChangeAdminUnauthorized() public withFactories {\n        (address admin, address sussyAccount) = _randomAccounts();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectRevert(ERC1967Factory.Unauthorized.selector);\n\n        vm.prank(sussyAccount);\n        factory.changeAdmin(proxy, sussyAccount);\n    }\n\n    function testUpgrade() public withFactories {\n        (address admin,) = _randomSigner();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectEmit(true, true, true, true, address(factory));\n        emit Upgraded(proxy, implementation1);\n\n        vm.prank(admin);\n        factory.upgrade(proxy, implementation1);\n\n        _checkImplementationSlot(proxy, implementation1);\n    }\n\n    function testUpgradeAndCall() public withFactories {\n        (address admin,) = _randomSigner();\n        _TestTemps memory t = _testTemps();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectEmit(true, true, true, true, address(factory));\n        emit Upgraded(proxy, implementation1);\n\n        vm.prank(admin);\n        vm.deal(admin, type(uint128).max);\n        bytes memory data = abi.encodeWithSignature(\"setValue(uint256,uint256)\", t.key, t.value);\n        factory.upgradeAndCall{value: t.msgValue}(proxy, implementation1, data);\n\n        _checkImplementationSlot(proxy, implementation1);\n        uint256 gasBefore = gasleft();\n        uint256 storedValue = MockImplementation(proxy).getValue(t.key);\n        unchecked {\n            uint256 gasUsed = gasBefore - gasleft();\n            emit LogUint(\"gasUsed\", gasUsed);\n        }\n        assertEq(storedValue, t.value);\n        assertEq(proxy.balance, t.msgValue);\n    }\n\n    function testUpgradeAndCallWithRevert() public withFactories {\n        (address admin,) = _randomSigner();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.prank(admin);\n        vm.expectRevert(MockImplementation.Fail.selector);\n        factory.upgradeAndCall(proxy, implementation1, abi.encodeWithSignature(\"fails()\"));\n    }\n\n    function testUpgradeUnauthorized() public withFactories {\n        (address admin, address sussyAccount) = _randomAccounts();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectRevert(ERC1967Factory.Unauthorized.selector);\n        vm.prank(sussyAccount);\n        factory.upgrade(proxy, implementation1);\n\n        vm.expectRevert(ERC1967Factory.Unauthorized.selector);\n        vm.prank(address(uint160(admin) ^ 1));\n        factory.upgrade(proxy, implementation1);\n\n        vm.prank(admin);\n        factory.upgrade(proxy, implementation1);\n    }\n\n    function testUpgradeWithCorruptedProxy() public withFactories {\n        (address admin,) = _randomSigner();\n\n        vm.prank(admin);\n        address proxy = factory.deploy(implementation0, admin);\n\n        vm.expectRevert(ERC1967Factory.Unauthorized.selector);\n        vm.prank(admin);\n        factory.upgrade(address(uint160(proxy) ^ 1), implementation1);\n\n        _checkImplementationSlot(proxy, implementation0);\n    }\n\n    function testFactoryDeployment() public {\n        address deployment =\n            _safeCreate2(ERC1967FactoryConstants.SALT, ERC1967FactoryConstants.INITCODE);\n        assertEq(deployment, ERC1967FactoryConstants.ADDRESS);\n        assertEq(deployment.code, ERC1967FactoryConstants.BYTECODE);\n    }\n\n    function _randomAccounts() internal returns (address a, address b) {\n        (a,) = _randomSigner();\n        do {\n            (b,) = _randomSigner();\n        } while (a == b);\n    }\n\n    function _checkImplementationSlot(address proxy, address implementation) internal {\n        bytes32 slot = bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n        assertEq(vm.load(proxy, slot), bytes32(uint256(uint160(implementation))));\n    }\n\n    function _checkProxyBytecode(address proxy) internal {\n        bytes memory code = address(proxy).code;\n        assertEq(uint8(bytes1(code[code.length - 1])), 0xfd);\n        assertTrue(code.length == 127 || code.length == 121);\n    }\n}\n",
        "contractname": "ERC1967Factory.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for reading contract metadata robustly.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\nlibrary MetadataReaderLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Default gas stipend for contract reads. High enough for most practical use cases\n    /// (able to SLOAD about 1000 bytes of data), but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev Default string byte length limit.\n    uint256 internal constant STRING_LIMIT_DEFAULT = 1000;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                METADATA READING OPERATIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Best-effort string reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Returns the empty string for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns empty string.\n    // 2. Attempts to `abi.decode` the returndata into a string.\n    // 3. With any remaining gas, scans the returndata from start to end for the\n    //    null byte '\\0', to interpret the returndata as a null-terminated string.\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"))`.\n    function readName(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit)`.\n    function readName(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit, gasStipend)`.\n    function readName(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"))`.\n    function readSymbol(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit)`.\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit, gasStipend)`.\n    function readSymbol(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `STRING_LIMIT_DEFAULT` (1000) bytes.\n    function readString(address target, bytes memory data) internal view returns (string memory) {\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, gasStipend);\n    }\n\n    // Best-effort unsigned integer reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Attempts to `abi.decode` the result into a uint256\n    //    (equivalent across all Solidity uint types, downcast as needed).\n    // 2. Returns zero for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns zero.\n    //     - `abi.decode` failure.\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimal()\")))`.\n    function readDecimals(address target) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\n    }\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimal()\"), gasStipend))`.\n    function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data, uint256 gasStipend)\n        internal\n        view\n        returns (uint256)\n    {\n        return _uint(target, _ptr(data), gasStipend);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Attempts to read and return a string at `target`.\n    function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }\n\n    /// @dev Attempts to read and return a uint at `target`.\n    function _uint(address target, bytes32 ptr, uint256 gasStipend)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Casts the function selector `s` into a pointer.\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }\n\n    /// @dev Casts the `data` into a pointer.\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MetadataReaderLib} from \"../src/utils/MetadataReaderLib.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract MetadataReaderLibTest is SoladyTest {\n    string internal _stringToReturn;\n\n    uint256 internal _randomness;\n\n    function returnsString() public view returns (string memory) {\n        uint256 r = _randomness;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, add(0x100, mload(0x40)))\n            mstore(0x00, r)\n        }\n        string memory s = _stringToReturn;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(r, 1)) {\n                if iszero(and(r, 2)) {\n                    mstore(sub(s, 0x40), 0x40)\n                    return(sub(s, 0x40), add(0x60, add(mload(s), byte(2, r))))\n                }\n                mstore(sub(s, 0x20), 0x20)\n                return(sub(s, 0x20), add(0x40, add(mload(s), byte(2, r))))\n            }\n            mstore(0x00, gas())\n            mstore(0x20, r)\n            mstore(add(mload(s), add(s, 0x20)), shr(8, keccak256(0x00, 0x40)))\n            return(add(s, 0x20), add(mload(s), byte(2, r)))\n        }\n    }\n\n    function returnsEmptyString() public view returns (string memory) {\n        uint256 r = _randomness;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, add(0x100, mload(0x40)))\n            mstore(0x00, r)\n        }\n        string memory s = _stringToReturn;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(r, 1)) {\n                if iszero(and(r, 2)) {\n                    mstore(sub(s, 0x40), 0x41)\n                    return(sub(s, 0x40), add(0x60, mload(s)))\n                }\n                mstore(sub(s, 0x20), 0x21)\n                return(sub(s, 0x20), add(0x40, mload(s)))\n            }\n            if iszero(and(r, 2)) {\n                let n := mload(s)\n                mstore(s, add(n, 1))\n                if iszero(and(r, 2)) {\n                    mstore(sub(s, 0x40), 0x40)\n                    return(sub(s, 0x40), add(0x60, n))\n                }\n                mstore(sub(s, 0x20), 0x20)\n                return(sub(s, 0x20), add(0x40, n))\n            }\n            let m := mload(0x40)\n            codecopy(m, codesize(), 0x200)\n            mstore(m, and(63, byte(3, r)))\n            return(m, and(63, byte(2, r)))\n        }\n    }\n\n    function returnsChoppedString(uint256 chop) public pure returns (string memory) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x00), 0x20)\n            mstore(add(m, 0x20), 0x20)\n            mstore(add(m, 0x40), \"112233445566778899aa112233445566\")\n            return(add(m, 0x00), add(0x40, chop))\n        }\n    }\n\n    function returnsBytes32StringA() public pure returns (bytes32) {\n        return bytes32(hex\"4d696c616479\");\n    }\n\n    function returnsBytes32StringB() public pure returns (bytes32) {\n        return bytes32(\"This string has thirty two bytes\");\n    }\n\n    function returnsNothing() public pure {}\n\n    function reverts() public pure {\n        revert(\"Lorem Ipsum\");\n    }\n\n    function returnsChoppedUint(uint256 v, uint256 chop) public pure returns (uint256) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v)\n            return(0x00, chop)\n        }\n    }\n\n    function name() public view returns (string memory) {\n        return returnsString();\n    }\n\n    function symbol() public view returns (string memory) {\n        return returnsString();\n    }\n\n    function returnsUint() public view returns (uint256) {\n        return _randomness;\n    }\n\n    function decimals() public view returns (uint8) {\n        return uint8(_randomness);\n    }\n\n    function testReadBytes32String() public brutalizeMemory {\n        string memory result;\n        result = _readString(abi.encodeWithSignature(\"returnsBytes32StringA()\"));\n        _checkMemory(result);\n        assertEq(result, \"Milady\");\n        result = _readString(abi.encodeWithSignature(\"returnsBytes32StringB()\"));\n        _checkMemory(result);\n        assertEq(result, \"This string has thirty two bytes\");\n        result = _readString(abi.encodeWithSignature(\"returnsNothing()\"));\n        _checkMemory(result);\n        assertEq(result, \"\");\n        result = _readString(abi.encodeWithSignature(\"reverts()\"));\n        _checkMemory(result);\n        assertEq(result, \"\");\n    }\n\n    function testReadBytes32StringTruncated() public brutalizeMemory {\n        bytes memory data;\n        string memory result;\n        unchecked {\n            data = abi.encodeWithSignature(\"returnsBytes32StringB()\");\n            for (uint256 limit; limit < 39; ++limit) {\n                result = _readString(data, limit);\n                _checkMemory(result);\n                assertEq(result, LibString.slice(\"This string has thirty two bytes\", 0, limit));\n            }\n        }\n    }\n\n    function testReadStringChopped() public {\n        bytes memory data;\n        string memory result;\n        data = abi.encodeWithSignature(\"returnsChoppedString(uint256)\", uint256(32));\n        result = _readString(data);\n        _checkMemory(result);\n        assertEq(result, \"112233445566778899aa112233445566\");\n\n        for (uint256 limit; limit < 39; limit += 5) {\n            for (uint256 chop; chop < 39; chop += 3) {\n                data = abi.encodeWithSignature(\"returnsChoppedString(uint256)\", uint256(chop));\n                result = _readString(data, limit);\n                _checkMemory(result);\n                // As long as the returndatasize is insufficient, the `abi.decode` will fail,\n                // and the resultant string will be empty.\n                // Even if the `limit` is smaller than `chop`.\n                string memory expected;\n                if (chop >= 32) {\n                    expected = LibString.slice(\"112233445566778899aa112233445566\", 0, limit);\n                }\n                assertEq(result, expected);\n            }\n        }\n    }\n\n    function _readString(bytes memory data, uint256 limit) internal returns (string memory) {\n        uint256 r = _random() % 2;\n        if (r == 0) return MetadataReaderLib.readString(address(this), data, limit, gasleft());\n        return MetadataReaderLib.readString(address(this), data, limit);\n    }\n\n    function _readString(bytes memory data) internal returns (string memory) {\n        uint256 r = _random() % 3;\n        if (r == 0) {\n            return MetadataReaderLib.readString(address(this), data, type(uint256).max, gasleft());\n        }\n        if (r == 1) return MetadataReaderLib.readString(address(this), data, type(uint256).max);\n        return MetadataReaderLib.readString(address(this), data);\n    }\n\n    function _readSymbol() internal returns (string memory) {\n        uint256 r = _random() % 3;\n        if (r == 0) {\n            return MetadataReaderLib.readSymbol(address(this), type(uint256).max, gasleft());\n        }\n        if (r == 1) return MetadataReaderLib.readSymbol(address(this), type(uint256).max);\n        return MetadataReaderLib.readSymbol(address(this));\n    }\n\n    function _readName() internal returns (string memory) {\n        uint256 r = _random() % 3;\n        if (r == 0) return MetadataReaderLib.readName(address(this), type(uint256).max, gasleft());\n        if (r == 1) return MetadataReaderLib.readName(address(this), type(uint256).max);\n        return MetadataReaderLib.readName(address(this));\n    }\n\n    function _readUint(bytes memory data) internal returns (uint256) {\n        uint256 r = _random() % 2;\n        if (r == 0) return MetadataReaderLib.readUint(address(this), data, gasleft());\n        return MetadataReaderLib.readUint(address(this), data);\n    }\n\n    function _readDecimals() internal returns (uint256) {\n        uint256 r = _random() % 2;\n        if (r == 0) return MetadataReaderLib.readDecimals(address(this), gasleft());\n        return MetadataReaderLib.readDecimals(address(this));\n    }\n\n    function testReadString(uint256 r) public brutalizeMemory {\n        string memory result;\n        string memory s = _generateString();\n        _stringToReturn = s;\n        _randomness = r;\n        result = _readString(abi.encodeWithSignature(\"returnsString()\"));\n        _checkMemory(result);\n        assertEq(result, s);\n        result = _readName();\n        _checkMemory(result);\n        assertEq(result, s);\n        result = _readSymbol();\n        _checkMemory(result);\n        assertEq(result, s);\n        result = _readString(abi.encodeWithSignature(\"returnsEmptyString()\"));\n        _checkMemory(result);\n        assertEq(result, \"\");\n        result = _readString(abi.encodeWithSignature(\"reverts()\"));\n        _checkMemory(result);\n        assertEq(result, \"\");\n        result = _readString(abi.encodeWithSignature(\"returnsNothing()\"));\n        _checkMemory(result);\n        assertEq(result, \"\");\n    }\n\n    function testReadStringTruncated(uint256 r) public brutalizeMemory {\n        bytes memory data;\n        string memory result;\n        string memory s = _generateString();\n        _stringToReturn = s;\n        _randomness = r;\n        unchecked {\n            uint256 limit = _bound(_random(), 0, bytes(s).length * 2);\n            data = abi.encodeWithSignature(\"returnsString()\");\n            result = MetadataReaderLib.readString(address(this), data, limit);\n            _checkMemory(result);\n            assertEq(result, LibString.slice(s, 0, limit));\n        }\n    }\n\n    function testReadUint(uint256 r) public {\n        _randomness = r;\n        bytes memory data = abi.encodeWithSignature(\"returnsUint()\");\n        assertEq(_readUint(data), r);\n        assertEq(_readDecimals(), uint8(r));\n    }\n\n    function testReadUint() public {\n        bytes memory data;\n        uint256 result;\n        data = abi.encodeWithSignature(\"returnsNothing()\");\n        result = _readUint(data);\n        assertEq(result, 0);\n        data = abi.encodeWithSignature(\"reverts()\");\n        result = _readUint(data);\n        assertEq(result, 0);\n\n        for (uint256 j; j != 8; ++j) {\n            for (uint256 i; i != 70; ++i) {\n                uint256 k = _hash(i, j);\n                data = abi.encodeWithSignature(\"returnsChoppedUint(uint256,uint256)\", k, i);\n                result = _readUint(data);\n                assertEq(result, i < 32 ? 0 : k);\n            }\n        }\n    }\n\n    function testBoundsCheckDifferential(uint256) public {\n        uint256 rds = _bound(_random(), 0, 128);\n        uint256 l = _random() % 2 == 0 ? type(uint248).max : 128;\n        uint256 o = _bound(_random(), 0, l);\n        uint256 n = _bound(_random(), 0, l);\n        bool result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(rds, 0x40)) {\n                if iszero(gt(o, sub(rds, 0x20))) {\n                    if iszero(gt(n, sub(rds, add(o, 0x20)))) { result := 1 }\n                }\n            }\n        }\n        bool expected = rds >= 0x40 && !(o + 0x20 > rds) && !(n + o + 0x20 > rds);\n        assertEq(result, expected);\n    }\n\n    function _hash(uint256 i, uint256 j) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, i)\n            mstore(0x20, j)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    function _generateString() internal returns (string memory result) {\n        uint256 randomness = _random();\n        uint256 resultLength = _randomStringLength();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x00, randomness)\n            mstore(0x40, and(add(add(result, 0x40), resultLength), not(31)))\n            mstore(result, resultLength)\n\n            // forgefmt: disable-next-item\n            for { let i := 0 } lt(i, resultLength) { i := add(i, 1) } {\n                mstore(0x20, gas())\n                let c := byte(0, keccak256(0x00, 0x40))\n                mstore8(add(add(result, 0x20), i), or(c, iszero(c)))\n            }\n        }\n    }\n\n    function _randomStringLength() internal returns (uint256 r) {\n        r = _random() % 256;\n        if (r < 64) return _random() % 128;\n        if (r < 128) return _random() % 64;\n        return _random() % 16;\n    }\n}\n",
        "contractname": "MetadataReaderLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            int256 wad = int256(WAD);\n            int256 p = x;\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (w >> 63 == 0) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == 0) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != 0);\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c != 0) {\n                int256 t = w | 1;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    x := sdiv(mul(x, wad), t)\n                }\n                x = (t * (wad + lnWad(x)));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    w := sdiv(x, add(wad, t))\n                }\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // 512-bit multiply `[p1 p0] = x * y`.\n                // Compute the product mod `2**256` and mod `2**256 - 1`\n                // then use the Chinese Remainder Theorem to reconstruct\n                // the 512 bit result. The result is stored in two 256\n                // variables such that `product = p1 * 2**256 + p0`.\n\n                // Least significant 256 bits of the product.\n                result := mul(x, y) // Temporarily use `result` as `p0` to save gas.\n                let mm := mulmod(x, y, not(0))\n                // Most significant 256 bits of the product.\n                let p1 := sub(mm, add(result, lt(mm, result)))\n\n                // Handle non-overflow cases, 256 by 256 division.\n                if iszero(p1) {\n                    if iszero(d) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    result := div(result, d)\n                    break\n                }\n\n                // Make sure the result is less than `2**256`. Also prevents `d == 0`.\n                if iszero(gt(d, p1)) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n\n                /*------------------- 512 by 256 division --------------------*/\n\n                // Make division exact by subtracting the remainder from `[p1 p0]`.\n                // Compute remainder using mulmod.\n                let r := mulmod(x, y, d)\n                // `t` is the least significant bit of `d`.\n                // Always greater or equal to 1.\n                let t := and(d, sub(0, d))\n                // Divide `d` by `t`, which is a power of two.\n                d := div(d, t)\n                // Invert `d mod 2**256`\n                // Now that `d` is an odd number, it has an inverse\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                // Compute the inverse by starting with a seed that is correct\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                let inv := xor(2, mul(3, d))\n                // Now use Newton-Raphson iteration to improve the precision.\n                // Thanks to Hensel's lifting lemma, this also works in modular\n                // arithmetic, doubling the correct bits in each step.\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                result :=\n                    mul(\n                        // Divide [p1 p0] by the factors of two.\n                        // Shift in bits from `p1` into `p0`. For this we need\n                        // to flip `t` such that it is `2**256 / t`.\n                        or(\n                            mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\n                            div(sub(result, r), t)\n                        ),\n                        // inverse mod 2**256\n                        mul(inv, sub(2, mul(d, inv)))\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                result := add(result, 1)\n                if iszero(result) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if iszero(iszero(x)) {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = 10 ** 9;\n            if (x <= type(uint256).max / 10 ** 36 - 1) {\n                x *= 10 ** 18;\n                z = 1;\n            }\n            z *= sqrt(x);\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`.\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = 10 ** 12;\n            if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {\n                if (x >= type(uint256).max / 10 ** 36) {\n                    x *= 10 ** 18;\n                    z = 10 ** 6;\n                } else {\n                    x *= 10 ** 36;\n                    z = 1;\n                }\n            }\n            z *= cbrt(x);\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(sub(0, shr(255, x)), add(sub(0, shr(255, x)), x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {FixedPointMathLib} from \"../src/utils/FixedPointMathLib.sol\";\n\ncontract FixedPointMathLibTest is SoladyTest {\n    function testExpWad() public {\n        assertEq(FixedPointMathLib.expWad(-41446531673892822312), 1);\n        assertEq(FixedPointMathLib.expWad(-41446531673892822313), 0);\n\n        assertEq(FixedPointMathLib.expWad(-3e18), 49787068367863942);\n        assertEq(FixedPointMathLib.expWad(-2e18), 135335283236612691);\n        assertEq(FixedPointMathLib.expWad(-1e18), 367879441171442321);\n\n        assertEq(FixedPointMathLib.expWad(-0.5e18), 606530659712633423);\n        assertEq(FixedPointMathLib.expWad(-0.3e18), 740818220681717866);\n\n        assertEq(FixedPointMathLib.expWad(0), 1000000000000000000);\n\n        assertEq(FixedPointMathLib.expWad(0.3e18), 1349858807576003103);\n        assertEq(FixedPointMathLib.expWad(0.5e18), 1648721270700128146);\n\n        assertEq(FixedPointMathLib.expWad(1e18), 2718281828459045235);\n        assertEq(FixedPointMathLib.expWad(2e18), 7389056098930650227);\n        assertEq(FixedPointMathLib.expWad(3e18), 20085536923187667741);\n        // True value: 20085536923187667740.92\n\n        assertEq(FixedPointMathLib.expWad(10e18), 220264657948067165169_80);\n        // True value: 22026465794806716516957.90\n        // Relative error 9.987984547746668e-22\n\n        assertEq(FixedPointMathLib.expWad(50e18), 5184705528587072464_148529318587763226117);\n        // True value: 5184705528587072464_087453322933485384827.47\n        // Relative error: 1.1780031733243328e-20\n\n        assertEq(\n            FixedPointMathLib.expWad(100e18),\n            268811714181613544841_34666106240937146178367581647816351662017\n        );\n        // True value: 268811714181613544841_26255515800135873611118773741922415191608\n        // Relative error: 3.128803544297531e-22\n\n        assertEq(\n            FixedPointMathLib.expWad(135305999368893231588),\n            578960446186580976_50144101621524338577433870140581303254786265309376407432913\n        );\n        // True value: 578960446186580976_49816762928942336782129491980154662247847962410455084893091\n        // Relative error: 5.653904247484822e-21\n    }\n\n    // Notes on lambertW0Wad:\n    //\n    // If you want to attempt finding a better approximation, look at\n    // https://github.com/recmo/experiment-solexp/blob/main/approximate_mpmath.ipynb\n    // I somehow can't get it to reproduce the approximation constants for `lnWad`.\n    // Let me know if you can get the code to reproduce the approximation constants for `lnWad`.\n\n    event TestingLambertW0WadMonotonicallyIncreasing(\n        int256 a, int256 b, int256 w0a, int256 w0b, bool success, uint256 gasUsed\n    );\n\n    int256 internal constant _ONE_DIV_EXP = 367879441171442321;\n    int256 internal constant _LAMBERT_W0_MIN = -367879441171442321;\n    int256 internal constant _EXP = 2718281828459045235;\n    int256 internal constant _WAD = 10 ** 18;\n\n    function testLambertW0WadKnownValues() public {\n        _checkLambertW0Wad(0, 0);\n        _checkLambertW0Wad(1, 1);\n        _checkLambertW0Wad(2, 2);\n        _checkLambertW0Wad(3, 2);\n        _checkLambertW0Wad(131071, 131070);\n        _checkLambertW0Wad(17179869183, 17179868887);\n        _checkLambertW0Wad(1000000000000000000, 567143290409783872);\n        _checkLambertW0Wad(-3678794411715, -3678807945318);\n        _checkLambertW0Wad(_LAMBERT_W0_MIN, -999999999741585709);\n        // These are exact values.\n        _checkLambertW0Wad(2 ** 255 - 1, 130435123404408416612);\n        _checkLambertW0Wad(2 ** 254 - 1, 129747263755102316133);\n        _checkLambertW0Wad(2 ** 253 - 1, 129059431996357330139);\n        _checkLambertW0Wad(2 ** 252 - 1, 128371628422812486425);\n        _checkLambertW0Wad(2 ** 251 - 1, 127683853333788079721);\n        _checkLambertW0Wad(2 ** 250 - 1, 126996107033385166927);\n        _checkLambertW0Wad(2 ** 249 - 1, 126308389830587715420);\n        _checkLambertW0Wad(2 ** 248 - 1, 125620702039367489656);\n        _checkLambertW0Wad(2 ** 247 - 1, 124933043978791764502);\n        _checkLambertW0Wad(2 ** 246 - 1, 124245415973133957088);\n        _checkLambertW0Wad(2 ** 245 - 1, 123557818351987272451);\n        _checkLambertW0Wad(2 ** 244 - 1, 122870251450381461880);\n        _checkLambertW0Wad(2 ** 243 - 1, 122182715608902796703);\n        _checkLambertW0Wad(2 ** 242 - 1, 121495211173817364188);\n        _checkLambertW0Wad(2 ** 241 - 1, 120807738497197796422);\n        _checkLambertW0Wad(2 ** 240 - 1, 120120297937053547320);\n        _checkLambertW0Wad(2 ** 239 - 1, 119432889857464837488);\n        _checkLambertW0Wad(2 ** 238 - 1, 118745514628720391363);\n        _checkLambertW0Wad(2 ** 237 - 1, 118058172627459096009);\n        _checkLambertW0Wad(2 ** 236 - 1, 117370864236815716134);\n        _checkLambertW0Wad(2 ** 235 - 1, 116683589846570805279);\n        _checkLambertW0Wad(2 ** 234 - 1, 115996349853304958814);\n        _checkLambertW0Wad(2 ** 233 - 1, 115309144660557560280);\n        _checkLambertW0Wad(2 ** 232 - 1, 114621974678990178815);\n        _checkLambertW0Wad(2 ** 231 - 1, 113934840326554781918);\n        _checkLambertW0Wad(2 ** 230 - 1, 113247742028666934564);\n        _checkLambertW0Wad(2 ** 229 - 1, 112560680218384162820);\n        _checkLambertW0Wad(2 ** 228 - 1, 111873655336589667598);\n        _checkLambertW0Wad(2 ** 227 - 1, 111186667832181581935);\n        _checkLambertW0Wad(2 ** 226 - 1, 110499718162267973459);\n        _checkLambertW0Wad(2 ** 225 - 1, 109812806792367802251);\n        _checkLambertW0Wad(2 ** 224 - 1, 109125934196618053331);\n        _checkLambertW0Wad(2 ** 223 - 1, 108439100857987272488);\n        _checkLambertW0Wad(2 ** 222 - 1, 107752307268495744067);\n        _checkLambertW0Wad(2 ** 221 - 1, 107065553929442559763);\n        _checkLambertW0Wad(2 ** 220 - 1, 106378841351639838444);\n        _checkLambertW0Wad(2 ** 219 - 1, 105692170055654368478);\n        _checkLambertW0Wad(2 ** 218 - 1, 105005540572056956171);\n        _checkLambertW0Wad(2 ** 217 - 1, 104318953441679776592);\n        _checkLambertW0Wad(2 ** 216 - 1, 103632409215882036434);\n        _checkLambertW0Wad(2 ** 215 - 1, 102945908456824272609);\n        _checkLambertW0Wad(2 ** 214 - 1, 102259451737751625038);\n        _checkLambertW0Wad(2 ** 213 - 1, 101573039643286437675);\n        _checkLambertW0Wad(2 ** 212 - 1, 100886672769730558166);\n        _checkLambertW0Wad(2 ** 211 - 1, 100200351725377723788);\n        _checkLambertW0Wad(2 ** 210 - 1, 99514077130836439501);\n        _checkLambertW0Wad(2 ** 209 - 1, 98827849619363773067);\n        _checkLambertW0Wad(2 ** 208 - 1, 98141669837210512407);\n        _checkLambertW0Wad(2 ** 207 - 1, 97455538443978151616);\n        _checkLambertW0Wad(2 ** 206 - 1, 96769456112988194563);\n        _checkLambertW0Wad(2 ** 205 - 1, 96083423531664288650);\n        _checkLambertW0Wad(2 ** 204 - 1, 95397441401927726359);\n        _checkLambertW0Wad(2 ** 203 - 1, 94711510440606878644);\n        _checkLambertW0Wad(2 ** 202 - 1, 94025631379861152095);\n        _checkLambertW0Wad(2 ** 201 - 1, 93339804967620091367);\n        _checkLambertW0Wad(2 ** 200 - 1, 92654031968038279517);\n        _checkLambertW0Wad(2 ** 199 - 1, 91968313161966721893);\n        _checkLambertW0Wad(2 ** 198 - 1, 91282649347441434152);\n        _checkLambertW0Wad(2 ** 197 - 1, 90597041340189991908);\n        _checkLambertW0Wad(2 ** 196 - 1, 89911489974156838659);\n        _checkLambertW0Wad(2 ** 195 - 1, 89225996102048190100);\n        _checkLambertW0Wad(2 ** 194 - 1, 88540560595897416858);\n        _checkLambertW0Wad(2 ** 193 - 1, 87855184347651834275);\n        _checkLambertW0Wad(2 ** 192 - 1, 87169868269781877263);\n        _checkLambertW0Wad(2 ** 191 - 1, 86484613295913690725);\n        _checkLambertW0Wad(2 ** 190 - 1, 85799420381486221653);\n        _checkLambertW0Wad(2 ** 189 - 1, 85114290504433958190);\n        _checkLambertW0Wad(2 ** 188 - 1, 84429224665896523735);\n        _checkLambertW0Wad(2 ** 187 - 1, 83744223890956400983);\n        _checkLambertW0Wad(2 ** 186 - 1, 83059289229406131801);\n        _checkLambertW0Wad(2 ** 185 - 1, 82374421756546414467);\n        _checkLambertW0Wad(2 ** 184 - 1, 81689622574016600237);\n        _checkLambertW0Wad(2 ** 183 - 1, 81004892810659176931);\n        _checkLambertW0Wad(2 ** 182 - 1, 80320233623419918558);\n        _checkLambertW0Wad(2 ** 181 - 1, 79635646198285477393);\n        _checkLambertW0Wad(2 ** 180 - 1, 78951131751260298782);\n        _checkLambertW0Wad(2 ** 179 - 1, 78266691529384849812);\n        _checkLambertW0Wad(2 ** 178 - 1, 77582326811797271395);\n        _checkLambertW0Wad(2 ** 177 - 1, 76898038910840689756);\n        _checkLambertW0Wad(2 ** 176 - 1, 76213829173218558571);\n        _checkLambertW0Wad(2 ** 175 - 1, 75529698981200547567);\n        _checkLambertW0Wad(2 ** 174 - 1, 74845649753881648207);\n        _checkLambertW0Wad(2 ** 173 - 1, 74161682948497332759);\n        _checkLambertW0Wad(2 ** 172 - 1, 73477800061797780656);\n        _checkLambertW0Wad(2 ** 171 - 1, 72794002631484376331);\n        _checkLambertW0Wad(2 ** 170 - 1, 72110292237711886966);\n        _checkLambertW0Wad(2 ** 169 - 1, 71426670504659947705);\n        _checkLambertW0Wad(2 ** 168 - 1, 70743139102177717275);\n        _checkLambertW0Wad(2 ** 167 - 1, 70059699747505819935);\n        _checkLambertW0Wad(2 ** 166 - 1, 69376354207079961679);\n        _checkLambertW0Wad(2 ** 165 - 1, 68693104298420901379);\n        _checkLambertW0Wad(2 ** 164 - 1, 68009951892115772747);\n        _checkLambertW0Wad(2 ** 163 - 1, 67326898913896092682);\n        _checkLambertW0Wad(2 ** 162 - 1, 66643947346818157796);\n        _checkLambertW0Wad(2 ** 161 - 1, 65961099233551926143);\n        _checkLambertW0Wad(2 ** 160 - 1, 65278356678784907905);\n        _checkLambertW0Wad(2 ** 159 - 1, 64595721851748049983);\n        _checkLambertW0Wad(2 ** 158 - 1, 63913196988871098107);\n        _checkLambertW0Wad(2 ** 157 - 1, 63230784396575459844);\n        _checkLambertW0Wad(2 ** 156 - 1, 62548486454213176429);\n        _checkLambertW0Wad(2 ** 155 - 1, 61866305617161244980);\n        _checkLambertW0Wad(2 ** 154 - 1, 61184244420081220067);\n        _checkLambertW0Wad(2 ** 153 - 1, 60502305480354769865);\n        _checkLambertW0Wad(2 ** 152 - 1, 59820491501706673077);\n        _checkLambertW0Wad(2 ** 151 - 1, 59138805278027624755);\n        _checkLambertW0Wad(2 ** 150 - 1, 58457249697410179101);\n        _checkLambertW0Wad(2 ** 149 - 1, 57775827746412203235);\n        _checkLambertW0Wad(2 ** 148 - 1, 57094542514563356374);\n        _checkLambertW0Wad(2 ** 147 - 1, 56413397199131353678);\n        _checkLambertW0Wad(2 ** 146 - 1, 55732395110166133991);\n        _checkLambertW0Wad(2 ** 145 - 1, 55051539675841537897);\n        _checkLambertW0Wad(2 ** 144 - 1, 54370834448115730535);\n        _checkLambertW0Wad(2 ** 143 - 1, 53690283108733387465);\n        _checkLambertW0Wad(2 ** 142 - 1, 53009889475594618649);\n        _checkLambertW0Wad(2 ** 141 - 1, 52329657509517754228);\n        _checkLambertW0Wad(2 ** 140 - 1, 51649591321425477661);\n        _checkLambertW0Wad(2 ** 139 - 1, 50969695179986390948);\n        _checkLambertW0Wad(2 ** 138 - 1, 50289973519746960243);\n        _checkLambertW0Wad(2 ** 137 - 1, 49610430949791948630);\n        _checkLambertW0Wad(2 ** 136 - 1, 48931072262974930811);\n        _checkLambertW0Wad(2 ** 135 - 1, 48251902445764340905);\n        _checkLambertW0Wad(2 ** 134 - 1, 47572926688754773801);\n        _checkLambertW0Wad(2 ** 133 - 1, 46894150397897992742);\n        _checkLambertW0Wad(2 ** 132 - 1, 46215579206513348095);\n        _checkLambertW0Wad(2 ** 131 - 1, 45537218988143149666);\n        _checkLambertW0Wad(2 ** 130 - 1, 44859075870325031417);\n        _checkLambertW0Wad(2 ** 129 - 1, 44181156249360587882);\n        _checkLambertW0Wad(2 ** 128 - 1, 43503466806167642613);\n        _checkLambertW0Wad(2 ** 127 - 1, 42826014523312541917);\n        _checkLambertW0Wad(2 ** 126 - 1, 42148806703328979292);\n        _checkLambertW0Wad(2 ** 125 - 1, 41471850988441194251);\n        _checkLambertW0Wad(2 ** 124 - 1, 40795155381822122767);\n        _checkLambertW0Wad(2 ** 123 - 1, 40118728270531400808);\n        _checkLambertW0Wad(2 ** 122 - 1, 39442578450294263667);\n        _checkLambertW0Wad(2 ** 121 - 1, 38766715152300604375);\n        _checkLambertW0Wad(2 ** 120 - 1, 38091148072224059569);\n        _checkLambertW0Wad(2 ** 119 - 1, 37415887401684336100);\n        _checkLambertW0Wad(2 ** 118 - 1, 36740943862402491609);\n        _checkLambertW0Wad(2 ** 117 - 1, 36066328743329022902);\n        _checkLambertW0Wad(2 ** 116 - 1, 35392053941058967434);\n        _checkLambertW0Wad(2 ** 115 - 1, 34718132003887455986);\n        _checkLambertW0Wad(2 ** 114 - 1, 34044576179904059477);\n        _checkLambertW0Wad(2 ** 113 - 1, 33371400469575784902);\n        _checkLambertW0Wad(2 ** 112 - 1, 32698619683327803297);\n        _checkLambertW0Wad(2 ** 111 - 1, 32026249504699254799);\n        _checkLambertW0Wad(2 ** 110 - 1, 31354306559730344521);\n        _checkLambertW0Wad(2 ** 109 - 1, 30682808493328298780);\n        _checkLambertW0Wad(2 ** 108 - 1, 30011774053465850808);\n        _checkLambertW0Wad(2 ** 107 - 1, 29341223184189485097);\n        _checkLambertW0Wad(2 ** 106 - 1, 28671177128558970924);\n        _checkLambertW0Wad(2 ** 105 - 1, 28001658542808735364);\n        _checkLambertW0Wad(2 ** 104 - 1, 27332691623220201135);\n        _checkLambertW0Wad(2 ** 103 - 1, 26664302247428250682);\n        _checkLambertW0Wad(2 ** 102 - 1, 25996518132161712657);\n        _checkLambertW0Wad(2 ** 101 - 1, 25329369009746106264);\n        _checkLambertW0Wad(2 ** 100 - 1, 24662886826087826761);\n        _checkLambertW0Wad(2 ** 99 - 1, 23997105963326166352);\n        _checkLambertW0Wad(2 ** 98 - 1, 23332063490900058530);\n        _checkLambertW0Wad(2 ** 97 - 1, 22667799449451523321);\n        _checkLambertW0Wad(2 ** 96 - 1, 22004357172804292983);\n        _checkLambertW0Wad(2 ** 95 - 1, 21341783654247925671);\n        _checkLambertW0Wad(2 ** 94 - 1, 20680129964567978803);\n        _checkLambertW0Wad(2 ** 93 - 1, 20019451730746615034);\n        _checkLambertW0Wad(2 ** 92 - 1, 19359809686086176343);\n        _checkLambertW0Wad(2 ** 91 - 1, 18701270304772358157);\n        _checkLambertW0Wad(2 ** 90 - 1, 18043906536712772323);\n        _checkLambertW0Wad(2 ** 89 - 1, 17387798662016868795);\n        _checkLambertW0Wad(2 ** 88 - 1, 16733035288929945451);\n        _checkLambertW0Wad(2 ** 87 - 1, 16079714524670107222 + 1);\n        _checkLambertW0Wad(2 ** 86 - 1, 15427945355807184379);\n        _checkLambertW0Wad(2 ** 85 - 1, 14777849284057868231);\n        _checkLambertW0Wad(2 ** 84 - 1, 14129562275318189632);\n        _checkLambertW0Wad(2 ** 83 - 1, 13483237095324880705);\n        _checkLambertW0Wad(2 ** 82 - 1, 12839046125789215063);\n        _checkLambertW0Wad(2 ** 81 - 1, 12197184781931118579);\n        _checkLambertW0Wad(2 ** 80 - 1, 11557875688514566228 - 1);\n        _checkLambertW0Wad(2 ** 79 - 1, 10921373820226202580);\n        _checkLambertW0Wad(2 ** 78 - 1, 10287972878516218499);\n        _checkLambertW0Wad(2 ** 77 - 1, 9658013267990184319);\n        _checkLambertW0Wad(2 ** 76 - 1, 9031892161491509531);\n        _checkLambertW0Wad(2 ** 75 - 1, 8410076319328428686);\n        _checkLambertW0Wad(2 ** 74 - 1, 7793118576966979948);\n        _checkLambertW0Wad(2 ** 73 - 1, 7181679269695846234);\n        _checkLambertW0Wad(2 ** 72 - 1, 6576554370186862926);\n        _checkLambertW0Wad(2 ** 71 - 1, 5978712844468804878 - 1);\n        _checkLambertW0Wad(2 ** 70 - 1, 5389346779005776683);\n        _checkLambertW0Wad(2 ** 69 - 1, 4809939316762921936);\n        _checkLambertW0Wad(2 ** 68 - 1, 4242357480017482271);\n        _checkLambertW0Wad(2 ** 67 - 1, 3688979548845126287);\n        _checkLambertW0Wad(2 ** 66 - 1, 3152869312105232629);\n        _checkLambertW0Wad(2 ** 65 - 1, 2638010157689274059);\n        _checkLambertW0Wad(2 ** 64 - 1, 2149604165721149566);\n        _checkLambertW0Wad(2 ** 63 - 1, 1694407549795038335);\n        _checkLambertW0Wad(2 ** 62 - 1, 1280973323147500590);\n        _checkLambertW0Wad(2 ** 61 - 1, 919438481612859603);\n        _checkLambertW0Wad(2 ** 60 - 1, 620128202996354327);\n        _checkLambertW0Wad(2 ** 59 - 1, 390213425026895126);\n        _checkLambertW0Wad(2 ** 58 - 1, 229193491169149614);\n        _checkLambertW0Wad(2 ** 57 - 1, 126935310044982397);\n        _checkLambertW0Wad(2 ** 56 - 1, 67363429834711483);\n        _checkLambertW0Wad(2 ** 55 - 1, 34796675828817814);\n        _checkLambertW0Wad(2 ** 54 - 1, 17698377658513340);\n        _checkLambertW0Wad(2 ** 53 - 1, 8927148493627578);\n        _checkLambertW0Wad(2 ** 52 - 1, 4483453146102402);\n        _checkLambertW0Wad(2 ** 51 - 1, 2246746269994097);\n        _checkLambertW0Wad(2 ** 50 - 1, 1124634392838166);\n        _checkLambertW0Wad(2 ** 49 - 1, 562633308112667);\n        _checkLambertW0Wad(2 ** 48 - 1, 281395781982528);\n        _checkLambertW0Wad(2 ** 47 - 1, 140717685495042);\n        _checkLambertW0Wad(2 ** 46 - 1, 70363792940114);\n        _checkLambertW0Wad(2 ** 45 - 1, 35183134214121);\n        _checkLambertW0Wad(2 ** 44 - 1, 17591876567571);\n        _checkLambertW0Wad(2 ** 43 - 1, 8796015651975);\n        _checkLambertW0Wad(2 ** 42 - 1, 4398027168417);\n        _checkLambertW0Wad(2 ** 41 - 1, 2199018419863);\n        _checkLambertW0Wad(2 ** 40 - 1, 1099510418851);\n        _checkLambertW0Wad(2 ** 39 - 1, 549755511655);\n        _checkLambertW0Wad(2 ** 38 - 1, 274877831385);\n        _checkLambertW0Wad(2 ** 37 - 1, 137438934581);\n        _checkLambertW0Wad(2 ** 36 - 1, 68719472012);\n        _checkLambertW0Wad(2 ** 35 - 1, 34359737186);\n        _checkLambertW0Wad(2 ** 34 - 1, 17179868887);\n        _checkLambertW0Wad(2 ** 33 - 1, 8589934517);\n        _checkLambertW0Wad(2 ** 32 - 1, 4294967276);\n        _checkLambertW0Wad(2 ** 31 - 1, 2147483642);\n        _checkLambertW0Wad(2 ** 30 - 1, 1073741821);\n        _checkLambertW0Wad(2 ** 29 - 1, 536870910);\n        _checkLambertW0Wad(2 ** 28 - 1, 268435454);\n        _checkLambertW0Wad(2 ** 27 - 1, 134217726);\n        _checkLambertW0Wad(2 ** 26 - 1, 67108862);\n        _checkLambertW0Wad(2 ** 25 - 1, 33554430);\n        _checkLambertW0Wad(2 ** 24 - 1, 16777214);\n        _checkLambertW0Wad(2 ** 23 - 1, 8388606);\n        _checkLambertW0Wad(2 ** 22 - 1, 4194302);\n        _checkLambertW0Wad(2 ** 21 - 1, 2097150);\n        _checkLambertW0Wad(2 ** 20 - 1, 1048574);\n        _checkLambertW0Wad(2 ** 19 - 1, 524286);\n        _checkLambertW0Wad(2 ** 18 - 1, 262142);\n        _checkLambertW0Wad(2 ** 17 - 1, 131070);\n        _checkLambertW0Wad(2 ** 16 - 1, 65534);\n        _checkLambertW0Wad(2 ** 15 - 1, 32766);\n        _checkLambertW0Wad(2 ** 14 - 1, 16382);\n        _checkLambertW0Wad(2 ** 13 - 1, 8190);\n        _checkLambertW0Wad(2 ** 12 - 1, 4094);\n        _checkLambertW0Wad(2 ** 11 - 1, 2046);\n        _checkLambertW0Wad(2 ** 10 - 1, 1022);\n        _checkLambertW0Wad(2 ** 9 - 1, 510);\n        _checkLambertW0Wad(2 ** 8 - 1, 254);\n    }\n\n    function testLambertW0WadRevertsForOutOfDomain() public {\n        FixedPointMathLib.lambertW0Wad(_LAMBERT_W0_MIN);\n        for (int256 i = 0; i <= 10; ++i) {\n            vm.expectRevert(FixedPointMathLib.OutOfDomain.selector);\n            FixedPointMathLib.lambertW0Wad(_LAMBERT_W0_MIN - 1 - i);\n        }\n        vm.expectRevert(FixedPointMathLib.OutOfDomain.selector);\n        FixedPointMathLib.lambertW0Wad(-type(int256).max);\n    }\n\n    function _checkLambertW0Wad(int256 x, int256 expected) internal {\n        unchecked {\n            uint256 gasBefore = gasleft();\n            int256 w = FixedPointMathLib.lambertW0Wad(x);\n            uint256 gasUsed = gasBefore - gasleft();\n            emit LogInt(\"x\", x);\n            emit LogUint(\"gasUsed\", gasUsed);\n            assertEq(w, expected);\n        }\n    }\n\n    function testLambertW0WadAccuracy() public {\n        testLambertW0WadAccuracy(uint184(int184(_testLamberW0WadAccuracyThres())));\n        testLambertW0WadAccuracy(2 ** 184 - 1);\n    }\n\n    function testLambertW0WadAccuracy(uint184 a) public {\n        int256 x = int256(int184(a));\n        if (x >= _testLamberW0WadAccuracyThres()) {\n            int256 l = FixedPointMathLib.lnWad(x);\n            int256 r = x * l / _WAD;\n            int256 w = FixedPointMathLib.lambertW0Wad(r);\n            assertLt(FixedPointMathLib.abs(l - w), 0xff);\n        }\n    }\n\n    function _testLamberW0WadAccuracyThres() internal pure returns (int256) {\n        unchecked {\n            return _ONE_DIV_EXP + _ONE_DIV_EXP * 0.01 ether / 1 ether;\n        }\n    }\n\n    function testLambertW0WadWithinBounds(int256 x) public {\n        if (x <= 0) x = _boundLambertW0WadInput(x);\n        int256 w = FixedPointMathLib.lambertW0Wad(x);\n        assertTrue(w <= x);\n        unchecked {\n            if (x > _EXP) {\n                int256 l = FixedPointMathLib.lnWad(x);\n                assertGt(l, 0);\n                int256 ll = FixedPointMathLib.lnWad(l);\n                int256 q = ll * _WAD;\n                int256 lower = l - ll + q / (2 * l);\n                if (x > _EXP + 4) {\n                    assertLt(lower, w + 1);\n                } else {\n                    assertLt(lower, w + 2);\n                }\n                int256 upper = l - ll + (q * _EXP) / (l * (_EXP - _WAD)) + 1;\n                assertLt(w, upper);\n            }\n        }\n    }\n\n    function testLambertW0WadWithinBounds() public {\n        unchecked {\n            for (int256 i = -10; i != 20; ++i) {\n                testLambertW0WadWithinBounds(_EXP + i);\n            }\n            testLambertW0WadWithinBounds(type(int256).max);\n        }\n    }\n\n    function testLambertW0WadMonotonicallyIncreasing() public {\n        unchecked {\n            for (uint256 i; i <= 256; ++i) {\n                uint256 x = 1 << i;\n                testLambertW0WadMonotonicallyIncreasingAround(int256(x));\n                testLambertW0WadMonotonicallyIncreasingAround(int256(x - 1));\n            }\n            for (uint256 i; i <= 57; ++i) {\n                uint256 x = 1 << i;\n                testLambertW0WadMonotonicallyIncreasingAround(-int256(x));\n                testLambertW0WadMonotonicallyIncreasingAround(-int256(x - 1));\n            }\n        }\n    }\n\n    function testLambertW0WadMonotonicallyIncreasing2() public {\n        // These are some problematic values gathered over the attempts.\n        // Some might not be problematic now.\n        _testLambertW0WadMonoAround(0x598cdf77327d789dc);\n        _testLambertW0WadMonoAround(0x3c8d97dfe4afb1b05);\n        _testLambertW0WadMonoAround(0x56a147b480c03cc22);\n        _testLambertW0WadMonoAround(0x3136f439c231d0bb9);\n        _testLambertW0WadMonoAround(0x2ae7cff17ef2469a1);\n        _testLambertW0WadMonoAround(0x1de668fd7afcf61cc);\n        _testLambertW0WadMonoAround(0x15024b2a35f2cdd95);\n        _testLambertW0WadMonoAround(0x11a65ae94b59590f9);\n        _testLambertW0WadMonoAround(0xf0c2c82174dffb7e);\n        _testLambertW0WadMonoAround(0xed3e56938cb11626);\n        _testLambertW0WadMonoAround(0xecf5c4e511142439);\n        _testLambertW0WadMonoAround(0xc0755fa2b4033cb0);\n        _testLambertW0WadMonoAround(0xa235db282ea4edc6);\n        _testLambertW0WadMonoAround(0x9ff2ec5c26eec112);\n        _testLambertW0WadMonoAround(0xa0c3c4e36f4415f1);\n        _testLambertW0WadMonoAround(0x9b9f0e8d61287782);\n        _testLambertW0WadMonoAround(0x7df719d1a4a7b8ad);\n        _testLambertW0WadMonoAround(0x7c881679a1464d25);\n        _testLambertW0WadMonoAround(0x7bec47487071495a);\n        _testLambertW0WadMonoAround(0x7be31c75fc717f9f);\n        _testLambertW0WadMonoAround(0x7bbb4e0716eeca53);\n        _testLambertW0WadMonoAround(0x78e59d40a92b443b);\n        _testLambertW0WadMonoAround(0x77658c4ad3af717d);\n        _testLambertW0WadMonoAround(0x75ae9afa425919fe);\n        _testLambertW0WadMonoAround(0x7526092d05bef41f);\n        _testLambertW0WadMonoAround(0x52896fe82be03dfe);\n        _testLambertW0WadMonoAround(0x4f05b0ddf3b71a19);\n        _testLambertW0WadMonoAround(0x3094b0feb93943fd);\n        _testLambertW0WadMonoAround(0x2ef215ae6701c40e);\n        _testLambertW0WadMonoAround(0x2ebd1c82095d6a92);\n        _testLambertW0WadMonoAround(0x2e520a4e670d52bb);\n        _testLambertW0WadMonoAround(0xfc2f004412e5ce69);\n        _testLambertW0WadMonoAround(0x158bc0b201103a7fc);\n        _testLambertW0WadMonoAround(0x39280df60945c436b);\n        _testLambertW0WadMonoAround(0x47256e5d374b35f74);\n        _testLambertW0WadMonoAround(0x2b9568ffb08c155a4);\n        _testLambertW0WadMonoAround(0x1b60b07806956f34d);\n        _testLambertW0WadMonoAround(0x21902755d1eee824c);\n        _testLambertW0WadMonoAround(0x6e15c8a6ee6e4fca4);\n        _testLambertW0WadMonoAround(0x5b13067d92d8e49c6);\n        _testLambertW0WadMonoAround(0x2826ebc1fce90cf6e);\n        _testLambertW0WadMonoAround(0x215eb5aa1041510a4);\n        _testLambertW0WadMonoAround(0x47b20347b57504c32);\n        _testLambertW0WadMonoAround(0x75e8fd53f8c90f95a);\n        _testLambertW0WadMonoAround(0x43e8d80f9af282627);\n        _testLambertW0WadMonoAround(0x3cf555b5fd4f20615);\n        _testLambertW0WadMonoAround(0xaff4b8b52f8355e6e);\n        _testLambertW0WadMonoAround(0x529e89e77ae046255);\n        _testLambertW0WadMonoAround(0x1f0289433f07cbf53b);\n        _testLambertW0WadMonoAround(0xc1f6e56c2001d9432);\n        _testLambertW0WadMonoAround(0x5e4117305c6e33ebc);\n        _testLambertW0WadMonoAround(0x2b416472dce2ea26d);\n        _testLambertW0WadMonoAround(0x71f55956ef3326067);\n        _testLambertW0WadMonoAround(0x35d9d57c965eb82c6);\n        _testLambertW0WadMonoAround(0x184f520f19335f25d);\n        _testLambertW0WadMonoAround(0x3c4bb8f445abe21a7);\n        _testLambertW0WadMonoAround(0x573e3b3e06e208201);\n        _testLambertW0WadMonoAround(0x184f520f19335f25d);\n        _testLambertW0WadMonoAround(0x573e3b3e06e208201);\n        _testLambertW0WadMonoAround(0x61e511ba00db632a4);\n        _testLambertW0WadMonoAround(0x12731b97bde57933d);\n        _testLambertW0WadMonoAround(0x79c29b05cf39be374);\n        _testLambertW0WadMonoAround(0x390fcd4186ac250b3);\n        _testLambertW0WadMonoAround(0x69c74b5975fd4832a);\n        _testLambertW0WadMonoAround(0x59db219a7048121bd);\n        _testLambertW0WadMonoAround(0x28f2adc4fab331d251);\n        _testLambertW0WadMonoAround(0x7be91527cc31769c);\n        _testLambertW0WadMonoAround(0x2ef215ae6701c40f);\n        _testLambertW0WadMonoAround(0x1240541334cfadd81);\n        _testLambertW0WadMonoAround(0x2a79eccb3d5f4faaed);\n        _testLambertW0WadMonoAround(0x7470d50c23bfd30e0);\n        _testLambertW0WadMonoAround(0x313386f14a7f95af9);\n        _testLambertW0WadMonoAround(0x2a60f3b64c57088e9);\n        _testLambertW0WadMonoAround(0x381298f7aa53edfe0);\n        _testLambertW0WadMonoAround(0x5cbfac5d7a1770806);\n        _testLambertW0WadMonoAround(0x19e46d1b5e6aba57e);\n        _testLambertW0WadMonoAround(0x19ff86906ae47c70a);\n        _testLambertW0WadMonoAround(0x164684654d9ca54ea1);\n        _testLambertW0WadMonoAround(0x99337fa75e803139);\n        _testLambertW0WadMonoAround(0x6fa0a50fcb8a95b97e);\n        _testLambertW0WadMonoAround(0xa117a195e06c3fd531);\n        _testLambertW0WadMonoAround(0x305da7073093bd8a07);\n        _testLambertW0WadMonoAround(0x98582b07fd3c6b64);\n        _testLambertW0WadMonoAround(0x1e824d2a367d9ce65);\n        _testLambertW0WadMonoAround(0x7bea796d633b386a);\n        _testLambertW0WadMonoAround(0x2fff5c38c6b2a2cd);\n        _testLambertW0WadMonoAround(0x198af4e7ffee1df7627);\n        _testLambertW0WadMonoAround(0x8ea8a7b6f7c7424d8d);\n        _testLambertW0WadMonoAround(0x11e504fa805e54e2ed8);\n        _testLambertW0WadMonoAround(0x3e5f2a7801badcdabd);\n        _testLambertW0WadMonoAround(0x1b7aaad69ac8770a3be);\n        _testLambertW0WadMonoAround(0x658acb00d525f3d345);\n        _testLambertW0WadMonoAround(0xd994d6447146880183f);\n        _testLambertW0WadMonoAround(0x2e07a342d7b1bc1a5ae);\n    }\n\n    function testLambertW0WadMonoDebug() public {\n        unchecked {\n            for (int256 i = -9; i <= 9; ++i) {\n                _testLambertW0WadMonoAround(0x2e07a342d7b1bc1a5ae + i);\n            }\n        }\n    }\n\n    function _testLambertW0WadMonoAround(int256 x) internal {\n        emit LogInt(\"x\", x);\n        emit LogUint(\"log2(x)\", FixedPointMathLib.log2(uint256(x)));\n        testLambertW0WadMonotonicallyIncreasingAround(x);\n    }\n\n    function testLambertW0WadMonotonicallyIncreasingAround2(uint96 t) public {\n        int256 x = int256(uint256(t));\n        testLambertW0WadMonotonicallyIncreasingAround(x);\n        if (t & 0xff == 0xab) {\n            _testLambertW0WadMonoFocus(x, 0, 0x1ffffffffffff, 0xffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 1, 0x1fffffffffffff, 0xffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 2, 0xfffffffffffffff, 0xffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 3, 0xffffffffffffffff, 0xfffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 4, 0xffffffffffffffff, 0xfffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 5, 0xffffffffffffffff, 0xffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 6, 0xffffffffffffffff, 0xffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 7, 0xffffffffffffffff, 0xfffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 8, 0xffffffffffffffff, 0xfffffffffffffffffff);\n            _testLambertW0WadMonoFocus(x, 9, 0xffffffffffffffff, 0xffffffffffffffffffff);\n        }\n    }\n\n    function _testLambertW0WadMonoFocus(int256 t, int256 i, int256 low, int256 mask) internal {\n        int256 x;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, t)\n            mstore(0x20, i)\n            x := and(keccak256(0x00, 0x40), mask)\n        }\n        do {\n            testLambertW0WadMonotonicallyIncreasingAround(x);\n            x >>= 1;\n        } while (x >= low);\n    }\n\n    function testLambertW0WadMonotonicallyIncreasingAround(int256 t) public {\n        if (t < _LAMBERT_W0_MIN) t = _boundLambertW0WadInput(t);\n        unchecked {\n            int256 end = t + 2;\n            for (int256 x = t - 2; x != end; ++x) {\n                testLambertW0WadMonotonicallyIncreasing(x, x + 1);\n            }\n        }\n    }\n\n    function testLambertW0WadMonotonicallyIncreasing(int256 a, int256 b) public {\n        if (a < _LAMBERT_W0_MIN) a = _boundLambertW0WadInput(a);\n        if (b < _LAMBERT_W0_MIN) b = _boundLambertW0WadInput(b);\n        if (a > b) {\n            int256 t = b;\n            b = a;\n            a = t;\n        }\n        unchecked {\n            uint256 gasBefore = gasleft();\n            int256 w0a = FixedPointMathLib.lambertW0Wad(a);\n            uint256 gasUsed = gasBefore - gasleft();\n            int256 w0b = FixedPointMathLib.lambertW0Wad(b);\n            bool success = w0a <= w0b;\n            emit TestingLambertW0WadMonotonicallyIncreasing(a, b, w0a, w0b, success, gasUsed);\n            if (!success) {\n                emit LogUint(\"log2(a)\", FixedPointMathLib.log2(uint256(a)));\n                emit LogUint(\"log2(b)\", FixedPointMathLib.log2(uint256(b)));\n                emit LogUint(\"log2(w0a)\", FixedPointMathLib.log2(uint256(w0a)));\n                emit LogUint(\"log2(w0b)\", FixedPointMathLib.log2(uint256(w0b)));\n                assertTrue(success);\n            }\n        }\n    }\n\n    function _boundLambertW0WadInput(int256 x) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(1, shl(1, not(x)))\n        }\n    }\n\n    function testMulWad() public {\n        assertEq(FixedPointMathLib.mulWad(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWad(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWad(369, 271), 0);\n    }\n\n    function testMulWadEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWad(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWad(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWad(0, 0), 0);\n    }\n\n    function testSMulWad() public {\n        assertEq(FixedPointMathLib.sMulWad(0, -2e18), 0);\n        assertEq(FixedPointMathLib.sMulWad(1e18, -1), -1);\n        assertEq(FixedPointMathLib.sMulWad(-0.5e18, 2e18), -1e18);\n        assertEq(FixedPointMathLib.sMulWad(-0.5e18, -10e18), 5e18);\n    }\n\n    function testSMulWadOverflowTrickDifferential(int256 x, int256 y) public {\n        unchecked {\n            bool c;\n            int256 z;\n            /// @solidity memory-safe-assembly\n            assembly {\n                z := mul(x, y)\n                c := iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1)))))\n            }\n            assertEq(c, !((x == 0 || z / x == y) && (x != -1 || y != type(int256).min)));\n        }\n    }\n\n    function testSMulWadEdgeCases() public {\n        assertEq(FixedPointMathLib.sMulWad(1e18, type(int256).max / 1e18), type(int256).max / 1e18);\n        assertEq(FixedPointMathLib.sMulWad(-1e18, type(int256).min / 2e18), type(int256).max / 2e18);\n        assertEq(FixedPointMathLib.sMulWad(0, 0), 0);\n    }\n\n    function testMulWadUp() public {\n        assertEq(FixedPointMathLib.mulWadUp(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadUp(369, 271), 1);\n    }\n\n    function testMulWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadUp(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadUp(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadUp(0, 0), 0);\n    }\n\n    function testDivWad() public {\n        assertEq(FixedPointMathLib.divWad(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWad(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWad(2, 100000000000000e18), 0);\n    }\n\n    function testDivWadEdgeCases() public {\n        assertEq(FixedPointMathLib.divWad(0, 1e18), 0);\n    }\n\n    function testSDivWad() public {\n        assertEq(FixedPointMathLib.sDivWad(1.25e18, -0.5e18), -2.5e18);\n        assertEq(FixedPointMathLib.sDivWad(3e18, -1e18), -3e18);\n        assertEq(FixedPointMathLib.sDivWad(type(int256).min / 1e18, type(int256).max), 0);\n    }\n\n    function testSDivWadEdgeCases() public {\n        assertEq(FixedPointMathLib.sDivWad(0, 1e18), 0);\n    }\n\n    function testDivWadZeroDenominatorReverts() public {\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWad(1e18, 0);\n    }\n\n    function testDivWadUp() public {\n        assertEq(FixedPointMathLib.divWadUp(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n        unchecked {\n            for (uint256 i; i < 10; ++i) {\n                assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n            }\n        }\n    }\n\n    function testDivWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadUp(0, 1e18), 0);\n    }\n\n    function testDivWadUpZeroDenominatorReverts() public {\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWadUp(1e18, 0);\n    }\n\n    function testMulDiv() public {\n        assertEq(FixedPointMathLib.mulDiv(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDiv(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDiv(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDiv(369, 271, 1e2), 999);\n\n        assertEq(FixedPointMathLib.mulDiv(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDiv(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDiv(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDiv(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDiv(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDiv(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDiv(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDiv(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDiv(0, 0, 1e18), 0);\n    }\n\n    function testMulDivZeroDenominatorReverts() public {\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDiv(1e18, 1e18, 0);\n    }\n\n    function testMulDivUp() public {\n        assertEq(FixedPointMathLib.mulDivUp(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivUp(369, 271, 1e2), 1000);\n\n        assertEq(FixedPointMathLib.mulDivUp(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivUp(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivUp(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivUp(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivUp(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivUp(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(0, 0, 1e18), 0);\n    }\n\n    function testMulDivUpZeroDenominator() public {\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDivUp(1e18, 1e18, 0);\n    }\n\n    function testLnWad() public {\n        assertEq(FixedPointMathLib.lnWad(1e18), 0);\n\n        // Actual: 999999999999999999.8674576\u2026\n        assertEq(FixedPointMathLib.lnWad(2718281828459045235), 999999999999999999);\n\n        // Actual: 2461607324344817917.963296\u2026\n        assertEq(FixedPointMathLib.lnWad(11723640096265400935), 2461607324344817918);\n    }\n\n    function testLnWadSmall() public {\n        // Actual: -41446531673892822312.3238461\u2026\n        assertEq(FixedPointMathLib.lnWad(1), -41446531673892822313);\n\n        // Actual: -37708862055609454006.40601608\u2026\n        assertEq(FixedPointMathLib.lnWad(42), -37708862055609454007);\n\n        // Actual: -32236191301916639576.251880365581\u2026\n        assertEq(FixedPointMathLib.lnWad(1e4), -32236191301916639577);\n\n        // Actual: -20723265836946411156.161923092\u2026\n        assertEq(FixedPointMathLib.lnWad(1e9), -20723265836946411157);\n    }\n\n    function testLnWadBig() public {\n        // Actual: 135305999368893231589.070344787\u2026\n        assertEq(FixedPointMathLib.lnWad(2 ** 255 - 1), 135305999368893231589);\n\n        // Actual: 76388489021297880288.605614463571\u2026\n        assertEq(FixedPointMathLib.lnWad(2 ** 170), 76388489021297880288);\n\n        // Actual: 47276307437780177293.081865\u2026\n        assertEq(FixedPointMathLib.lnWad(2 ** 128), 47276307437780177293);\n    }\n\n    function testLnWadNegativeReverts() public {\n        vm.expectRevert(FixedPointMathLib.LnWadUndefined.selector);\n        FixedPointMathLib.lnWad(-1);\n        FixedPointMathLib.lnWad(-2 ** 255);\n    }\n\n    function testLnWadOverflowReverts() public {\n        vm.expectRevert(FixedPointMathLib.LnWadUndefined.selector);\n        FixedPointMathLib.lnWad(0);\n    }\n\n    function testRPow() public {\n        assertEq(FixedPointMathLib.rpow(0, 0, 0), 0);\n        assertEq(FixedPointMathLib.rpow(1, 0, 0), 0);\n        assertEq(FixedPointMathLib.rpow(0, 1, 0), 0);\n        assertEq(FixedPointMathLib.rpow(0, 0, 1), 1);\n        assertEq(FixedPointMathLib.rpow(1, 1, 0), 1);\n        assertEq(FixedPointMathLib.rpow(1, 1, 1), 1);\n        assertEq(FixedPointMathLib.rpow(2e27, 0, 1e27), 1e27);\n        assertEq(FixedPointMathLib.rpow(2e27, 2, 1e27), 4e27);\n        assertEq(FixedPointMathLib.rpow(2e18, 2, 1e18), 4e18);\n        assertEq(FixedPointMathLib.rpow(2e8, 2, 1e8), 4e8);\n        assertEq(FixedPointMathLib.rpow(8, 3, 1), 512);\n    }\n\n    function testRPowOverflowReverts() public {\n        vm.expectRevert(FixedPointMathLib.RPowOverflow.selector);\n        FixedPointMathLib.rpow(2, type(uint128).max, 1);\n        FixedPointMathLib.rpow(type(uint128).max, 3, 1);\n    }\n\n    function testSqrt() public {\n        assertEq(FixedPointMathLib.sqrt(0), 0);\n        assertEq(FixedPointMathLib.sqrt(1), 1);\n        assertEq(FixedPointMathLib.sqrt(2704), 52);\n        assertEq(FixedPointMathLib.sqrt(110889), 333);\n        assertEq(FixedPointMathLib.sqrt(32239684), 5678);\n        unchecked {\n            for (uint256 i = 100; i < 200; ++i) {\n                assertEq(FixedPointMathLib.sqrt(i * i), i);\n            }\n        }\n    }\n\n    function testSqrtWad() public {\n        assertEq(FixedPointMathLib.sqrtWad(0), 0);\n        assertEq(FixedPointMathLib.sqrtWad(1), 10 ** 9);\n        assertEq(FixedPointMathLib.sqrtWad(2), 1414213562);\n        assertEq(FixedPointMathLib.sqrtWad(4), 2000000000);\n        assertEq(FixedPointMathLib.sqrtWad(8), 2828427124);\n        assertEq(FixedPointMathLib.sqrtWad(16), 4000000000);\n        assertEq(FixedPointMathLib.sqrtWad(32), 5656854249);\n        assertEq(FixedPointMathLib.sqrtWad(64), 8000000000);\n        assertEq(FixedPointMathLib.sqrtWad(10 ** 18), 10 ** 18);\n        assertEq(FixedPointMathLib.sqrtWad(4 * 10 ** 18), 2 * 10 ** 18);\n        assertEq(FixedPointMathLib.sqrtWad(type(uint8).max), 15968719422);\n        assertEq(FixedPointMathLib.sqrtWad(type(uint16).max), 255998046867);\n        assertEq(FixedPointMathLib.sqrtWad(type(uint32).max), 65535999992370);\n        assertEq(FixedPointMathLib.sqrtWad(type(uint64).max), 4294967295999999999);\n        assertEq(FixedPointMathLib.sqrtWad(type(uint128).max), 18446744073709551615999999999);\n        assertEq(\n            FixedPointMathLib.sqrtWad(type(uint256).max),\n            340282366920938463463374607431768211455000000000\n        );\n    }\n\n    function testCbrt() public {\n        assertEq(FixedPointMathLib.cbrt(0), 0);\n        assertEq(FixedPointMathLib.cbrt(1), 1);\n        assertEq(FixedPointMathLib.cbrt(2), 1);\n        assertEq(FixedPointMathLib.cbrt(3), 1);\n        assertEq(FixedPointMathLib.cbrt(9), 2);\n        assertEq(FixedPointMathLib.cbrt(27), 3);\n        assertEq(FixedPointMathLib.cbrt(80), 4);\n        assertEq(FixedPointMathLib.cbrt(81), 4);\n        assertEq(FixedPointMathLib.cbrt(10 ** 18), 10 ** 6);\n        assertEq(FixedPointMathLib.cbrt(8 * 10 ** 18), 2 * 10 ** 6);\n        assertEq(FixedPointMathLib.cbrt(9 * 10 ** 18), 2080083);\n        assertEq(FixedPointMathLib.cbrt(type(uint8).max), 6);\n        assertEq(FixedPointMathLib.cbrt(type(uint16).max), 40);\n        assertEq(FixedPointMathLib.cbrt(type(uint32).max), 1625);\n        assertEq(FixedPointMathLib.cbrt(type(uint64).max), 2642245);\n        assertEq(FixedPointMathLib.cbrt(type(uint128).max), 6981463658331);\n        assertEq(FixedPointMathLib.cbrt(type(uint256).max), 48740834812604276470692694);\n    }\n\n    function testCbrtWad() public {\n        assertEq(FixedPointMathLib.cbrtWad(0), 0);\n        assertEq(FixedPointMathLib.cbrtWad(1), 10 ** 12);\n        assertEq(FixedPointMathLib.cbrtWad(2), 1259921049894);\n        assertEq(FixedPointMathLib.cbrtWad(3), 1442249570307);\n        assertEq(FixedPointMathLib.cbrtWad(9), 2080083823051);\n        assertEq(FixedPointMathLib.cbrtWad(27), 3000000000000);\n        assertEq(FixedPointMathLib.cbrtWad(80), 4308869380063);\n        assertEq(FixedPointMathLib.cbrtWad(81), 4326748710922);\n        assertEq(FixedPointMathLib.cbrtWad(10 ** 18), 10 ** 18);\n        assertEq(FixedPointMathLib.cbrtWad(8 * 10 ** 18), 2 * 10 ** 18);\n        assertEq(FixedPointMathLib.cbrtWad(9 * 10 ** 18), 2080083823051904114);\n        assertEq(FixedPointMathLib.cbrtWad(type(uint8).max), 6341325705384);\n        assertEq(FixedPointMathLib.cbrtWad(type(uint16).max), 40317268530317);\n        assertEq(FixedPointMathLib.cbrtWad(type(uint32).max), 1625498677089280);\n        assertEq(FixedPointMathLib.cbrtWad(type(uint64).max), 2642245949629133047);\n        assertEq(FixedPointMathLib.cbrtWad(type(uint128).max), 6981463658331559092288464);\n        assertEq(\n            FixedPointMathLib.cbrtWad(type(uint256).max), 48740834812604276470692694000000000000\n        );\n    }\n\n    function testLog2() public {\n        assertEq(FixedPointMathLib.log2(0), 0);\n        assertEq(FixedPointMathLib.log2(2), 1);\n        assertEq(FixedPointMathLib.log2(4), 2);\n        assertEq(FixedPointMathLib.log2(1024), 10);\n        assertEq(FixedPointMathLib.log2(1048576), 20);\n        assertEq(FixedPointMathLib.log2(1073741824), 30);\n        for (uint256 i = 1; i < 255; i++) {\n            assertEq(FixedPointMathLib.log2((1 << i) - 1), i - 1);\n            assertEq(FixedPointMathLib.log2((1 << i)), i);\n            assertEq(FixedPointMathLib.log2((1 << i) + 1), i);\n        }\n    }\n\n    function testLog2Differential(uint256 x) public {\n        assertEq(FixedPointMathLib.log2(x), _log2Original(x));\n    }\n\n    function _log2Original(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function testLog2Up() public {\n        assertEq(FixedPointMathLib.log2Up(0), 0);\n        assertEq(FixedPointMathLib.log2Up(1), 0);\n        assertEq(FixedPointMathLib.log2Up(2), 1);\n        assertEq(FixedPointMathLib.log2Up(2 + 1), 2);\n        assertEq(FixedPointMathLib.log2Up(4), 2);\n        assertEq(FixedPointMathLib.log2Up(4 + 1), 3);\n        assertEq(FixedPointMathLib.log2Up(4 + 2), 3);\n        assertEq(FixedPointMathLib.log2Up(1024), 10);\n        assertEq(FixedPointMathLib.log2Up(1024 + 1), 11);\n        assertEq(FixedPointMathLib.log2Up(1048576), 20);\n        assertEq(FixedPointMathLib.log2Up(1048576 + 1), 21);\n        assertEq(FixedPointMathLib.log2Up(1073741824), 30);\n        assertEq(FixedPointMathLib.log2Up(1073741824 + 1), 31);\n        for (uint256 i = 2; i < 255; i++) {\n            assertEq(FixedPointMathLib.log2Up((1 << i) - 1), i);\n            assertEq(FixedPointMathLib.log2Up((1 << i)), i);\n            assertEq(FixedPointMathLib.log2Up((1 << i) + 1), i + 1);\n        }\n    }\n\n    function testAvg() public {\n        assertEq(FixedPointMathLib.avg(uint256(5), uint256(6)), uint256(5));\n        assertEq(FixedPointMathLib.avg(uint256(0), uint256(1)), uint256(0));\n        assertEq(FixedPointMathLib.avg(uint256(45645465), uint256(4846513)), uint256(25245989));\n    }\n\n    function testAvgSigned() public {\n        assertEq(FixedPointMathLib.avg(int256(5), int256(6)), int256(5));\n        assertEq(FixedPointMathLib.avg(int256(0), int256(1)), int256(0));\n        assertEq(FixedPointMathLib.avg(int256(45645465), int256(4846513)), int256(25245989));\n\n        assertEq(FixedPointMathLib.avg(int256(5), int256(-6)), int256(-1));\n        assertEq(FixedPointMathLib.avg(int256(0), int256(-1)), int256(-1));\n        assertEq(FixedPointMathLib.avg(int256(45645465), int256(-4846513)), int256(20399476));\n    }\n\n    function testAvgEdgeCase() public {\n        assertEq(FixedPointMathLib.avg(uint256(2 ** 256 - 1), uint256(1)), uint256(2 ** 255));\n        assertEq(FixedPointMathLib.avg(uint256(2 ** 256 - 1), uint256(10)), uint256(2 ** 255 + 4));\n        assertEq(\n            FixedPointMathLib.avg(uint256(2 ** 256 - 1), uint256(2 ** 256 - 1)),\n            uint256(2 ** 256 - 1)\n        );\n    }\n\n    function testAbs() public {\n        assertEq(FixedPointMathLib.abs(0), 0);\n        assertEq(FixedPointMathLib.abs(-5), 5);\n        assertEq(FixedPointMathLib.abs(5), 5);\n        assertEq(FixedPointMathLib.abs(-1155656654), 1155656654);\n        assertEq(FixedPointMathLib.abs(621356166516546561651), 621356166516546561651);\n    }\n\n    function testDist() public {\n        assertEq(FixedPointMathLib.dist(0, 0), 0);\n        assertEq(FixedPointMathLib.dist(-5, -4), 1);\n        assertEq(FixedPointMathLib.dist(5, 46), 41);\n        assertEq(FixedPointMathLib.dist(46, 5), 41);\n        assertEq(FixedPointMathLib.dist(-1155656654, 6544844), 1162201498);\n        assertEq(FixedPointMathLib.dist(-848877, -8447631456), 8446782579);\n    }\n\n    function testDistEdgeCases() public {\n        assertEq(FixedPointMathLib.dist(type(int256).min, type(int256).max), type(uint256).max);\n        assertEq(\n            FixedPointMathLib.dist(type(int256).min, 0),\n            0x8000000000000000000000000000000000000000000000000000000000000000\n        );\n        assertEq(\n            FixedPointMathLib.dist(type(int256).max, 5),\n            0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\n        );\n        assertEq(\n            FixedPointMathLib.dist(type(int256).min, -5),\n            0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\n        );\n    }\n\n    function testAbsEdgeCases() public {\n        assertEq(FixedPointMathLib.abs(-(2 ** 255 - 1)), (2 ** 255 - 1));\n        assertEq(FixedPointMathLib.abs((2 ** 255 - 1)), (2 ** 255 - 1));\n    }\n\n    function testGcd() public {\n        assertEq(FixedPointMathLib.gcd(0, 0), 0);\n        assertEq(FixedPointMathLib.gcd(85, 0), 85);\n        assertEq(FixedPointMathLib.gcd(0, 2), 2);\n        assertEq(FixedPointMathLib.gcd(56, 45), 1);\n        assertEq(FixedPointMathLib.gcd(12, 28), 4);\n        assertEq(FixedPointMathLib.gcd(12, 1), 1);\n        assertEq(FixedPointMathLib.gcd(486516589451122, 48656), 2);\n        assertEq(FixedPointMathLib.gcd(2 ** 254 - 4, 2 ** 128 - 1), 15);\n        assertEq(FixedPointMathLib.gcd(3, 26017198113384995722614372765093167890), 1);\n        unchecked {\n            for (uint256 i = 2; i < 10; ++i) {\n                assertEq(FixedPointMathLib.gcd(31 * (1 << i), 31), 31);\n            }\n        }\n    }\n\n    function testFullMulDiv() public {\n        assertEq(FixedPointMathLib.fullMulDiv(0, 0, 1), 0);\n        assertEq(FixedPointMathLib.fullMulDiv(4, 4, 2), 8);\n        assertEq(FixedPointMathLib.fullMulDiv(2 ** 200, 2 ** 200, 2 ** 200), 2 ** 200);\n    }\n\n    function testFullMulDivUpRevertsIfRoundedUpResultOverflowsCase1() public {\n        vm.expectRevert(FixedPointMathLib.FullMulDivFailed.selector);\n        FixedPointMathLib.fullMulDivUp(\n            535006138814359, 432862656469423142931042426214547535783388063929571229938474969, 2\n        );\n    }\n\n    function testFullMulDivUpRevertsIfRoundedUpResultOverflowsCase2() public {\n        vm.expectRevert(FixedPointMathLib.FullMulDivFailed.selector);\n        FixedPointMathLib.fullMulDivUp(\n            115792089237316195423570985008687907853269984659341747863450311749907997002549,\n            115792089237316195423570985008687907853269984659341747863450311749907997002550,\n            115792089237316195423570985008687907853269984653042931687443039491902864365164\n        );\n    }\n\n    function testFullMulDiv(uint256 a, uint256 b, uint256 d) public returns (uint256 result) {\n        if (d == 0) {\n            vm.expectRevert(FixedPointMathLib.FullMulDivFailed.selector);\n            FixedPointMathLib.fullMulDiv(a, b, d);\n            return 0;\n        }\n\n        // Compute a * b in Chinese Remainder Basis\n        uint256 expectedA;\n        uint256 expectedB;\n        unchecked {\n            expectedA = a * b;\n            expectedB = mulmod(a, b, 2 ** 256 - 1);\n        }\n\n        // Construct a * b\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        if (prod1 >= d) {\n            vm.expectRevert(FixedPointMathLib.FullMulDivFailed.selector);\n            FixedPointMathLib.fullMulDiv(a, b, d);\n            return 0;\n        }\n\n        uint256 q = FixedPointMathLib.fullMulDiv(a, b, d);\n        uint256 r = mulmod(a, b, d);\n\n        // Compute q * d + r in Chinese Remainder Basis\n        uint256 actualA;\n        uint256 actualB;\n        unchecked {\n            actualA = q * d + r;\n            actualB = addmod(mulmod(q, d, 2 ** 256 - 1), r, 2 ** 256 - 1);\n        }\n\n        assertEq(actualA, expectedA);\n        assertEq(actualB, expectedB);\n        return q;\n    }\n\n    function testFullMulDivUp(uint256 a, uint256 b, uint256 d) public {\n        uint256 fullMulDivResult = testFullMulDiv(a, b, d);\n        if (fullMulDivResult != 0) {\n            uint256 expectedResult = fullMulDivResult;\n            if (mulmod(a, b, d) > 0) {\n                if (!(fullMulDivResult < type(uint256).max)) {\n                    vm.expectRevert(FixedPointMathLib.FullMulDivFailed.selector);\n                    FixedPointMathLib.fullMulDivUp(a, b, d);\n                    return;\n                }\n                expectedResult++;\n            }\n            assertEq(FixedPointMathLib.fullMulDivUp(a, b, d), expectedResult);\n        }\n    }\n\n    function testMulWad(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        uint256 result = FixedPointMathLib.mulWad(x, y);\n        assertEq(result, (x * y) / 1e18);\n        assertEq(FixedPointMathLib.rawMulWad(x, y), result);\n    }\n\n    function testSMulWad(int256 x, int256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if ((x != 0 && (x * y) / x != y) || (x == -1 && y == type(int256).min)) return;\n        }\n\n        int256 result = FixedPointMathLib.sMulWad(x, y);\n        assertEq(result, int256((x * y) / 1e18));\n        assertEq(FixedPointMathLib.rawSMulWad(x, y), result);\n    }\n\n    function testMulWadOverflowReverts(uint256 x, uint256 y) public {\n        unchecked {\n            vm.assume(x != 0 && (x * y) / x != y);\n        }\n        vm.expectRevert(FixedPointMathLib.MulWadFailed.selector);\n        FixedPointMathLib.mulWad(x, y);\n    }\n\n    function testSMulWadOverflowRevertsOnCondition1(int256 x, int256 y) public {\n        unchecked {\n            vm.assume(x != 0 && (x * y) / x != y);\n        }\n        vm.expectRevert(FixedPointMathLib.SMulWadFailed.selector);\n        FixedPointMathLib.sMulWad(x, y);\n    }\n\n    function testSMulWadOverflowRevertsOnCondition2(int256 x) public {\n        vm.assume(x < 0);\n        vm.expectRevert(FixedPointMathLib.SMulWadFailed.selector);\n        FixedPointMathLib.sMulWad(x, type(int256).min);\n    }\n\n    function testMulWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadUp(x, y), x * y == 0 ? 0 : (x * y - 1) / 1e18 + 1);\n    }\n\n    function testMulWadUpOverflowReverts(uint256 x, uint256 y) public {\n        unchecked {\n            vm.assume(x != 0 && !((x * y) / x == y));\n        }\n        vm.expectRevert(FixedPointMathLib.MulWadFailed.selector);\n        FixedPointMathLib.mulWadUp(x, y);\n    }\n\n    function testDivWad(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        uint256 result = FixedPointMathLib.divWad(x, y);\n        assertEq(result, (x * 1e18) / y);\n        assertEq(FixedPointMathLib.rawDivWad(x, y), result);\n    }\n\n    function testSDivWad(int256 x, int256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        int256 result = FixedPointMathLib.sDivWad(x, y);\n        assertEq(result, int256((x * 1e18) / y));\n        assertEq(FixedPointMathLib.rawSDivWad(x, y), result);\n    }\n\n    function testDivWadOverflowReverts(uint256 x, uint256 y) public {\n        unchecked {\n            vm.assume(y != 0 && (x * 1e18) / 1e18 != x);\n        }\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWad(x, y);\n    }\n\n    function testSDivWadOverflowReverts(int256 x, int256 y) public {\n        unchecked {\n            vm.assume(y != 0 && (x * 1e18) / 1e18 != x);\n        }\n        vm.expectRevert(FixedPointMathLib.SDivWadFailed.selector);\n        FixedPointMathLib.sDivWad(x, y);\n    }\n\n    function testDivWadZeroDenominatorReverts(uint256 x) public {\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWad(x, 0);\n    }\n\n    function testSDivWadZeroDenominatorReverts(int256 x) public {\n        vm.expectRevert(FixedPointMathLib.SDivWadFailed.selector);\n        FixedPointMathLib.sDivWad(x, 0);\n    }\n\n    function testDivWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadUp(x, y), x == 0 ? 0 : (x * 1e18 - 1) / y + 1);\n    }\n\n    function testDivWadUpOverflowReverts(uint256 x, uint256 y) public {\n        unchecked {\n            vm.assume(y != 0 && (x * 1e18) / 1e18 != x);\n        }\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWadUp(x, y);\n    }\n\n    function testDivWadUpZeroDenominatorReverts(uint256 x) public {\n        vm.expectRevert(FixedPointMathLib.DivWadFailed.selector);\n        FixedPointMathLib.divWadUp(x, 0);\n    }\n\n    function testMulDiv(uint256 x, uint256 y, uint256 denominator) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDiv(x, y, denominator), (x * y) / denominator);\n    }\n\n    function testMulDivOverflowReverts(uint256 x, uint256 y, uint256 denominator) public {\n        unchecked {\n            vm.assume(denominator != 0 && x != 0 && (x * y) / x != y);\n        }\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDiv(x, y, denominator);\n    }\n\n    function testMulDivZeroDenominatorReverts(uint256 x, uint256 y) public {\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDiv(x, y, 0);\n    }\n\n    function testMulDivUp(uint256 x, uint256 y, uint256 denominator) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(\n            FixedPointMathLib.mulDivUp(x, y, denominator),\n            x * y == 0 ? 0 : (x * y - 1) / denominator + 1\n        );\n    }\n\n    function testMulDivUpOverflowReverts(uint256 x, uint256 y, uint256 denominator) public {\n        unchecked {\n            vm.assume(denominator != 0 && x != 0 && (x * y) / x != y);\n        }\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDivUp(x, y, denominator);\n    }\n\n    function testMulDivUpZeroDenominatorReverts(uint256 x, uint256 y) public {\n        vm.expectRevert(FixedPointMathLib.MulDivFailed.selector);\n        FixedPointMathLib.mulDivUp(x, y, 0);\n    }\n\n    function testCbrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.cbrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where `next * next * next` or `next * next` overflows.\n        unchecked {\n            if (next * next * next < next * next) return;\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root * root <= x && next * next * next > x);\n    }\n\n    function testCbrtWad(uint256 x) public {\n        uint256 result = FixedPointMathLib.cbrtWad(x);\n        uint256 floor = FixedPointMathLib.cbrt(x);\n        assertTrue(result >= floor * 10 ** 12 && result <= (floor + 1) * 10 ** 12);\n        assertEq(result / 10 ** 12, floor);\n    }\n\n    function testCbrtBack(uint256 x) public {\n        unchecked {\n            x = _bound(x, 0, 48740834812604276470692694);\n            while (x != 0) {\n                assertEq(FixedPointMathLib.cbrt(x * x * x), x);\n                x >>= 1;\n            }\n        }\n    }\n\n    function testSqrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.sqrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where `next * next` overflows.\n        unchecked {\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root <= x && next * next > x);\n    }\n\n    function testSqrtWad(uint256 x) public {\n        uint256 result = FixedPointMathLib.sqrtWad(x);\n        uint256 floor = FixedPointMathLib.sqrt(x);\n        assertTrue(result >= floor * 10 ** 9 && result <= (floor + 1) * 10 ** 9);\n        assertEq(result / 10 ** 9, floor);\n    }\n\n    function testSqrtBack(uint256 x) public {\n        unchecked {\n            x >>= 128;\n            while (x != 0) {\n                assertEq(FixedPointMathLib.sqrt(x * x), x);\n                x >>= 1;\n            }\n        }\n    }\n\n    function testSqrtHashed(uint256 x) public {\n        testSqrtBack(uint256(keccak256(abi.encode(x))));\n    }\n\n    function testSqrtHashedSingle() public {\n        testSqrtHashed(123);\n    }\n\n    function testMin(uint256 x, uint256 y) public {\n        uint256 z = x < y ? x : y;\n        assertEq(FixedPointMathLib.min(x, y), z);\n    }\n\n    function testMinBrutalized(uint256 x, uint256 y) public {\n        uint32 xCasted;\n        uint32 yCasted;\n        /// @solidity memory-safe-assembly\n        assembly {\n            xCasted := x\n            yCasted := y\n        }\n        uint256 expected = xCasted < yCasted ? xCasted : yCasted;\n        assertEq(FixedPointMathLib.min(xCasted, yCasted), expected);\n        assertEq(FixedPointMathLib.min(uint32(x), uint32(y)), expected);\n        expected = uint32(x) < uint32(y) ? uint32(x) : uint32(y);\n        assertEq(FixedPointMathLib.min(xCasted, yCasted), expected);\n    }\n\n    function testMinSigned(int256 x, int256 y) public {\n        int256 z = x < y ? x : y;\n        assertEq(FixedPointMathLib.min(x, y), z);\n    }\n\n    function testMax(uint256 x, uint256 y) public {\n        uint256 z = x > y ? x : y;\n        assertEq(FixedPointMathLib.max(x, y), z);\n    }\n\n    function testMaxSigned(int256 x, int256 y) public {\n        int256 z = x > y ? x : y;\n        assertEq(FixedPointMathLib.max(x, y), z);\n    }\n\n    function testMaxCasted(uint32 x, uint32 y, uint256 brutalizer) public {\n        uint32 z = x > y ? x : y;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, brutalizer)\n            mstore(0x20, 1)\n            x := or(shl(32, keccak256(0x00, 0x40)), x)\n            mstore(0x20, 2)\n            y := or(shl(32, keccak256(0x00, 0x40)), y)\n        }\n        assertTrue(FixedPointMathLib.max(x, y) == z);\n    }\n\n    function testZeroFloorSub(uint256 x, uint256 y) public {\n        uint256 z = x > y ? x - y : 0;\n        assertEq(FixedPointMathLib.zeroFloorSub(x, y), z);\n    }\n\n    function testZeroFloorSubCasted(uint32 x, uint32 y, uint256 brutalizer) public {\n        uint256 z = x > y ? x - y : 0;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, brutalizer)\n            mstore(0x20, 1)\n            x := or(shl(32, keccak256(0x00, 0x40)), x)\n            mstore(0x20, 2)\n            y := or(shl(32, keccak256(0x00, 0x40)), y)\n        }\n        assertTrue(FixedPointMathLib.zeroFloorSub(x, y) == z);\n    }\n\n    function testDist(int256 x, int256 y) public {\n        uint256 z;\n        unchecked {\n            if (x > y) {\n                z = uint256(x - y);\n            } else {\n                z = uint256(y - x);\n            }\n        }\n        assertEq(FixedPointMathLib.dist(x, y), z);\n    }\n\n    function testAbs(int256 x) public {\n        uint256 z = uint256(x);\n        if (x < 0) {\n            if (x == type(int256).min) {\n                z = uint256(type(int256).max) + 1;\n            } else {\n                z = uint256(-x);\n            }\n        }\n        assertEq(FixedPointMathLib.abs(x), z);\n    }\n\n    function testGcd(uint256 x, uint256 y) public {\n        assertEq(FixedPointMathLib.gcd(x, y), _gcd(x, y));\n    }\n\n    function testClamp(uint256 x, uint256 minValue, uint256 maxValue) public {\n        uint256 clamped = x;\n        if (clamped < minValue) {\n            clamped = minValue;\n        }\n        if (clamped > maxValue) {\n            clamped = maxValue;\n        }\n        assertEq(FixedPointMathLib.clamp(x, minValue, maxValue), clamped);\n    }\n\n    function testClampSigned(int256 x, int256 minValue, int256 maxValue) public {\n        int256 clamped = x;\n        if (clamped < minValue) {\n            clamped = minValue;\n        }\n        if (clamped > maxValue) {\n            clamped = maxValue;\n        }\n        assertEq(FixedPointMathLib.clamp(x, minValue, maxValue), clamped);\n    }\n\n    function testFactorial() public {\n        uint256 result = 1;\n        assertEq(FixedPointMathLib.factorial(0), result);\n        unchecked {\n            for (uint256 i = 1; i != 58; ++i) {\n                result = result * i;\n                assertEq(FixedPointMathLib.factorial(i), result);\n            }\n        }\n        vm.expectRevert(FixedPointMathLib.FactorialOverflow.selector);\n        FixedPointMathLib.factorial(58);\n    }\n\n    function testFactorialOriginal() public {\n        uint256 result = 1;\n        assertEq(_factorialOriginal(0), result);\n        unchecked {\n            for (uint256 i = 1; i != 58; ++i) {\n                result = result * i;\n                assertEq(_factorialOriginal(i), result);\n            }\n        }\n    }\n\n    function _factorialOriginal(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            for {} x {} {\n                result := mul(result, x)\n                x := sub(x, 1)\n            }\n        }\n    }\n\n    function _gcd(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (y == 0) {\n            return x;\n        } else {\n            return _gcd(y, x % y);\n        }\n    }\n\n    function testRawAdd(uint256 x, uint256 y) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(x, y)\n        }\n        assertEq(FixedPointMathLib.rawAdd(x, y), z);\n    }\n\n    function testRawAdd(int256 x, int256 y) public {\n        int256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(x, y)\n        }\n        assertEq(FixedPointMathLib.rawAdd(x, y), z);\n    }\n\n    function testRawSub(uint256 x, uint256 y) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(x, y)\n        }\n        assertEq(FixedPointMathLib.rawSub(x, y), z);\n    }\n\n    function testRawSub(int256 x, int256 y) public {\n        int256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(x, y)\n        }\n        assertEq(FixedPointMathLib.rawSub(x, y), z);\n    }\n\n    function testRawMul(uint256 x, uint256 y) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n        }\n        assertEq(FixedPointMathLib.rawMul(x, y), z);\n    }\n\n    function testRawMul(int256 x, int256 y) public {\n        int256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n        }\n        assertEq(FixedPointMathLib.rawMul(x, y), z);\n    }\n\n    function testRawDiv(uint256 x, uint256 y) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n        assertEq(FixedPointMathLib.rawDiv(x, y), z);\n    }\n\n    function testRawSDiv(int256 x, int256 y) public {\n        int256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n        assertEq(FixedPointMathLib.rawSDiv(x, y), z);\n    }\n\n    function testRawMod(uint256 x, uint256 y) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n        assertEq(FixedPointMathLib.rawMod(x, y), z);\n    }\n\n    function testRawSMod(int256 x, int256 y) public {\n        int256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n        assertEq(FixedPointMathLib.rawSMod(x, y), z);\n    }\n\n    function testRawAddMod(uint256 x, uint256 y, uint256 denominator) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, denominator)\n        }\n        assertEq(FixedPointMathLib.rawAddMod(x, y, denominator), z);\n    }\n\n    function testRawMulMod(uint256 x, uint256 y, uint256 denominator) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, denominator)\n        }\n        assertEq(FixedPointMathLib.rawMulMod(x, y, denominator), z);\n    }\n\n    function testLog10() public {\n        assertEq(FixedPointMathLib.log10(0), 0);\n        assertEq(FixedPointMathLib.log10(1), 0);\n        assertEq(FixedPointMathLib.log10(type(uint256).max), 77);\n        unchecked {\n            for (uint256 i = 1; i <= 77; ++i) {\n                uint256 x = 10 ** i;\n                assertEq(FixedPointMathLib.log10(x), i);\n                assertEq(FixedPointMathLib.log10(x - 1), i - 1);\n                assertEq(FixedPointMathLib.log10(x + 1), i);\n            }\n        }\n    }\n\n    function testLog10(uint256 i, uint256 j) public {\n        i = _bound(i, 0, 77);\n        uint256 low = 10 ** i;\n        uint256 high = i == 77 ? type(uint256).max : (10 ** (i + 1)) - 1;\n        uint256 x = _bound(j, low, high);\n        assertEq(FixedPointMathLib.log10(x), i);\n    }\n\n    function testLog10Up() public {\n        assertEq(FixedPointMathLib.log10Up(0), 0);\n        assertEq(FixedPointMathLib.log10Up(1), 0);\n        assertEq(FixedPointMathLib.log10Up(9), 1);\n        assertEq(FixedPointMathLib.log10Up(10), 1);\n        assertEq(FixedPointMathLib.log10Up(99), 2);\n        assertEq(FixedPointMathLib.log10Up(100), 2);\n        assertEq(FixedPointMathLib.log10Up(999), 3);\n        assertEq(FixedPointMathLib.log10Up(1000), 3);\n        assertEq(FixedPointMathLib.log10Up(10 ** 77), 77);\n        assertEq(FixedPointMathLib.log10Up(10 ** 77 + 1), 78);\n        assertEq(FixedPointMathLib.log10Up(type(uint256).max), 78);\n    }\n\n    function testLog256() public {\n        assertEq(FixedPointMathLib.log256(0), 0);\n        assertEq(FixedPointMathLib.log256(1), 0);\n        assertEq(FixedPointMathLib.log256(256), 1);\n        assertEq(FixedPointMathLib.log256(type(uint256).max), 31);\n        unchecked {\n            for (uint256 i = 1; i <= 31; ++i) {\n                uint256 x = 256 ** i;\n                assertEq(FixedPointMathLib.log256(x), i);\n                assertEq(FixedPointMathLib.log256(x - 1), i - 1);\n                assertEq(FixedPointMathLib.log256(x + 1), i);\n            }\n        }\n    }\n\n    function testLog256(uint256 i, uint256 j) public {\n        i = _bound(i, 0, 31);\n        uint256 low = 256 ** i;\n        uint256 high = i == 31 ? type(uint256).max : (256 ** (i + 1)) - 1;\n        uint256 x = _bound(j, low, high);\n        assertEq(FixedPointMathLib.log256(x), i);\n    }\n\n    function testLog256Up() public {\n        assertEq(FixedPointMathLib.log256Up(0), 0);\n        assertEq(FixedPointMathLib.log256Up(0x01), 0);\n        assertEq(FixedPointMathLib.log256Up(0x02), 1);\n        assertEq(FixedPointMathLib.log256Up(0xff), 1);\n        assertEq(FixedPointMathLib.log256Up(0x0100), 1);\n        assertEq(FixedPointMathLib.log256Up(0x0101), 2);\n        assertEq(FixedPointMathLib.log256Up(0xffff), 2);\n        assertEq(FixedPointMathLib.log256Up(0x010000), 2);\n        assertEq(FixedPointMathLib.log256Up(0x010001), 3);\n        assertEq(FixedPointMathLib.log256Up(type(uint256).max - 1), 32);\n        assertEq(FixedPointMathLib.log256Up(type(uint256).max), 32);\n    }\n\n    function testSci() public {\n        _testSci(0, 0, 0);\n        _testSci(1, 1, 0);\n        _testSci(13, 13, 0);\n        _testSci(130, 13, 1);\n        _testSci(1300, 13, 2);\n        unchecked {\n            uint256 a = 103;\n            uint256 exponent = 0;\n            uint256 m = 1;\n            uint256 n = 78 - FixedPointMathLib.log10Up(a);\n            for (uint256 i; i < n; ++i) {\n                _testSci(a * m, a, exponent);\n                exponent += 1;\n                m *= 10;\n            }\n        }\n        _testSci(10 ** 77, 1, 77);\n        _testSci(2 * (10 ** 76), 2, 76);\n        _testSci(9 * (10 ** 76), 9, 76);\n        unchecked {\n            for (uint256 i; i < 32; ++i) {\n                testSci(11 + i * i * 100);\n            }\n            for (uint256 i; i < 500; ++i) {\n                _testSci(0, 0, 0);\n            }\n        }\n        unchecked {\n            uint256 x = 30000000000000000000000000000000000000000000000001;\n            _testSci(x, x, 0);\n        }\n    }\n\n    function testSci(uint256 a) public {\n        unchecked {\n            while (a % 10 == 0) a = _random();\n            uint256 exponent = 0;\n            uint256 m = 1;\n            uint256 n = 78 - FixedPointMathLib.log10Up(a);\n            for (uint256 i; i < n; ++i) {\n                _testSci(a * m, a, exponent);\n                uint256 x = a * 10 ** exponent;\n                assertEq(x, a * m);\n                exponent += 1;\n                m *= 10;\n            }\n        }\n    }\n\n    function testSci2(uint256 x) public {\n        unchecked {\n            (uint256 mantissa, uint256 exponent) = FixedPointMathLib.sci(x);\n            assertEq(x % 10 ** exponent, 0);\n            if (x != 0) {\n                assertTrue(x % 10 ** (exponent + 1) > 0);\n                assertTrue(mantissa % 10 != 0);\n            } else {\n                assertEq(mantissa, 0);\n                assertEq(exponent, 0);\n            }\n        }\n    }\n\n    function _testSci(uint256 x, uint256 expectedMantissa, uint256 expectedExponent) internal {\n        (uint256 mantissa, uint256 exponent) = FixedPointMathLib.sci(x);\n        assertEq(mantissa, expectedMantissa);\n        assertEq(exponent, expectedExponent);\n    }\n\n    function testPackUnpackSci(uint256) public {\n        unchecked {\n            uint256 x = (_random() & 0x1) * 10 ** (_random() % 70);\n            uint8 packed = uint8(FixedPointMathLib.packSci(x));\n            uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n            assertEq(unpacked, x);\n        }\n        unchecked {\n            uint256 x = (_random() & 0x1ff) * 10 ** (_random() % 70);\n            uint16 packed = uint16(FixedPointMathLib.packSci(x));\n            uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n            assertEq(unpacked, x);\n        }\n        unchecked {\n            uint256 x = (_random() & 0x1ffffff) * 10 ** (_random() % 70);\n            uint32 packed = uint32(FixedPointMathLib.packSci(x));\n            uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n            assertEq(unpacked, x);\n        }\n        unchecked {\n            uint256 x = (_random() & 0x1ffffffffffffff) * 10 ** (_random() % 60);\n            uint64 packed = uint64(FixedPointMathLib.packSci(x));\n            uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n            assertEq(unpacked, x);\n        }\n        unchecked {\n            uint256 x = (_random() * 10 ** (_random() % 78)) & ((1 << 249) - 1);\n            uint256 packed = FixedPointMathLib.packSci(x);\n            uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n            assertEq(unpacked, x);\n        }\n    }\n\n    function testPackUnpackSci() public {\n        uint256 mantissaSize = 249;\n        unchecked {\n            for (uint256 i; i <= mantissaSize; ++i) {\n                uint256 x = (1 << i) - 1;\n                uint256 packed = FixedPointMathLib.packSci(x);\n                uint256 unpacked = FixedPointMathLib.unpackSci(packed);\n                assertEq(unpacked, x);\n            }\n        }\n        unchecked {\n            uint256 x = (1 << (mantissaSize + 1)) - 1;\n            vm.expectRevert(FixedPointMathLib.MantissaOverflow.selector);\n            FixedPointMathLib.packSci(x);\n        }\n    }\n}\n",
        "contractname": "FixedPointMathLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == 0) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibBit} from \"../src/utils/LibBit.sol\";\n\ncontract LibBitTest is SoladyTest {\n    function testFLS() public {\n        assertEq(LibBit.fls(0xff << 3), 10);\n        for (uint256 i = 1; i < 255; i++) {\n            assertEq(LibBit.fls((1 << i) - 1), i - 1);\n            assertEq(LibBit.fls((1 << i)), i);\n            assertEq(LibBit.fls((1 << i) + 1), i);\n        }\n        assertEq(LibBit.fls(0), 256);\n    }\n\n    function testCLZ() public {\n        for (uint256 i = 1; i < 255; i++) {\n            assertEq(LibBit.clz((1 << i) - 1), 255 - (i - 1));\n            assertEq(LibBit.clz((1 << i)), 255 - i);\n            assertEq(LibBit.clz((1 << i) + 1), 255 - i);\n        }\n        assertEq(LibBit.clz(0), 256);\n    }\n\n    function testFFS() public {\n        assertEq(LibBit.ffs(0xff << 3), 3);\n        uint256 brutalizer = uint256(keccak256(abi.encode(address(this), block.timestamp)));\n        for (uint256 i = 0; i < 256; i++) {\n            assertEq(LibBit.ffs(1 << i), i);\n            assertEq(LibBit.ffs(type(uint256).max << i), i);\n            assertEq(LibBit.ffs((brutalizer | 1) << i), i);\n        }\n        assertEq(LibBit.ffs(0), 256);\n    }\n\n    function testPopCount(uint256 x) public {\n        uint256 c;\n        unchecked {\n            for (uint256 t = x; t != 0; c++) {\n                t &= t - 1;\n            }\n        }\n        assertEq(LibBit.popCount(x), c);\n    }\n\n    function testPopCount() public {\n        unchecked {\n            for (uint256 i = 1; i < 256; ++i) {\n                assertEq(LibBit.popCount((1 << i) | 1), 2);\n            }\n        }\n    }\n\n    function testIsPo2(uint8 a, uint8 b) public {\n        unchecked {\n            uint256 x = (1 << uint256(a)) | (1 << uint256(b));\n            if (a == b) {\n                assertTrue(LibBit.isPo2(x));\n            } else {\n                assertFalse(LibBit.isPo2(x));\n            }\n        }\n    }\n\n    function testIsPo2(uint256 x) public {\n        uint256 c;\n        unchecked {\n            for (uint256 t = x; t != 0; c++) {\n                t &= t - 1;\n            }\n        }\n        assertEq(LibBit.isPo2(x), c == 1);\n    }\n\n    function testIsPo2() public {\n        assertFalse(LibBit.isPo2(0));\n        assertFalse(LibBit.isPo2(type(uint256).max));\n        unchecked {\n            for (uint256 i; i < 256; ++i) {\n                uint256 x = 1 << i;\n                assertTrue(LibBit.isPo2(x));\n                assertFalse(LibBit.isPo2(~x));\n            }\n        }\n    }\n\n    function testAnd(bool x, bool y) public {\n        assertEq(LibBit.and(x, y), x && y);\n        assertEq(LibBit.rawAnd(x, y), LibBit.and(x, y));\n    }\n\n    function testAnd() public {\n        unchecked {\n            for (uint256 t; t != 100; ++t) {\n                uint256 i = _random();\n                uint256 j = _random();\n                uint256 k = _random();\n                bool a = i < j;\n                bool b = j < k;\n                assertEq(LibBit.and(a, b), i < j && j < k);\n            }\n        }\n    }\n\n    function testOr(bool x, bool y) public {\n        assertEq(LibBit.or(x, y), x || y);\n        assertEq(LibBit.rawOr(x, y), LibBit.or(x, y));\n    }\n\n    function testOr() public {\n        unchecked {\n            for (uint256 t; t != 100; ++t) {\n                uint256 i = _random();\n                uint256 j = _random();\n                uint256 k = _random();\n                bool a = i < j;\n                bool b = j < k;\n                assertEq(LibBit.or(a, b), i < j || j < k);\n            }\n        }\n    }\n\n    function testAutoClean(uint256 x, uint256 y) public {\n        bool xCasted;\n        bool yCasted;\n        /// @solidity memory-safe-assembly\n        assembly {\n            xCasted := x\n            yCasted := y\n        }\n        bool result = LibBit.and(true, LibBit.or(xCasted, yCasted));\n        assertEq(result, xCasted || yCasted);\n    }\n\n    function testReturnsBool() public {\n        bool result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x40b98a2f)\n            mstore(0x20, 123)\n            pop(staticcall(gas(), address(), 0x1c, 0x24, 0x00, 0x20))\n            result := eq(mload(0x00), 1)\n        }\n        assertTrue(result);\n    }\n\n    function returnsBool(uint256 i) public pure returns (bool b) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := i\n        }\n    }\n\n    function testPassInBool() public {\n        bool result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x59a3028a)\n            mstore(0x20, 1)\n            pop(staticcall(gas(), address(), 0x1c, 0x24, 0x00, 0x20))\n            result := eq(mload(0x00), 1)\n        }\n        assertTrue(result);\n    }\n\n    function acceptsBool(bool) public pure returns (bool) {\n        return true;\n    }\n\n    function testBoolToUint(bool b) public {\n        uint256 z;\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n        assertEq(LibBit.toUint(b), z);\n        assertEq(LibBit.rawToUint(b), z);\n    }\n\n    function testReverseBits() public {\n        uint256 x = 0xf2e857a5b8e3fec9f9c60ae71ba63813c96741bc837169cf0f29f113ede5956f;\n        uint256 r = 0xf6a9a7b7c88f94f0f3968ec13d82e693c81c65d8e750639f937fc71da5ea174f;\n        assertEq(LibBit.reverseBits(x), r);\n        unchecked {\n            for (uint256 i; i < 256; ++i) {\n                assertEq(LibBit.reverseBits(1 << i), (1 << 255) >> i);\n            }\n        }\n    }\n\n    function testReverseBitsDifferential(uint256 x) public {\n        assertEq(LibBit.reverseBits(x), _reverseBitsOriginal(x));\n    }\n\n    function _reverseBitsOriginal(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            for (uint256 i; i != 256; ++i) {\n                r = (r << 1) | ((x >> i) & 1);\n            }\n        }\n    }\n\n    function testReverseBytes() public {\n        uint256 x = 0x112233445566778899aa112233445566778899aa112233445566778899aa1122;\n        uint256 r = 0x2211aa998877665544332211aa998877665544332211aa998877665544332211;\n        assertEq(LibBit.reverseBytes(x), r);\n        unchecked {\n            for (uint256 i; i < 256; i += 8) {\n                assertEq(LibBit.reverseBytes(0xff << i), (0xff << 248) >> i);\n            }\n        }\n    }\n\n    function testReverseBytesDifferential(uint256 x) public {\n        assertEq(LibBit.reverseBytes(x), _reverseBytesOriginal(x));\n    }\n\n    function _reverseBytesOriginal(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let i := 0 } lt(i, 32) { i := add(i, 1) } { mstore8(i, byte(sub(31, i), x)) }\n            r := mload(0x00)\n        }\n    }\n}\n",
        "contractname": "LibBit.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for generating pseudorandom numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\nlibrary LibPRNG {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\n    error InvalidInitialLazyShufflerLength();\n\n    /// @dev The new length must not be less than the current length.\n    error InvalidNewLazyShufflerLength();\n\n    /// @dev The lazy shuffler has not been initialized.\n    error LazyShufflerNotInitialized();\n\n    /// @dev Cannot double initialize the lazy shuffler.\n    error LazyShufflerAlreadyInitialized();\n\n    /// @dev The lazy shuffle has finished.\n    error LazyShuffleFinished();\n\n    /// @dev The queried index is out of bounds.\n    error LazyShufflerGetOutOfBounds();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A pseudorandom number state in memory.\n    struct PRNG {\n        uint256 state;\n    }\n\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\n    struct LazyShuffler {\n        // Bits Layout:\n        // - [0..31]    `numShuffled`\n        // - [32..223]  `permutationSlot`\n        // - [224..255] `length`\n        uint256 _state;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Seeds the `prng` with `state`.\n    function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }\n\n    /// @dev Returns the next pseudorandom uint256.\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }\n\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\n    /// between 0 (inclusive) and `upper` (exclusive).\n    /// If your modulus is big, this method is recommended\n    /// for uniform sampling to avoid modulo bias.\n    /// For uniform sampling across all uint256 values,\n    /// or for small enough moduli such that the bias is neligible,\n    /// use {next} instead.\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }\n\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\n            // The chance of drawing a sample outside 10 \u03c3 from the standard normal distribution\n            // is \u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\n            let s := 0x1000000000000000100000000000000010000000000000001\n            let r1 := mulmod(result, a, n)\n            let r2 := mulmod(r1, a, n)\n            let r3 := mulmod(r2, a, n)\n            // forgefmt: disable-next-item\n            result := sub(sar(96, mul(26614938895861601847173011183,\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\n        }\n    }\n\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\n            // Gas usage varies, starting from about 172+ gas.\n            let r := keccak256(prng, 0x20)\n            mstore(prng, r)\n            let p := shl(129, r)\n            let w := shl(1, r)\n            if iszero(gt(w, p)) {\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n                for {} 1 {} {\n                    r := mulmod(r, a, n)\n                    if iszero(lt(shl(129, r), w)) {\n                        r := mulmod(r, a, n)\n                        result := add(1000000000000000000, result)\n                        w := shl(1, r)\n                        p := shl(129, r)\n                        if iszero(lt(w, p)) { break }\n                        continue\n                    }\n                    w := shl(1, r)\n                    if iszero(lt(w, shl(129, r))) { break }\n                }\n            }\n            result := add(div(p, shl(129, 170141183460469231732)), result)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\n    /// Reverts if `$` has already been initialized.\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\n    function initialize(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if sload($.slot) {\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, $.slot)\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Increases the length of `$`.\n    /// Reverts if `$` has not been initialized.\n    function grow(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            // If the new length is smaller than the old length, revert.\n            if lt(n, shr(224, state)) {\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\n        }\n    }\n\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\n    /// such that all elements can be drawn again.\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\n    function restart(LazyShuffler storage $) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot)\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, shl(32, shr(32, state)))\n        }\n    }\n\n    /// @dev Returns the number of elements that have been shuffled.\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(0xffffffff, sload($.slot))\n        }\n    }\n\n    /// @dev Returns the length of `$`.\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload($.slot))\n        }\n    }\n\n    /// @dev Returns if `$` has been initialized.\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(sload($.slot)))\n        }\n    }\n\n    /// @dev Returns if there are any more elements left to shuffle.\n    /// Reverts if `$` is not initialized.\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            result := eq(shr(224, state), and(0xffffffff, state))\n        }\n    }\n\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            let n := shr(224, state) // Length of `$`.\n            if iszero(lt(index, n)) {\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let u32 := gt(n, 0xfffe)\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\n            result := and(m, shr(o, sload(s)))\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\n        }\n    }\n\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\n    /// and returns the next value in the shuffled range.\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function _get(u32_, state_, i_) -> _value {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                _value := and(m_, shr(o_, sload(s_)))\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\n            }\n            function _set(u32_, state_, i_, value_) {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                let v_ := sload(s_) // Bucket slot value.\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\n            }\n            let state := sload($.slot) // The packed value at `$`.\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\n            let n := shr(224, state) // Length of `$`.\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\n            if iszero(remainder) {\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\n            chosen := _get(gt(n, 0xfffe), state, index)\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibPRNG} from \"../src/utils/LibPRNG.sol\";\nimport {LibSort} from \"../src/utils/LibSort.sol\";\nimport {FixedPointMathLib} from \"../src/utils/FixedPointMathLib.sol\";\n\ncontract LibPRNGTest is SoladyTest {\n    using LibPRNG for *;\n\n    LibPRNG.LazyShuffler internal _lazyShuffler0;\n    LibPRNG.LazyShuffler internal _lazyShuffler1;\n\n    function testPRNGNext() public {\n        unchecked {\n            // Super unlikely to fail.\n            for (uint256 i; i < 32; ++i) {\n                LibPRNG.PRNG memory prng;\n                prng.seed(i);\n                uint256 r0 = prng.next();\n                uint256 r1 = prng.next();\n                uint256 r2 = prng.next();\n                assertTrue(r0 != r1);\n                assertTrue(r1 != r2);\n                prng.seed(i * 2);\n                uint256 r3 = prng.next();\n                assertTrue(r2 != r3);\n            }\n        }\n    }\n\n    function testPRNGUniform() public {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            for (uint256 i = 1; i < 32; ++i) {\n                for (uint256 j; j < 32; ++j) {\n                    assertTrue(prng.uniform(i) < i);\n                }\n            }\n            for (uint256 i; i < 32; ++i) {\n                assertTrue(prng.uniform(0) == 0);\n            }\n            // Super unlikely to fail.\n            uint256 previous;\n            for (uint256 i = 128; i < 256; ++i) {\n                uint256 n = 1 << i;\n                for (uint256 j; j < 8; ++j) {\n                    uint256 r = prng.uniform(n);\n                    assertTrue(r < n);\n                    assertTrue(r != previous);\n                    previous = r;\n                }\n            }\n        }\n    }\n\n    function testPRNGShuffleGas() public pure {\n        unchecked {\n            uint256[] memory a = new uint256[](10000);\n            LibPRNG.PRNG memory prng;\n            prng.shuffle(a);\n        }\n    }\n\n    function testPRNGShuffleBytesGas() public pure {\n        unchecked {\n            bytes memory a = new bytes(10000);\n            LibPRNG.PRNG memory prng;\n            prng.shuffle(a);\n        }\n    }\n\n    function testPRNGShuffle() public {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            for (uint256 s = 1; s < 9; ++s) {\n                uint256 n = 1 << s; // 2, 4, 8, 16, ...\n                uint256[] memory a = new uint256[](n);\n                for (uint256 i; i < n; ++i) {\n                    a[i] = i;\n                }\n                bytes32 hashBefore = keccak256(abi.encode(a));\n                for (;;) {\n                    prng.shuffle(a);\n                    bytes32 hashAfterShuffle = keccak256(abi.encode(a));\n                    LibSort.sort(a);\n                    bytes32 hashAfterSort = keccak256(abi.encode(a));\n                    assertTrue(hashBefore == hashAfterSort);\n                    if (hashBefore != hashAfterShuffle) break;\n                }\n            }\n            // Checking that we won't crash.\n            for (uint256 n = 0; n < 2; ++n) {\n                uint256[] memory a = new uint256[](n);\n                prng.shuffle(a);\n            }\n        }\n    }\n\n    function testPRNGShuffleBytes() public {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            for (uint256 s = 1; s < 9; ++s) {\n                uint256 n = 1 << s; // 2, 4, 8, 16, ...\n                bytes memory a = new bytes(n);\n                for (uint256 i; i < n; ++i) {\n                    a[i] = bytes1(uint8(i & 0xff));\n                }\n                bytes32 hashBefore = keccak256(abi.encode(a));\n                uint256 checksumBefore = _bytesOrderAgnosticChecksum(a);\n                for (uint256 i; i < 30; ++i) {\n                    prng.shuffle(a);\n                    assertEq(_bytesOrderAgnosticChecksum(a), checksumBefore);\n                    bytes32 hashAfterShuffle = keccak256(abi.encode(a));\n                    if (hashBefore != hashAfterShuffle) break;\n                }\n            }\n            // Checking that we won't crash.\n            for (uint256 n = 0; n < 2; ++n) {\n                uint256[] memory a = new uint256[](n);\n                prng.shuffle(a);\n            }\n        }\n    }\n\n    function testLCGGas() public {\n        unchecked {\n            uint256 randomness;\n            for (uint256 i; i < 256; i++) {\n                randomness = _stepLCG(randomness);\n            }\n            assertTrue(randomness != 0);\n        }\n    }\n\n    function testPRNGGas() public {\n        unchecked {\n            LibPRNG.PRNG memory prng;\n            uint256 randomness;\n            for (uint256 i; i < 256; i++) {\n                randomness = prng.next();\n            }\n            assertTrue(randomness != 0);\n        }\n    }\n\n    function _bytesOrderAgnosticChecksum(bytes memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let n := mload(a) } n { n := sub(n, 1) } {\n                result := add(result, and(mload(add(a, n)), 0xff))\n            }\n        }\n    }\n\n    // This is for demonstrating that the gas savings\n    // over the `keccak256` approach isn't that much.\n    // The multiplier and the increment are chosen for good enough\n    // statistical test results.\n    //\n    // See: https://github.com/stevenang/randomness_testsuite\n    // See: https://www.pcg-random.org/posts/does-it-beat-the-minimal-standard.html\n    //\n    // The xorshift is required because the raw 128 lower bits\n    // of the LCG alone will not pass the tests.\n    function _stepLCG(uint256 state) private pure returns (uint256 randomness) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let a := 0xd6aad120322a96acae4ccfaf5fcd4bbfda3f2f3001db6837c0981639faa68d8d\n            state := add(mul(state, a), 83)\n            randomness := xor(state, shr(128, state))\n        }\n    }\n\n    function testStandardNormalWad() public {\n        LibPRNG.PRNG memory prng;\n        unchecked {\n            uint256 n = 1000;\n            int256 oldM;\n            int256 newM;\n            int256 oldS;\n            int256 newS;\n            for (uint256 i; i != n;) {\n                uint256 gasBefore = gasleft();\n                int256 x = prng.standardNormalWad();\n                uint256 gasUsed = gasBefore - gasleft();\n                if (++i == 1) {\n                    oldM = (newM = x);\n                } else {\n                    newM = oldM + (x - oldM) / int256(i);\n                    newS = oldS + (x - oldM) * (x - newM);\n                    oldM = newM;\n                    oldS = newS;\n                }\n                emit LogInt(\"standardNormalWad\", x);\n                emit LogUint(\"gasUsed\", gasUsed);\n            }\n            int256 wad = int256(FixedPointMathLib.WAD);\n            emit LogInt(\"mean\", newM);\n            int256 sd = int256(FixedPointMathLib.sqrt(uint256(newS / int256(n - 1))));\n            assertLt(FixedPointMathLib.abs(newM), uint256(wad / 8));\n            emit LogInt(\"standard deviation\", sd);\n            assertLt(FixedPointMathLib.abs(sd - wad), uint256(wad / 8));\n        }\n    }\n\n    function testExponentialWad() public {\n        LibPRNG.PRNG memory prng;\n        unchecked {\n            uint256 n = 1000;\n            int256 oldM;\n            int256 newM;\n            int256 oldS;\n            int256 newS;\n            for (uint256 i; i != n;) {\n                uint256 gasBefore = gasleft();\n                int256 x = int256(prng.exponentialWad());\n                uint256 gasUsed = gasBefore - gasleft();\n                if (++i == 1) {\n                    oldM = (newM = x);\n                } else {\n                    newM = oldM + (x - oldM) / int256(i);\n                    newS = oldS + (x - oldM) * (x - newM);\n                    oldM = newM;\n                    oldS = newS;\n                }\n                emit LogInt(\"exponentialWad\", x);\n                emit LogUint(\"gasUsed\", gasUsed);\n            }\n            int256 wad = int256(FixedPointMathLib.WAD);\n            emit LogInt(\"mean\", newM);\n            int256 sd = int256(FixedPointMathLib.sqrt(uint256(newS / int256(n - 1))));\n            assertLt(FixedPointMathLib.abs(newM - wad), uint256(wad / 8));\n            emit LogInt(\"standard deviation\", sd);\n            assertLt(FixedPointMathLib.abs(sd - wad), uint256(wad / 8));\n        }\n    }\n\n    function testLazyShufflerProducesShuffledRange(uint256 n) public {\n        n = _bound(n, 1, _random() % 8 == 0 ? 50 : 10);\n        if (_random() % 8 == 0) {\n            _brutalizeMemory();\n        }\n        _lazyShuffler0.initialize(n);\n        assertEq(_lazyShuffler0.length(), n);\n        assertEq(_lazyShuffler0.numShuffled(), 0);\n        if (_random() % 8 == 0) {\n            _lazyShuffler0.restart();\n        }\n        assertEq(_lazyShuffler0.initialized(), true);\n        assertEq(_lazyShuffler1.initialized(), false);\n        assertEq(_lazyShuffler0.finished(), false);\n        uint256[] memory outputs = new uint256[](n);\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                assertEq(_lazyShuffler0.finished(), false);\n                outputs[i] = _lazyShuffler0.next(_random());\n            }\n            if (n > 32) {\n                bool anyShuffled;\n                for (uint256 i; i != n && !anyShuffled; ++i) {\n                    anyShuffled = outputs[i] != i;\n                }\n                assertTrue(anyShuffled); // Super unlikely to fail.\n            }\n            LibSort.sort(outputs);\n            for (uint256 i; i != n; ++i) {\n                assertEq(outputs[i], i);\n            }\n            assertEq(_lazyShuffler0.finished(), true);\n        }\n        assertEq(_lazyShuffler0.finished(), true);\n    }\n\n    function testLazyShufflerProducesShuffledRange2() public {\n        unchecked {\n            _lazyShuffler0.initialize(uint32(17));\n            int256 m = 16;\n            // This infinite loop must eventually break.\n            for (bool done; !done;) {\n                int256[] memory sums = new int256[](17);\n                for (int256 t; t != m; ++t) {\n                    for (uint256 i; i != 17; ++i) {\n                        sums[i] += int256(uint256(_lazyShuffler0.next(_random())));\n                    }\n                    _lazyShuffler0.restart();\n                }\n                int256 expectedAvgSum = 8 * m;\n                done = true;\n                uint256 thres = uint256(expectedAvgSum / 8);\n                for (uint256 i; i != 17; ++i) {\n                    if (FixedPointMathLib.abs(sums[i] - expectedAvgSum) >= thres) {\n                        done = false;\n                        m *= 2;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function testLazyShufflerProducesShuffledRangeWithGrow(uint256 n, uint256 nGrow) public {\n        n = _bound(n, 1, 32);\n        nGrow = n + _bound(nGrow, 0, 32);\n        _lazyShuffler0.initialize(n);\n        uint256[] memory outputs = new uint256[](nGrow);\n        unchecked {\n            uint256 i;\n            while (i != n) {\n                outputs[i] = _lazyShuffler0.next(_random());\n                ++i;\n                if (_random() % 8 == 0) break;\n            }\n            _lazyShuffler0.grow(nGrow);\n            while (i != nGrow) {\n                outputs[i] = _lazyShuffler0.next(_random());\n                ++i;\n            }\n            LibSort.sort(outputs);\n            for (i = 0; i != nGrow; ++i) {\n                assertEq(outputs[i], i);\n            }\n            assertEq(_lazyShuffler0.finished(), true);\n        }\n        assertEq(_lazyShuffler0.finished(), true);\n    }\n\n    function testLazyShufflerNoStorageCollisions() public {\n        _lazyShuffler0.initialize(16);\n        _lazyShuffler1.initialize(32);\n        uint256[] memory outputs0 = new uint256[](16);\n        uint256[] memory outputs1 = new uint256[](32);\n        unchecked {\n            for (uint256 i; i != 16; ++i) {\n                outputs0[i] = _lazyShuffler0.next(_random());\n            }\n            for (uint256 i; i != 32; ++i) {\n                assertEq(_lazyShuffler1.finished(), false);\n                outputs1[i] = _lazyShuffler1.next(_random());\n            }\n            assertEq(_lazyShuffler0.finished(), true);\n            assertEq(_lazyShuffler1.finished(), true);\n            LibSort.sort(outputs0);\n            LibSort.sort(outputs1);\n            for (uint256 i; i != 16; ++i) {\n                assertEq(outputs0[i], i);\n            }\n            for (uint256 i; i != 32; ++i) {\n                assertEq(outputs1[i], i);\n            }\n        }\n    }\n\n    function testLazyShufflerGet() public {\n        _lazyShuffler0.initialize(16);\n        _lazyShuffler1.initialize(32);\n        uint256[] memory outputs0 = new uint256[](16);\n        uint256[] memory outputs1 = new uint256[](32);\n        unchecked {\n            for (uint256 i; i != 16; ++i) {\n                assertEq(_lazyShuffler0.get(i), i);\n            }\n            for (uint256 i; i != 16; ++i) {\n                outputs0[i] = _lazyShuffler0.next(_random());\n            }\n            for (uint256 i; i != 32; ++i) {\n                assertEq(_lazyShuffler1.get(i), i);\n            }\n            for (uint256 i; i != 32; ++i) {\n                assertEq(_lazyShuffler1.finished(), false);\n                outputs1[i] = _lazyShuffler1.next(_random());\n            }\n            for (uint256 i; i != 16; ++i) {\n                assertEq(_lazyShuffler0.get(i), outputs0[i]);\n            }\n            for (uint256 i; i != 32; ++i) {\n                assertEq(_lazyShuffler1.get(i), outputs1[i]);\n            }\n        }\n    }\n\n    function testLazyShufflerGetOutOfBoundsReverts(uint256 n, uint256 i) public {\n        n = _bound(n, 1, 2 ** 32 - 2);\n        _lazyShuffler0.initialize(n);\n        i = _bound(i, 1, 2 ** 32 + 1);\n        if (i < n) {\n            assertEq(this.lazyShuffler0Get(i), i);\n        } else {\n            vm.expectRevert(LibPRNG.LazyShufflerGetOutOfBounds.selector);\n            this.lazyShuffler0Get(i);\n        }\n    }\n\n    function testLazyShufflerRestart() public {\n        uint256[] memory outputs0 = new uint256[](32);\n        uint256[] memory outputs1 = new uint256[](32);\n        _lazyShuffler0.initialize(32);\n        assertEq(_lazyShuffler0.numShuffled(), 0);\n        assertEq(_lazyShuffler0.length(), 32);\n        for (uint256 i; i != 32; ++i) {\n            assertEq(_lazyShuffler0.numShuffled(), i);\n            outputs0[i] = _lazyShuffler0.next(_random());\n        }\n        assertEq(_lazyShuffler0.numShuffled(), 32);\n        _lazyShuffler0.restart();\n        assertEq(_lazyShuffler0.numShuffled(), 0);\n        assertEq(_lazyShuffler0.length(), 32);\n        for (uint256 i; i != 32; ++i) {\n            outputs1[i] = _lazyShuffler0.next(_random());\n        }\n        assertTrue(keccak256(abi.encode(outputs0)) != keccak256(abi.encode(outputs1)));\n        LibSort.sort(outputs0);\n        LibSort.sort(outputs1);\n        for (uint256 i; i != 32; ++i) {\n            assertEq(outputs0[i], i);\n            assertEq(outputs1[i], i);\n        }\n    }\n\n    function testLazyShufflerRevertsOnInitWithInvalidLength(uint256 n) public {\n        n = _bound(n, 0, 2 ** 32 + 1);\n        if (n == 0 || n >= 2 ** 32 - 1) {\n            vm.expectRevert(LibPRNG.InvalidInitialLazyShufflerLength.selector);\n        }\n        this.lazyShufflerInitialize(n);\n    }\n\n    function testLazyShufflerRevertsOnGrowWithInvalidLength(uint256 n, uint256 nGrow) public {\n        n = _bound(n, 1, 2 ** 32 - 2);\n        this.lazyShufflerInitialize(n);\n        nGrow = _bound(n, 0, 2 ** 32 - 2);\n        if (nGrow < n) {\n            vm.expectRevert(LibPRNG.InvalidNewLazyShufflerLength.selector);\n        }\n        this.lazyShufflerGrow(n);\n    }\n\n    function testLazyShufflerRevertsOnDoubleInit() public {\n        this.lazyShufflerInitialize(1);\n        vm.expectRevert(LibPRNG.LazyShufflerAlreadyInitialized.selector);\n        this.lazyShufflerInitialize(2);\n    }\n\n    function testLazyShufflerRevertsOnZeroLengthNext() public {\n        vm.expectRevert(LibPRNG.LazyShuffleFinished.selector);\n        lazyShufflerNext(_random());\n    }\n\n    function testLazyShufflerRevertsOnFinshedNext(uint256 n) public {\n        n = _bound(n, 1, 3);\n        _lazyShuffler0.initialize(n);\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                lazyShufflerNext(_random());\n            }\n        }\n        vm.expectRevert(LibPRNG.LazyShuffleFinished.selector);\n        lazyShufflerNext(_random());\n    }\n\n    function lazyShufflerInitialize(uint256 n) public {\n        _lazyShuffler0.initialize(n);\n    }\n\n    function lazyShufflerGrow(uint256 n) public {\n        _lazyShuffler0.grow(n);\n    }\n\n    function lazyShufflerNext(uint256 randomness) public returns (uint256) {\n        return _lazyShuffler0.next(randomness);\n    }\n\n    function lazyShuffler0Get(uint256 i) public view returns (uint256) {\n        return _lazyShuffler0.get(i);\n    }\n\n    function lazyShuffler1Get(uint256 i) public view returns (uint256) {\n        return _lazyShuffler1.get(i);\n    }\n}\n",
        "contractname": "LibPRNG.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Initializable mixin for the upgradeable contracts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Initializable.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/utils/Initializable.sol)\nabstract contract Initializable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The contract is already initialized.\n    error InvalidInitialization();\n\n    /// @dev The contract is not initializing.\n    error NotInitializing();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Triggered when the contract has been initialized.\n    event Initialized(uint64 version);\n\n    /// @dev `keccak256(bytes(\"Initialized(uint64)\"))`.\n    bytes32 private constant _INTIALIZED_EVENT_SIGNATURE =\n        0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The default initializable slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_INITIALIZABLE_SLOT\")))))`.\n    ///\n    /// Bits Layout:\n    /// - [0]     `initializing`\n    /// - [1..64] `initializedVersion`\n    bytes32 private constant _INITIALIZABLE_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffbf601132;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Override to return a custom storage slot if required.\n    function _initializableSlot() internal pure virtual returns (bytes32) {\n        return _INITIALIZABLE_SLOT;\n    }\n\n    /// @dev Guards an initializer function so that it can be invoked at most once.\n    ///\n    /// You can guard a function with `onlyInitializing` such that it can be called\n    /// through a function guarded with `initializer`.\n    ///\n    /// This is similar to `reinitializer(1)`, except that in the context of a constructor,\n    /// an `initializer` guarded function can be invoked multiple times.\n    /// This can be useful during testing and is not expected to be used in production.\n    ///\n    /// Emits an {Initialized} event.\n    modifier initializer() virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            // Set `initializing` to 1, `initializedVersion` to 1.\n            sstore(s, 3)\n            // If `!(initializing == 0 && initializedVersion == 0)`.\n            if i {\n                // If `!(address(this).code.length == 0 && initializedVersion == 1)`.\n                if iszero(lt(extcodesize(address()), eq(shr(1, i), 1))) {\n                    mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                    revert(0x1c, 0x04)\n                }\n                s := shl(shl(255, i), s) // Skip initializing if `initializing == 1`.\n            }\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if s {\n                // Set `initializing` to 0, `initializedVersion` to 1.\n                sstore(s, 2)\n                // Emit the {Initialized} event.\n                mstore(0x20, 1)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }\n\n    /// @dev Guards an reinitialzer function so that it can be invoked at most once.\n    ///\n    /// You can guard a function with `onlyInitializing` such that it can be called\n    /// through a function guarded with `reinitializer`.\n    ///\n    /// Emits an {Initialized} event.\n    modifier reinitializer(uint64 version) virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := and(version, 0xffffffffffffffff) // Clean upper bits.\n            let i := sload(s)\n            // If `initializing == 1 || initializedVersion >= version`.\n            if iszero(lt(and(i, 1), lt(shr(1, i), version))) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            // Set `initializing` to 1, `initializedVersion` to `version`.\n            sstore(s, or(1, shl(1, version)))\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Set `initializing` to 0, `initializedVersion` to `version`.\n            sstore(s, shl(1, version))\n            // Emit the {Initialized} event.\n            mstore(0x20, version)\n            log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n        }\n    }\n\n    /// @dev Guards a function such that it can only be called in the scope\n    /// of a function guarded with `initializer` or `reinitializer`.\n    modifier onlyInitializing() virtual {\n        _checkInitializing();\n        _;\n    }\n\n    /// @dev Reverts if the contract is not initializing.\n    function _checkInitializing() internal view virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(1, sload(s))) {\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Locks any future initializations by setting the initialized version to `2**64 - 1`.\n    ///\n    /// Calling this in the constructor will prevent the contract from being initialized\n    /// or reinitialized. It is recommended to use this to lock implementation contracts\n    /// that are designed to be called through proxies.\n    ///\n    /// Emits an {Initialized} event the first time it is successfully called.\n    function _disableInitializers() internal virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            if and(i, 1) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            let uint64max := shr(192, s) // Computed to save bytecode.\n            if iszero(eq(shr(1, i), uint64max)) {\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\n                sstore(s, shl(1, uint64max))\n                // Emit the {Initialized} event.\n                mstore(0x20, uint64max)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }\n\n    /// @dev Returns the highest version that has been initialized.\n    function _getInitializedVersion() internal view virtual returns (uint64 version) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := shr(1, sload(s))\n        }\n    }\n\n    /// @dev Returns whether the contract is currently initializing.\n    function _isInitializing() internal view virtual returns (bool result) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, sload(s))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockInitializable, Initializable} from \"./utils/mocks/MockInitializable.sol\";\n\ncontract InitializableTest is SoladyTest {\n    event Initialized(uint64 version);\n\n    MockInitializable m;\n\n    function setUp() public {\n        MockInitializable.Args memory a;\n        m = new MockInitializable(a);\n    }\n\n    function _args() internal returns (MockInitializable.Args memory a) {\n        a.x = _random();\n        a.version = uint64(_bound(_random(), 1, type(uint64).max));\n        a.checkOnlyDuringInitializing = _random() & 1 == 0;\n        a.recurse = _random() & 1 == 0;\n    }\n\n    function _expectEmitInitialized(uint64 version) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Initialized(version);\n    }\n\n    function testInitialize() public {\n        MockInitializable.Args memory a;\n        a.x = 123;\n        m.initialize(a);\n        assertEq(m.x(), a.x);\n        _checkVersion(1);\n    }\n\n    function _checkVersion(uint64 version) internal {\n        assertEq(m.version(), version);\n        assertFalse(m.isInitializing());\n    }\n\n    function testInitializeReinititalize(uint256) public {\n        MockInitializable.Args memory a = _args();\n\n        if (a.recurse) {\n            vm.expectRevert(Initializable.InvalidInitialization.selector);\n            if (_random() & 1 == 0) {\n                m.initialize(a);\n            } else {\n                m.reinitialize(a);\n            }\n            return;\n        }\n\n        if (_random() & 1 == 0) {\n            _expectEmitInitialized(1);\n            m.initialize(a);\n            a.version = 1;\n        } else {\n            _expectEmitInitialized(a.version);\n            m.reinitialize(a);\n        }\n        assertEq(m.x(), a.x);\n        _checkVersion(a.version);\n\n        if (_random() & 1 == 0) {\n            vm.expectRevert(Initializable.InvalidInitialization.selector);\n            m.initialize(a);\n        }\n        if (_random() & 1 == 0) {\n            vm.expectRevert(Initializable.InvalidInitialization.selector);\n            m.reinitialize(a);\n        }\n        if (_random() & 1 == 0) {\n            a.version = m.version();\n            uint64 newVersion = uint64(_random());\n            if (newVersion > a.version) {\n                a.version = newVersion;\n                m.reinitialize(a);\n                _checkVersion(a.version);\n            }\n        }\n    }\n\n    function testOnlyInitializing() public {\n        vm.expectRevert(Initializable.NotInitializing.selector);\n        m.onlyDuringInitializing();\n    }\n\n    function testDisableInitializers() public {\n        _expectEmitInitialized(type(uint64).max);\n        m.disableInitializers();\n        _checkVersion(type(uint64).max);\n        m.disableInitializers();\n        _checkVersion(type(uint64).max);\n\n        MockInitializable.Args memory a;\n        vm.expectRevert(Initializable.InvalidInitialization.selector);\n        m.initialize(a);\n        vm.expectRevert(Initializable.InvalidInitialization.selector);\n        m.reinitialize(a);\n    }\n\n    function testInitializableConstructor() public {\n        MockInitializable.Args memory a;\n        a.initializeMulti = true;\n        m = new MockInitializable(a);\n        _checkVersion(1);\n\n        vm.expectRevert(Initializable.InvalidInitialization.selector);\n        m.initialize(a);\n        a.version = 2;\n        m.reinitialize(a);\n        _checkVersion(2);\n\n        a.disableInitializers = true;\n        _expectEmitInitialized(type(uint64).max);\n        m = new MockInitializable(a);\n        _checkVersion(type(uint64).max);\n        vm.expectRevert(Initializable.InvalidInitialization.selector);\n        m.initialize(a);\n        vm.expectRevert(Initializable.InvalidInitialization.selector);\n        m.reinitialize(a);\n    }\n\n    function testInitializeInititalizerTrick(\n        bool initializing,\n        uint64 initializedVersion,\n        uint16 codeSize\n    ) public {\n        bool isTopLevelCall = !initializing;\n        bool initialSetup = initializedVersion == 0 && isTopLevelCall;\n        bool construction = initializedVersion == 1 && codeSize == 0;\n        bool expected = !initialSetup && !construction;\n        bool computed;\n        uint256 i;\n        /// @solidity memory-safe-assembly\n        assembly {\n            i := or(initializing, shl(1, initializedVersion))\n            if i { if iszero(lt(codeSize, eq(shr(1, i), 1))) { computed := 1 } }\n        }\n        assertEq(computed, expected);\n    }\n\n    function testInitializeReinititalizerTrick(\n        bool initializing,\n        uint64 initializedVersion,\n        uint64 version\n    ) public {\n        bool expected = initializing == true || initializedVersion >= version;\n        bool computed;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := or(initializing, shl(1, initializedVersion))\n            computed := iszero(lt(and(i, 1), lt(shr(1, i), version)))\n        }\n        assertEq(computed, expected);\n    }\n}\n",
        "contractname": "Initializable.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract LibStringTest is SoladyTest {\n    function testToStringZero() public {\n        assertEq(LibString.toString(uint256(0)), \"0\");\n    }\n\n    function testToStringPositiveNumber() public {\n        assertEq(LibString.toString(uint256(4132)), \"4132\");\n    }\n\n    function testToStringUint256Max() public {\n        assertEq(\n            LibString.toString(type(uint256).max),\n            \"115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n        );\n    }\n\n    function testToStringZeroBrutalized() public brutalizeMemory {\n        string memory s0 = LibString.toString(uint256(0));\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        string memory s1 = LibString.toString(uint256(0));\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        assertEq(s0, \"0\");\n        assertEq(s1, \"0\");\n    }\n\n    function testToStringPositiveNumberBrutalized() public brutalizeMemory {\n        string memory s0 = LibString.toString(uint256(4132));\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        string memory s1 = LibString.toString(uint256(4132));\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        assertEq(s0, \"4132\");\n        assertEq(s1, \"4132\");\n    }\n\n    function testToStringUint256MaxBrutalized() public brutalizeMemory {\n        string memory s0 = LibString.toString(type(uint256).max);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        string memory s1 = LibString.toString(type(uint256).max);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(0x40), not(0))\n            mstore(0x40, add(mload(0x40), 0x20))\n        }\n        assertEq(\n            s0, \"115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n        );\n        assertEq(\n            s1, \"115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n        );\n    }\n\n    function testToStringZeroRightPadded(uint256 x) public view brutalizeMemory {\n        _checkMemory(LibString.toString(x));\n    }\n\n    function testToStringSignedDifferential(int256 x) public brutalizeMemory {\n        assertEq(LibString.toString(x), _toStringSignedOriginal(x));\n    }\n\n    function testToStringSignedMemory(int256 x) public view brutalizeMemory {\n        _misalignFreeMemoryPointer();\n        uint256 freeMemoryPointer;\n        /// @solidity memory-safe-assembly\n        assembly {\n            freeMemoryPointer := mload(0x40)\n        }\n        string memory str = LibString.toString(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(str, freeMemoryPointer) { revert(0, 0) }\n        }\n        _checkMemory(str);\n    }\n\n    function testToStringSignedGas() public pure {\n        for (int256 x = -10; x < 10; ++x) {\n            LibString.toString(x);\n        }\n    }\n\n    function testToStringSignedOriginalGas() public pure {\n        for (int256 x = -10; x < 10; ++x) {\n            _toStringSignedOriginal(x);\n        }\n    }\n\n    function _toStringSignedOriginal(int256 x) internal pure returns (string memory) {\n        unchecked {\n            return x >= 0\n                ? LibString.toString(uint256(x))\n                : string(abi.encodePacked(\"-\", LibString.toString(uint256(-x))));\n        }\n    }\n\n    function testToHexStringZero() public {\n        assertEq(LibString.toHexString(0), \"0x00\");\n    }\n\n    function testToHexStringPositiveNumber() public {\n        assertEq(LibString.toHexString(0x4132), \"0x4132\");\n    }\n\n    function testToHexStringUint256Max() public {\n        assertEq(\n            LibString.toHexString(type(uint256).max),\n            \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        );\n    }\n\n    function testToHexStringFixedLengthPositiveNumberLong() public {\n        assertEq(\n            LibString.toHexString(0x4132, 32),\n            \"0x0000000000000000000000000000000000000000000000000000000000004132\"\n        );\n    }\n\n    function testToHexStringFixedLengthPositiveNumberShort() public {\n        assertEq(LibString.toHexString(0x4132, 2), \"0x4132\");\n    }\n\n    function testToHexStringZeroRightPadded(uint256 x) public pure {\n        _checkMemory(LibString.toHexString(x));\n    }\n\n    function testToHexStringFixedLengthInsufficientLength() public {\n        vm.expectRevert(LibString.HexLengthInsufficient.selector);\n        LibString.toHexString(0x4132, 1);\n    }\n\n    function testToHexStringFixedLengthUint256Max() public {\n        assertEq(\n            LibString.toHexString(type(uint256).max, 32),\n            \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        );\n    }\n\n    function testToHexStringFixedLengthZeroRightPadded(uint256 x, uint256 randomness) public pure {\n        uint256 minLength = (bytes(LibString.toHexString(x)).length - 2) * 2;\n        uint256 length = (randomness % 32) + minLength;\n        _checkMemory(LibString.toHexString(x, length));\n    }\n\n    function testFromAddressToHexString() public {\n        assertEq(\n            LibString.toHexString(0xA9036907dCcae6a1E0033479B12E837e5cF5a02f),\n            \"0xa9036907dccae6a1e0033479b12e837e5cf5a02f\"\n        );\n    }\n\n    function testAddressToHexStringZeroRightPadded(address x) public pure {\n        _checkMemory(LibString.toHexString(x));\n    }\n\n    function testFromAddressToHexStringWithLeadingZeros() public {\n        assertEq(\n            LibString.toHexString(0x0000E0Ca771e21bD00057F54A68C30D400000000),\n            \"0x0000e0ca771e21bd00057f54a68c30d400000000\"\n        );\n    }\n\n    function testToMinimalHexStringZero() public {\n        assertEq(LibString.toMinimalHexString(0), \"0x0\");\n    }\n\n    function testToMinimalHexStringPositiveNumber() public {\n        assertEq(LibString.toMinimalHexString(0x54132), \"0x54132\");\n        assertEq(LibString.toMinimalHexString(0x4132), \"0x4132\");\n        assertEq(LibString.toMinimalHexString(0x0123), \"0x123\");\n        assertEq(LibString.toMinimalHexString(0x12), \"0x12\");\n        assertEq(LibString.toMinimalHexString(0x1), \"0x1\");\n    }\n\n    function testToMinimalHexStringUint256Max() public {\n        assertEq(\n            LibString.toMinimalHexString(type(uint256).max),\n            \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        );\n    }\n\n    function testToMinimalHexStringZeroRightPadded(uint256 x) public pure {\n        _checkMemory(LibString.toMinimalHexString(x));\n    }\n\n    function testToMinimalHexStringNoPrefixZero() public {\n        assertEq(LibString.toMinimalHexStringNoPrefix(0), \"0\");\n    }\n\n    function testToMinimalHexStringNoPrefixPositiveNumber() public {\n        assertEq(LibString.toMinimalHexStringNoPrefix(0x54132), \"54132\");\n        assertEq(LibString.toMinimalHexStringNoPrefix(0x4132), \"4132\");\n        assertEq(LibString.toMinimalHexStringNoPrefix(0x0123), \"123\");\n        assertEq(LibString.toMinimalHexStringNoPrefix(0x12), \"12\");\n        assertEq(LibString.toMinimalHexStringNoPrefix(0x1), \"1\");\n    }\n\n    function testToMinimalHexStringNoPrefixUint256Max() public {\n        assertEq(\n            LibString.toMinimalHexStringNoPrefix(type(uint256).max),\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        );\n    }\n\n    function testToMinimalHexStringNoPrefixZeroRightPadded(uint256 x) public pure {\n        _checkMemory(LibString.toMinimalHexStringNoPrefix(x));\n    }\n\n    function testFromAddressToHexStringChecksummed() public {\n        // All caps.\n        assertEq(\n            LibString.toHexStringChecksummed(0x52908400098527886E0F7030069857D2E4169EE7),\n            \"0x52908400098527886E0F7030069857D2E4169EE7\"\n        );\n        assertEq(\n            LibString.toHexStringChecksummed(0x8617E340B3D01FA5F11F306F4090FD50E238070D),\n            \"0x8617E340B3D01FA5F11F306F4090FD50E238070D\"\n        );\n        // All lower.\n        assertEq(\n            LibString.toHexStringChecksummed(0xde709f2102306220921060314715629080e2fb77),\n            \"0xde709f2102306220921060314715629080e2fb77\"\n        );\n        assertEq(\n            LibString.toHexStringChecksummed(0x27b1fdb04752bbc536007a920d24acb045561c26),\n            \"0x27b1fdb04752bbc536007a920d24acb045561c26\"\n        );\n        // Normal.\n        assertEq(\n            LibString.toHexStringChecksummed(0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed),\n            \"0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed\"\n        );\n        assertEq(\n            LibString.toHexStringChecksummed(0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359),\n            \"0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359\"\n        );\n        assertEq(\n            LibString.toHexStringChecksummed(0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB),\n            \"0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB\"\n        );\n        assertEq(\n            LibString.toHexStringChecksummed(0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb),\n            \"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb\"\n        );\n    }\n\n    function testFromAddressToHexStringChecksummedDifferential(uint256 randomness)\n        public\n        brutalizeMemory\n    {\n        address r;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := randomness\n        }\n        string memory expectedResult = LibString.toHexString(r);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := add(expectedResult, 0x22)\n            let hashed := keccak256(o, 40)\n            // forgefmt: disable-next-item\n            for { let i := 0 } iszero(eq(i, 20)) { i := add(i, 1) } {\n                let temp := byte(i, hashed)\n                let p := add(o, add(i, i))\n                let c0 := byte(0, mload(p))\n                let c1 := byte(1, mload(p))\n                if and(gt(c1, 58), gt(and(temp, 15), 7)) {\n                    mstore8(add(p, 1), sub(c1, 32))    \n                }\n                if and(gt(c0, 58), gt(shr(4, temp), 7)) {\n                    mstore8(p, sub(c0, 32))    \n                }\n            }\n        }\n        string memory checksummed = LibString.toHexStringChecksummed(r);\n        _checkMemory(checksummed);\n        assertEq(checksummed, expectedResult);\n    }\n\n    function testHexStringNoPrefixVariants(uint256 x, uint256 randomness) public brutalizeMemory {\n        string memory noPrefix = LibString.toHexStringNoPrefix(x);\n        _checkMemory(noPrefix);\n        string memory expectedResult = LibString.concat(\"0x\", noPrefix);\n        string memory withPrefix = LibString.toHexString(x);\n        _checkMemory(withPrefix);\n        assertEq(withPrefix, expectedResult);\n\n        uint256 length;\n        /// @solidity memory-safe-assembly\n        assembly {\n            length := add(shr(1, mload(noPrefix)), and(randomness, 63))\n        }\n        _misalignFreeMemoryPointer();\n        noPrefix = LibString.toHexStringNoPrefix(x, length);\n        _checkMemory(noPrefix);\n        expectedResult = LibString.concat(\"0x\", noPrefix);\n        _misalignFreeMemoryPointer();\n        withPrefix = LibString.toHexString(x, length);\n        _checkMemory(withPrefix);\n        assertEq(withPrefix, expectedResult);\n\n        address xAddress;\n        /// @solidity memory-safe-assembly\n        assembly {\n            xAddress := x\n        }\n        _misalignFreeMemoryPointer();\n        noPrefix = LibString.toHexStringNoPrefix(xAddress);\n        _checkMemory(noPrefix);\n        expectedResult = LibString.concat(\"0x\", noPrefix);\n        _misalignFreeMemoryPointer();\n        withPrefix = LibString.toHexString(xAddress);\n        _checkMemory(withPrefix);\n        assertEq(withPrefix, expectedResult);\n    }\n\n    function testBytesToHexStringNoPrefix() public {\n        assertEq(LibString.toHexStringNoPrefix(\"\"), \"\");\n        assertEq(LibString.toHexStringNoPrefix(\"A\"), \"41\");\n        assertEq(\n            LibString.toHexStringNoPrefix(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),\n            \"4142434445464748494a4b4c4d4e4f505152535455565758595a\"\n        );\n    }\n\n    function testBytesToHexStringNoPrefix(bytes memory raw) public brutalizeMemory {\n        string memory converted = LibString.toHexStringNoPrefix(raw);\n        _checkMemory(converted);\n        unchecked {\n            bytes memory hexChars = \"0123456789abcdef\";\n            for (uint256 i; i != raw.length; ++i) {\n                uint256 t = uint8(bytes1(raw[i]));\n                assertTrue(hexChars[t & 15] == bytes(converted)[i * 2 + 1]);\n                assertTrue(hexChars[(t >> 4) & 15] == bytes(converted)[i * 2]);\n            }\n        }\n    }\n\n    function testBytesToHexString() public {\n        assertEq(LibString.toHexString(\"\"), \"0x\");\n        assertEq(LibString.toHexString(\"A\"), \"0x41\");\n        assertEq(\n            LibString.toHexString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),\n            \"0x4142434445464748494a4b4c4d4e4f505152535455565758595a\"\n        );\n    }\n\n    function testBytesToHexString(bytes memory raw) public brutalizeMemory {\n        string memory converted = LibString.toHexString(raw);\n        _checkMemory(converted);\n        unchecked {\n            bytes memory hexChars = \"0123456789abcdef\";\n            for (uint256 i; i != raw.length; ++i) {\n                uint256 t = uint8(bytes1(raw[i]));\n                assertTrue(hexChars[t & 15] == bytes(converted)[i * 2 + 1 + 2]);\n                assertTrue(hexChars[(t >> 4) & 15] == bytes(converted)[i * 2 + 2]);\n            }\n        }\n    }\n\n    function testStringIs7BitASCII() public {\n        bytes memory raw = new bytes(1);\n        for (uint256 i; i < 256; ++i) {\n            raw[0] = bytes1(uint8(i));\n            assertEq(LibString.is7BitASCII(string(raw)), i < 128);\n            assertEq(LibString.is7BitASCII(string(raw)), _is7BitASCIIOriginal(string(raw)));\n        }\n    }\n\n    function testStringIs7BitASCIIDifferential(bytes memory raw) public brutalizeMemory {\n        string memory s = string(raw);\n        bytes32 hashBefore = keccak256(raw);\n        assertEq(LibString.is7BitASCII(s), _is7BitASCIIOriginal(s));\n        assertEq(keccak256(raw), hashBefore);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(raw, add(0x20, mload(raw))), hashBefore)\n        }\n        assertEq(LibString.is7BitASCII(s), _is7BitASCIIOriginal(s));\n        assertEq(keccak256(raw), hashBefore);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(add(raw, add(0x20, mload(raw)))), hashBefore)) { revert(0, 0) }\n        }\n    }\n\n    function testStringRuneCountDifferential(string memory s) public {\n        assertEq(LibString.runeCount(s), _runeCountOriginal(s));\n    }\n\n    function testStringRuneCount() public {\n        unchecked {\n            string memory runes = new string(256);\n            for (uint256 i; i < 256; ++i) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(add(add(runes, 0x20), i), i)\n                }\n            }\n            for (uint256 i; i < 256; ++i) {\n                string memory s = _generateString(runes);\n                testStringRuneCountDifferential(s);\n            }\n        }\n    }\n\n    function testStringReplaceShort() public {\n        assertEq(LibString.replace(\"abc\", \"\", \"_@\"), \"_@a_@b_@c_@\");\n        assertEq(LibString.replace(\"abc\", \"a\", \"_\"), \"_bc\");\n        assertEq(LibString.replace(\"abc\", \"b\", \"_\"), \"a_c\");\n        assertEq(LibString.replace(\"abc\", \"c\", \"_\"), \"ab_\");\n        assertEq(LibString.replace(\"abc\", \"ab\", \"_\"), \"_c\");\n        assertEq(LibString.replace(\"abc\", \"bc\", \"_\"), \"a_\");\n        assertEq(LibString.replace(\"abc\", \"ac\", \"_\"), \"abc\");\n        assertEq(LibString.replace(\"abc\", \"a\", \"\"), \"bc\");\n        assertEq(LibString.replace(\"abc\", \"\", \"\"), \"abc\");\n        assertEq(LibString.replace(\"abc\", \"d\", \"x\"), \"abc\");\n    }\n\n    function testStringReplaceMedium() public {\n        // forgefmt: disable-next-item\n        string memory subject = \"70708741044725766535585242414884609539555049888764130733849700923779599488691391677696419266840\";\n        string memory search = \"46095395550498887641307338497009\";\n        string memory replacement = \"320807383223517906783031356692334377159141\";\n        // forgefmt: disable-next-item\n        string memory expectedResult = \"707087410447257665355852424148832080738322351790678303135669233437715914123779599488691391677696419266840\";\n        assertEq(LibString.replace(subject, search, replacement), expectedResult);\n    }\n\n    function testStringReplaceLong() public {\n        // forgefmt: disable-next-item\n        string memory subject = \"01234567890123456789012345678901_search_search_search_search_search_search_23456789012345678901234567890123456789_search_search_search_search_search_search\";\n        string memory search = \"search_search_search_search_search_search\";\n        string memory replacement = \"REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT\";\n        // forgefmt: disable-next-item\n        string memory expectedResult = \"01234567890123456789012345678901_REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT_23456789012345678901234567890123456789_REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT_REPLACEMENT\";\n        assertEq(LibString.replace(subject, search, replacement), expectedResult);\n    }\n\n    function testStringReplace(uint256) public brutalizeMemory {\n        string memory filler = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n        string memory replacement = _generateString(\"0123456790_-+/=|{}<>!\");\n        if (bytes(search).length != 0) {\n            string memory subject;\n            subject = LibString.concat(subject, filler);\n            subject = LibString.concat(subject, search);\n            subject = LibString.concat(subject, filler);\n            subject = LibString.concat(subject, search);\n            subject = LibString.concat(subject, filler);\n            _misalignFreeMemoryPointer();\n            string memory expectedResult;\n            expectedResult = LibString.concat(expectedResult, filler);\n            expectedResult = LibString.concat(expectedResult, replacement);\n            expectedResult = LibString.concat(expectedResult, filler);\n            expectedResult = LibString.concat(expectedResult, replacement);\n            expectedResult = LibString.concat(expectedResult, filler);\n            _misalignFreeMemoryPointer();\n            string memory replaced = LibString.replace(subject, search, replacement);\n            _checkMemory(replaced);\n            assertEq(replaced, expectedResult);\n        } else {\n            string memory expectedResult;\n            expectedResult = LibString.concat(expectedResult, replacement);\n            expectedResult = LibString.concat(expectedResult, \" \");\n            expectedResult = LibString.concat(expectedResult, replacement);\n            expectedResult = LibString.concat(expectedResult, \" \");\n            expectedResult = LibString.concat(expectedResult, replacement);\n            expectedResult = LibString.concat(expectedResult, \" \");\n            expectedResult = LibString.concat(expectedResult, replacement);\n            string memory replaced = LibString.replace(\"   \", search, replacement);\n            assertEq(replaced, expectedResult);\n        }\n    }\n\n    function testStringIndexOf(uint256) public brutalizeMemory {\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        string memory subject = string(bytes.concat(bytes(filler0), bytes(search), bytes(filler1)));\n\n        uint256 from = _generateFrom(subject);\n\n        if (bytes(search).length == 0) {\n            if (from > bytes(subject).length) {\n                assertEq(LibString.indexOf(subject, search, from), bytes(subject).length);\n            } else {\n                assertEq(LibString.indexOf(subject, search, from), from);\n            }\n        } else {\n            if (from > bytes(filler0).length) {\n                assertEq(LibString.indexOf(subject, search, from), LibString.NOT_FOUND);\n            } else {\n                assertEq(LibString.indexOf(subject, search, from), bytes(filler0).length);\n            }\n        }\n    }\n\n    function testStringIndexOf() public {\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.indexOf(subject, \"\"), 0);\n        assertEq(LibString.indexOf(subject, \"\", 16), 16);\n        assertEq(LibString.indexOf(subject, \"\", 17), 17);\n        assertEq(LibString.indexOf(subject, \"\", 52), 52);\n        assertEq(LibString.indexOf(subject, \"\", 53), 52);\n        assertEq(LibString.indexOf(subject, \"\", 555), 52);\n        assertEq(LibString.indexOf(subject, \"abc\", 0), 0);\n        assertEq(LibString.indexOf(subject, \"abc\", 1), LibString.NOT_FOUND);\n        assertEq(LibString.indexOf(subject, \"bcd\"), 1);\n        assertEq(LibString.indexOf(subject, \"XYZ\"), 49);\n        assertEq(LibString.indexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW\"), 16);\n        assertEq(LibString.indexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"), 16);\n        assertEq(LibString.indexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 16), 16);\n        assertEq(\n            LibString.indexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 17),\n            LibString.NOT_FOUND\n        );\n\n        assertEq(LibString.indexOf(\"abcabcabc\", \"abc\"), 0);\n        assertEq(LibString.indexOf(\"abcabcabc\", \"abc\", 1), 3);\n\n        assertEq(LibString.indexOf(\"a\", \"bcd\"), LibString.NOT_FOUND);\n        assertEq(LibString.indexOf(\"a\", \"bcd\", 0), LibString.NOT_FOUND);\n        assertEq(LibString.indexOf(\"accd\", \"bcd\"), LibString.NOT_FOUND);\n        assertEq(LibString.indexOf(\"\", \"bcd\"), LibString.NOT_FOUND);\n    }\n\n    function testStringLastIndexOf(uint256) public brutalizeMemory {\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        string memory subject = string(bytes.concat(bytes(filler0), bytes(search), bytes(filler1)));\n\n        uint256 from = _generateFrom(subject);\n\n        if (bytes(search).length == 0) {\n            if (from > bytes(subject).length) {\n                assertEq(LibString.lastIndexOf(subject, search, from), bytes(subject).length);\n            } else {\n                assertEq(LibString.lastIndexOf(subject, search, from), from);\n            }\n        } else {\n            if (from < bytes(filler0).length) {\n                assertEq(LibString.lastIndexOf(subject, search, from), LibString.NOT_FOUND);\n            } else {\n                assertEq(LibString.lastIndexOf(subject, search, from), bytes(filler0).length);\n            }\n        }\n    }\n\n    function testStringLastIndexOf() public {\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.lastIndexOf(subject, \"\", 0), 0);\n        assertEq(LibString.lastIndexOf(subject, \"\", 16), 16);\n        assertEq(LibString.lastIndexOf(subject, \"\", 17), 17);\n        assertEq(LibString.lastIndexOf(subject, \"\", 52), 52);\n        assertEq(LibString.lastIndexOf(subject, \"\", 53), 52);\n        assertEq(LibString.lastIndexOf(subject, \"\", 555), 52);\n        assertEq(LibString.lastIndexOf(subject, \"abc\"), 0);\n        assertEq(LibString.lastIndexOf(subject, \"abc\", 0), 0);\n        assertEq(LibString.lastIndexOf(subject, \"abc\", 1), 0);\n        assertEq(LibString.lastIndexOf(subject, \"abc\", 3), 0);\n        assertEq(LibString.lastIndexOf(subject, \"bcd\"), 1);\n        assertEq(LibString.lastIndexOf(subject, \"bcd\", 1), 1);\n        assertEq(LibString.lastIndexOf(subject, \"bcd\", 0), LibString.NOT_FOUND);\n        assertEq(LibString.lastIndexOf(subject, \"XYZ\"), 49);\n        assertEq(LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW\"), 16);\n        assertEq(LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"), 16);\n        assertEq(LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 52), 16);\n        assertEq(LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 51), 16);\n        assertEq(LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 16), 16);\n        assertEq(\n            LibString.lastIndexOf(subject, \"qrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", 15),\n            LibString.NOT_FOUND\n        );\n\n        assertEq(LibString.lastIndexOf(\"abcabcabc\", \"abc\"), 6);\n        assertEq(LibString.lastIndexOf(\"abcabcabc\", \"abc\", 5), 3);\n\n        assertEq(LibString.lastIndexOf(\"a\", \"bcd\"), LibString.NOT_FOUND);\n        assertEq(LibString.lastIndexOf(\"a\", \"bcd\", 0), LibString.NOT_FOUND);\n        assertEq(LibString.lastIndexOf(\"accd\", \"bcd\"), LibString.NOT_FOUND);\n        assertEq(LibString.lastIndexOf(\"\", \"bcd\"), LibString.NOT_FOUND);\n    }\n\n    function testContains() public {\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.contains(subject, \"a\"), true);\n        assertEq(LibString.contains(subject, \"abc\"), true);\n        assertEq(LibString.contains(subject, \"z\"), true);\n        assertEq(LibString.contains(subject, \"Z\"), true);\n        assertEq(LibString.contains(subject, \"az\"), false);\n        assertEq(LibString.contains(subject, \"aZ\"), false);\n        assertEq(LibString.contains(subject, \"Aa\"), false);\n        assertEq(LibString.contains(subject, \"Zz\"), false);\n        assertEq(LibString.contains(subject, \"abcZ\"), false);\n        assertEq(LibString.contains(subject, \"abcz\"), false);\n        assertEq(LibString.contains(subject, \"abcA\"), false);\n        assertEq(LibString.contains(subject, \"abcB\"), false);\n        assertEq(LibString.contains(subject, \"abcC\"), false);\n        assertEq(LibString.contains(subject, \"\"), true);\n        assertEq(LibString.contains(\"\", \"abc\"), false);\n        assertEq(LibString.contains(\"\", \"\"), true);\n    }\n\n    function testStringStartsWith(uint256) public brutalizeMemory {\n        string memory filler = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        if (bytes(search).length == 0) {\n            string memory subject = string(bytes.concat(bytes(filler), bytes(search)));\n            assertEq(LibString.startsWith(subject, search), true);\n        }\n\n        if (_random() & 1 == 1) {\n            string memory subject = string(bytes.concat(bytes(search), bytes(filler)));\n            assertEq(LibString.startsWith(subject, search), true);\n        }\n\n        if (bytes(filler).length != 0 && bytes(search).length != 0) {\n            string memory subject = string(bytes.concat(bytes(filler), bytes(search)));\n            assertEq(LibString.startsWith(subject, search), false);\n        }\n    }\n\n    function testStringStartsWith() public {\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.startsWith(subject, \"abc\"), true);\n        assertEq(LibString.startsWith(subject, \"abcdefghijklmnopqrstuvwxyzABCDEFG\"), true);\n        assertEq(LibString.startsWith(subject, \"bcd\"), false);\n        assertEq(LibString.startsWith(subject, \"bcdefghijklmnopqrstuvwxyzABCDEFGH\"), false);\n\n        assertEq(LibString.startsWith(\"\", \"\"), true);\n        assertEq(LibString.startsWith(\"bc\", \"\"), true);\n        assertEq(LibString.startsWith(\"bc\", \"bc\"), true);\n        assertEq(LibString.startsWith(\"bc\", \"abc\"), false);\n        assertEq(LibString.startsWith(\"\", \"abc\"), false);\n    }\n\n    function testStringEndsWith(uint256) public brutalizeMemory {\n        string memory filler = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        if (bytes(search).length == 0) {\n            string memory subject = string(bytes.concat(bytes(search), bytes(filler)));\n            assertEq(LibString.endsWith(subject, search), true);\n        }\n\n        if (_random() & 1 == 1) {\n            string memory subject = string(bytes.concat(bytes(filler), bytes(search)));\n            assertEq(LibString.endsWith(subject, search), true);\n        }\n\n        if (bytes(filler).length != 0 && bytes(search).length != 0) {\n            string memory subject = string(bytes.concat(bytes(search), bytes(filler)));\n            assertEq(LibString.endsWith(subject, search), false);\n        }\n    }\n\n    function testStringEndsWith() public {\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.endsWith(subject, \"XYZ\"), true);\n        assertEq(LibString.endsWith(subject, \"pqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"), true);\n        assertEq(LibString.endsWith(subject, \"WXY\"), false);\n        assertEq(LibString.endsWith(subject, \"opqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\"), false);\n\n        assertEq(LibString.endsWith(\"\", \"\"), true);\n        assertEq(LibString.endsWith(\"bc\", \"\"), true);\n        assertEq(LibString.endsWith(\"bc\", \"bc\"), true);\n        assertEq(LibString.endsWith(\"bc\", \"abc\"), false);\n        assertEq(LibString.endsWith(\"\", \"abc\"), false);\n    }\n\n    function testStringRepeat(string memory subject, uint256 times) public brutalizeMemory {\n        times = times % 8;\n        string memory repeated = LibString.repeat(subject, times);\n        string memory expectedResult = _repeatOriginal(subject, times);\n        _checkMemory(repeated);\n        assertEq(repeated, expectedResult);\n    }\n\n    function testStringRepeat() public {\n        assertEq(LibString.repeat(\"\", 0), \"\");\n        assertEq(LibString.repeat(\"\", 100), \"\");\n        assertEq(LibString.repeat(\"a\", 0), \"\");\n        assertEq(LibString.repeat(\"a\", 1), \"a\");\n        assertEq(LibString.repeat(\"a\", 3), \"aaa\");\n        assertEq(LibString.repeat(\"abc\", 0), \"\");\n        assertEq(LibString.repeat(\"abc\", 1), \"abc\");\n        assertEq(LibString.repeat(\"abc\", 3), \"abcabcabc\");\n        assertEq(LibString.repeat(\"efghi\", 3), \"efghiefghiefghi\");\n    }\n\n    function testStringRepeatOriginal() public {\n        assertEq(_repeatOriginal(\"\", 0), \"\");\n        assertEq(_repeatOriginal(\"\", 100), \"\");\n        assertEq(_repeatOriginal(\"a\", 0), \"\");\n        assertEq(_repeatOriginal(\"a\", 1), \"a\");\n        assertEq(_repeatOriginal(\"a\", 3), \"aaa\");\n        assertEq(_repeatOriginal(\"abc\", 0), \"\");\n        assertEq(_repeatOriginal(\"abc\", 1), \"abc\");\n        assertEq(_repeatOriginal(\"abc\", 3), \"abcabcabc\");\n        assertEq(_repeatOriginal(\"efghi\", 3), \"efghiefghiefghi\");\n    }\n\n    function testStringSlice(uint256) public brutalizeMemory {\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory expectedResult = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\n        string memory subject =\n            string(bytes.concat(bytes(filler0), bytes(expectedResult), bytes(filler1)));\n\n        uint256 start = bytes(filler0).length;\n        uint256 end = start + bytes(expectedResult).length;\n\n        _misalignFreeMemoryPointer();\n        string memory slice = LibString.slice(subject, start, end);\n        _checkMemory(slice);\n        assertEq(slice, expectedResult);\n    }\n\n    function testStringSlice() public {\n        assertEq(LibString.slice(\"\", 0, 1), \"\");\n        assertEq(LibString.slice(\"\", 1, 0), \"\");\n        assertEq(LibString.slice(\"\", 0, 0), \"\");\n        assertEq(LibString.slice(\"\", 0), \"\");\n        assertEq(LibString.slice(\"\", 1), \"\");\n\n        assertEq(LibString.slice(\"a\", 0), \"a\");\n        assertEq(LibString.slice(\"a\", 1), \"\");\n        assertEq(LibString.slice(\"a\", 3), \"\");\n\n        assertEq(LibString.slice(\"abc\", 0), \"abc\");\n        assertEq(LibString.slice(\"abc\", 1), \"bc\");\n        assertEq(LibString.slice(\"abc\", 1, 2), \"b\");\n        assertEq(LibString.slice(\"abc\", 3), \"\");\n\n        string memory subject = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        assertEq(LibString.slice(subject, 0), subject);\n        assertEq(LibString.slice(subject, 1), \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        assertEq(\n            LibString.slice(subject, 1, 51), \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\"\n        );\n        assertEq(LibString.slice(subject, 11, 41), \"lmnopqrstuvwxyzABCDEFGHIJKLMNO\");\n        assertEq(LibString.slice(subject, 21, 31), \"vwxyzABCDE\");\n        assertEq(LibString.slice(subject, 31, 21), \"\");\n    }\n\n    function testStringIndicesOf(uint256) public brutalizeMemory {\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory search = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        string memory subject;\n\n        unchecked {\n            uint256[] memory indices;\n            if (_random() & 1 == 0) {\n                subject = string(bytes.concat(bytes(filler0), bytes(search), bytes(filler1)));\n                indices = new uint256[](1);\n                indices[0] = bytes(filler0).length;\n            } else {\n                subject = string(bytes.concat(bytes(filler0), bytes(filler1)));\n                indices = new uint256[](0);\n            }\n\n            if (bytes(search).length == 0) {\n                indices = new uint256[](bytes(subject).length + 1);\n                for (uint256 i; i < indices.length; ++i) {\n                    indices[i] = i;\n                }\n            }\n            assertEq(LibString.indicesOf(subject, search), indices);\n        }\n    }\n\n    function testStringIndicesOf() public {\n        uint256[] memory indices;\n\n        indices = new uint256[](3);\n        indices[0] = 0;\n        indices[1] = 2;\n        indices[2] = 4;\n        assertEq(LibString.indicesOf(\"ababa\", \"a\"), indices);\n\n        indices = new uint256[](6);\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 2;\n        indices[3] = 3;\n        indices[4] = 4;\n        indices[5] = 5;\n        assertEq(LibString.indicesOf(\"ababa\", \"\"), indices);\n\n        indices = new uint256[](2);\n        indices[0] = 1;\n        indices[1] = 3;\n        assertEq(LibString.indicesOf(\"ababa\", \"b\"), indices);\n\n        indices = new uint256[](2);\n        indices[0] = 0;\n        indices[1] = 2;\n        assertEq(LibString.indicesOf(\"ababa\", \"ab\"), indices);\n\n        indices = new uint256[](2);\n        indices[0] = 1;\n        indices[1] = 3;\n        assertEq(LibString.indicesOf(\"ababa\", \"ba\"), indices);\n\n        indices = new uint256[](1);\n        indices[0] = 1;\n        assertEq(LibString.indicesOf(\"ababa\", \"bab\"), indices);\n\n        indices = new uint256[](1);\n        indices[0] = 0;\n        assertEq(LibString.indicesOf(\"ababa\", \"ababa\"), indices);\n\n        indices = new uint256[](1);\n        indices[0] = 0;\n        assertEq(LibString.indicesOf(\"\", \"\"), indices);\n\n        indices = new uint256[](0);\n        assertEq(LibString.indicesOf(\"ababa\", \"c\"), indices);\n\n        indices = new uint256[](0);\n        assertEq(LibString.indicesOf(\"ababab\", \"abababa\"), indices);\n    }\n\n    function testStringSplit(uint256) public brutalizeMemory {\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory delimiter = _generateString(\"abcdefghijklmnopqrstuvwxyz\");\n\n        string memory subject =\n            string(bytes.concat(bytes(filler0), bytes(delimiter), bytes(filler1)));\n\n        unchecked {\n            string[] memory elements;\n            if (bytes(delimiter).length == 0) {\n                elements = new string[](bytes(subject).length);\n                for (uint256 i; i < elements.length; ++i) {\n                    elements[i] = LibString.slice(subject, i, i + 1);\n                }\n            } else {\n                elements = new string[](2);\n                elements[0] = filler0;\n                elements[1] = filler1;\n            }\n            _misalignFreeMemoryPointer();\n            string[] memory split = LibString.split(subject, delimiter);\n            assertTrue(_stringArraysAreSame(split, elements));\n            for (uint256 i; i < split.length; ++i) {\n                _checkMemory(split[i]);\n            }\n        }\n    }\n\n    function testStringSplit() public {\n        string[] memory elements;\n\n        elements = new string[](4);\n        elements[0] = \"\";\n        elements[1] = \"b\";\n        elements[2] = \"b\";\n        elements[3] = \"\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"ababa\", \"a\"), elements));\n\n        elements = new string[](3);\n        elements[0] = \"a\";\n        elements[1] = \"a\";\n        elements[2] = \"a\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"ababa\", \"b\"), elements));\n\n        elements = new string[](5);\n        elements[0] = \"a\";\n        elements[1] = \"b\";\n        elements[2] = \"a\";\n        elements[3] = \"b\";\n        elements[4] = \"a\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"ababa\", \"\"), elements));\n\n        elements = new string[](2);\n        elements[0] = \"a\";\n        elements[1] = \"b\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"ab\", \"\"), elements));\n\n        elements = new string[](1);\n        elements[0] = \"ab\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"ab\", \" \"), elements));\n\n        elements = new string[](1);\n        elements[0] = \"a\";\n        assertTrue(_stringArraysAreSame(LibString.split(\"a\", \"\"), elements));\n\n        elements = new string[](0);\n        assertTrue(_stringArraysAreSame(LibString.split(\"\", \"\"), elements));\n    }\n\n    function testStringConcat(string memory a, string memory b) public brutalizeMemory {\n        string memory concatenated = LibString.concat(a, b);\n        _checkMemory(concatenated);\n        string memory expectedResult = string(bytes.concat(bytes(a), bytes(b)));\n        assertEq(concatenated, expectedResult);\n    }\n\n    function testStringConcat() public {\n        assertEq(\n            LibString.concat(\n                \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\",\n                \"12345678901234567890123456789012345678901234567890\"\n            ),\n            \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY12345678901234567890123456789012345678901234567890\"\n        );\n        assertEq(LibString.concat(\"\", \"b\"), \"b\");\n        assertEq(LibString.concat(\"\", \"b\"), \"b\");\n        assertEq(LibString.concat(\"a\", \"b\"), \"ab\");\n        assertEq(LibString.concat(\"a\", \"\"), \"a\");\n        assertEq(LibString.concat(\"\", \"\"), \"\");\n    }\n\n    function testStringConcatOriginal() public {\n        assertEq(\n            string(\n                bytes.concat(\n                    bytes(\"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\"),\n                    bytes(\"12345678901234567890123456789012345678901234567890\")\n                )\n            ),\n            \"bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY12345678901234567890123456789012345678901234567890\"\n        );\n        assertEq(string(bytes.concat(bytes(\"\"), bytes(\"b\"))), \"b\");\n        assertEq(string(bytes.concat(bytes(\"\"), bytes(\"b\"))), \"b\");\n        assertEq(string(bytes.concat(bytes(\"a\"), bytes(\"b\"))), \"ab\");\n        assertEq(string(bytes.concat(bytes(\"a\"), bytes(\"\"))), \"a\");\n        assertEq(string(bytes.concat(bytes(\"\"), bytes(\"\"))), \"\");\n    }\n\n    function testStringEscapeHTML() public {\n        assertEq(LibString.escapeHTML(\"\"), \"\");\n        assertEq(LibString.escapeHTML(\"abc\"), \"abc\");\n        assertEq(LibString.escapeHTML('abc\"_123'), \"abc&quot;_123\");\n        assertEq(LibString.escapeHTML(\"abc&_123\"), \"abc&amp;_123\");\n        assertEq(LibString.escapeHTML(\"abc'_123\"), \"abc&#39;_123\");\n        assertEq(LibString.escapeHTML(\"abc<_123\"), \"abc&lt;_123\");\n        assertEq(LibString.escapeHTML(\"abc>_123\"), \"abc&gt;_123\");\n    }\n\n    function testStringEscapeHTML(uint256) public brutalizeMemory {\n        string[] memory originalChars = new string[](5);\n        originalChars[0] = '\"';\n        originalChars[1] = \"&\";\n        originalChars[2] = \"'\";\n        originalChars[3] = \"<\";\n        originalChars[4] = \">\";\n\n        string[] memory escapedChars = new string[](5);\n        escapedChars[0] = \"&quot;\";\n        escapedChars[1] = \"&amp;\";\n        escapedChars[2] = \"&#39;\";\n        escapedChars[3] = \"&lt;\";\n        escapedChars[4] = \"&gt;\";\n\n        string memory filler0 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        string memory filler1 = _generateString(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\n        uint256 r = _random() % 5;\n\n        string memory expectedResult =\n            string(bytes.concat(bytes(filler0), bytes(escapedChars[r]), bytes(filler1)));\n\n        string memory input =\n            string(bytes.concat(bytes(filler0), bytes(originalChars[r]), bytes(filler1)));\n\n        _misalignFreeMemoryPointer();\n        string memory escaped = LibString.escapeHTML(input);\n        _checkMemory(escaped);\n\n        assertEq(expectedResult, escaped);\n    }\n\n    function testStringEscapeJSON() public {\n        _checkStringEscapeJSON(\"\", \"\");\n        _checkStringEscapeJSON(\"abc\", \"abc\");\n        _checkStringEscapeJSON('abc\"_123', 'abc\\\\\"_123');\n        _checkStringEscapeJSON(\"abc\\\\_123\", \"abc\\\\\\\\_123\");\n        _checkStringEscapeJSON(\"abc\\x08_123\", \"abc\\\\b_123\");\n        _checkStringEscapeJSON(\"abc\\x0c_123\", \"abc\\\\f_123\");\n        _checkStringEscapeJSON(\"abc\\n_123\", \"abc\\\\n_123\");\n        _checkStringEscapeJSON(\"abc\\r_123\", \"abc\\\\r_123\");\n        _checkStringEscapeJSON(\"abc\\t_123\", \"abc\\\\t_123\");\n    }\n\n    function _checkStringEscapeJSON(string memory s, string memory expected) internal {\n        assertEq(LibString.escapeJSON(s), expected);\n        assertEq(LibString.escapeJSON(s, false), expected);\n        assertEq(LibString.escapeJSON(s, true), string(bytes.concat('\"', bytes(expected), '\"')));\n    }\n\n    function testStringEscapeJSONHexEncode() public brutalizeMemory {\n        unchecked {\n            for (uint256 i; i <= 0x1f; ++i) {\n                if (i != 0x8 && i != 0x9 && i != 0x0a && i != 0x0c && i != 0x0d) {\n                    string memory input =\n                        string(bytes.concat(bytes(\"abc\"), bytes1(uint8(i)), bytes(\"_123\")));\n                    string memory hexCode = LibString.replace(LibString.toHexString(i), \"0x\", \"00\");\n                    string memory expectedOutput =\n                        string(bytes.concat(bytes(\"abc\\\\u\"), bytes(hexCode), bytes(\"_123\")));\n                    string memory escaped = LibString.escapeJSON(input);\n                    _checkMemory(escaped);\n                    assertEq(escaped, expectedOutput);\n                }\n            }\n        }\n    }\n\n    function testStringEq(string memory a, string memory b) public {\n        assertEq(LibString.eq(a, b), keccak256(bytes(a)) == keccak256(bytes(b)));\n    }\n\n    function checkIsSN(string memory s) public pure returns (bool) {\n        // You can try replacing it with\n        // `return keccak256(bytes(s)) == keccak256(\"sn\");`\n        // and see the bytecode size increase.\n        // This demonstrates that `eqs` does the compile time magic.\n        // Note that `s` must be in memory, not calldata.\n        return LibString.eqs(s, \"sn\");\n    }\n\n    function testStringEqs() public {\n        assertTrue(LibString.eqs(\"\", \"\"));\n        assertTrue(LibString.eqs(\"1\", \"1\"));\n        assertTrue(LibString.eqs(\"12\", \"12\"));\n        assertTrue(LibString.eqs(\"123\", \"123\"));\n        assertTrue(LibString.eqs(\"Hello\", \"Hello\"));\n        assertTrue(\n            LibString.eqs(\"12345678901234567890123456789012\", \"12345678901234567890123456789012\")\n        );\n\n        assertTrue(LibString.eqs(\"\", hex\"0061\"));\n        assertTrue(LibString.eqs(\"a\", hex\"610061\"));\n        assertTrue(LibString.eqs(\"aa\", hex\"61610061\"));\n\n        assertFalse(LibString.eqs(\"\", \"x\"));\n        assertFalse(LibString.eqs(\"1\", \"2\"));\n        assertFalse(LibString.eqs(\"Hello\", \"Hehe\"));\n        assertFalse(LibString.eqs(\"12345678901234567890123456789012\", \"\"));\n\n        assertTrue(checkIsSN(\"sn\"));\n        assertFalse(checkIsSN(\"x\"));\n    }\n\n    function testStringPackAndUnpackOneDifferential(string memory a) public brutalizeMemory {\n        a = LibString.slice(a, 0);\n        bytes32 packed = LibString.packOne(a);\n        unchecked {\n            if (bytes(a).length < 32) {\n                bytes memory expectedResultBytes = abi.encodePacked(uint8(bytes(a).length), a);\n                bytes32 expectedResult;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    expectedResult := mload(add(expectedResultBytes, 0x20))\n                }\n                assertEq(packed, expectedResult);\n            } else {\n                assertEq(packed, bytes32(0));\n            }\n        }\n    }\n\n    function testStringPackAndUnpackOne(string memory a) public brutalizeMemory {\n        _misalignFreeMemoryPointer();\n        bytes32 packed = LibString.packOne(a);\n        string memory unpacked = LibString.unpackOne(packed);\n        _checkMemory(unpacked);\n\n        if (bytes(a).length < 32) {\n            assertEq(unpacked, a);\n        } else {\n            assertEq(packed, bytes32(0));\n            assertEq(unpacked, \"\");\n        }\n    }\n\n    function testStringPackAndUnpackOne() public {\n        unchecked {\n            testStringPackAndUnpackOne(\"\");\n            testStringPackAndUnpackOne(\"Hehe\");\n            testStringPackAndUnpackOne(\"abcdefghijklmnopqrstuvwxyzABCD\");\n            testStringPackAndUnpackOne(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        }\n    }\n\n    function testStringPackAndUnpackTwoDifferential(string memory a, string memory b)\n        public\n        brutalizeMemory\n    {\n        a = LibString.slice(a, 0);\n        b = LibString.slice(b, 0);\n        bytes32 packed = LibString.packTwo(a, b);\n        unchecked {\n            if (bytes(a).length + bytes(b).length < 31) {\n                bytes memory expectedResultBytes =\n                    abi.encodePacked(uint8(bytes(a).length), a, uint8(bytes(b).length), b);\n                bytes32 expectedResult;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    expectedResult := mload(add(expectedResultBytes, 0x20))\n                }\n                assertEq(packed, expectedResult);\n            } else {\n                assertEq(packed, bytes32(0));\n            }\n        }\n    }\n\n    function testStringPackAndUnpackTwo(string memory a, string memory b) public brutalizeMemory {\n        bytes32 packed = LibString.packTwo(a, b);\n        _misalignFreeMemoryPointer();\n        (string memory unpackedA, string memory unpackedB) = LibString.unpackTwo(packed);\n        _checkMemory(unpackedA);\n        _checkMemory(unpackedB);\n\n        unchecked {\n            if (bytes(a).length + bytes(b).length < 31) {\n                assertEq(unpackedA, a);\n                assertEq(unpackedB, b);\n            } else {\n                assertEq(packed, bytes32(0));\n                assertEq(unpackedA, \"\");\n                assertEq(unpackedB, \"\");\n            }\n        }\n    }\n\n    function testStringPackAndUnpackTwo() public {\n        unchecked {\n            testStringPackAndUnpackTwo(\"\", \"\");\n            testStringPackAndUnpackTwo(\"\", \"\");\n            testStringPackAndUnpackTwo(\"a\", \"\");\n            testStringPackAndUnpackTwo(\"\", \"b\");\n            testStringPackAndUnpackTwo(\"abcdefghijklmnopqrstuvwxyzABCD\", \"\");\n            testStringPackAndUnpackTwo(\"The strongest community I've ever seen\", \"NGL\");\n            testStringPackAndUnpackTwo(\"\", \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        }\n    }\n\n    function testStringDirectReturn(string memory a) public {\n        assertEq(this.returnString(a), a);\n    }\n\n    function testStringDirectReturn() public {\n        testStringDirectReturn(\"\");\n        testStringDirectReturn(\"aaa\");\n        testStringDirectReturn(\"98729\");\n    }\n\n    function returnString(string memory a) external pure returns (string memory) {\n        LibString.directReturn(a);\n    }\n\n    function testStringLowerDifferential(string memory s) public {\n        string memory expectedResult = _lowerOriginal(s);\n        _misalignFreeMemoryPointer();\n        string memory result = LibString.lower(s);\n        _checkMemory(result);\n        assertEq(result, expectedResult);\n    }\n\n    function testStringLowerDifferential() public {\n        unchecked {\n            string memory ascii = new string(128);\n            for (uint256 i; i < 128; ++i) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(add(add(ascii, 0x20), i), i)\n                }\n            }\n            for (uint256 i; i < 256; ++i) {\n                string memory s = _generateString(ascii);\n                testStringLowerDifferential(s);\n            }\n        }\n    }\n\n    function testStringLowerOriginal() public {\n        assertEq(_lowerOriginal(\"@AZ[\"), \"@az[\");\n    }\n\n    function testStringUpperDifferential(string memory s) public {\n        string memory expectedResult = _upperOriginal(s);\n        _misalignFreeMemoryPointer();\n        string memory result = LibString.upper(s);\n        _checkMemory(result);\n        assertEq(result, expectedResult);\n    }\n\n    function testStringUpperDifferential() public {\n        unchecked {\n            string memory ascii = new string(128);\n            for (uint256 i; i < 128; ++i) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(add(add(ascii, 0x20), i), i)\n                }\n            }\n            for (uint256 i; i < 256; ++i) {\n                string memory s = _generateString(ascii);\n                testStringUpperDifferential(s);\n            }\n        }\n    }\n\n    function testStringUpperOriginal() public {\n        assertEq(_upperOriginal(\"`az}\"), \"`AZ}\");\n    }\n\n    function fromSmallString() public {\n        assertEq(LibString.fromSmallString(bytes32(\"\")), \"\");\n        assertEq(LibString.fromSmallString(bytes32(\"a\")), \"a\");\n        assertEq(LibString.fromSmallString(bytes32(\"abc\")), \"abc\");\n        assertEq(LibString.fromSmallString(bytes32(\"Hello world!\")), \"Hello world!\");\n    }\n\n    function testNormalizeSmallString() public {\n        bytes32 x;\n        bytes32 y;\n        assertEq(LibString.normalizeSmallString(x), y);\n        x = 0x1100000000000000000000000000000000000000000000000000000000000000;\n        y = 0x1100000000000000000000000000000000000000000000000000000000000000;\n        assertEq(LibString.normalizeSmallString(x), y);\n        x = 0x1100ff0000000000000000000000000000000000000000000000000000000000;\n        y = 0x1100000000000000000000000000000000000000000000000000000000000000;\n        assertEq(LibString.normalizeSmallString(x), y);\n        x = 0x1122ff0000000000000000000000000000000000000000000000000000000000;\n        y = 0x1122ff0000000000000000000000000000000000000000000000000000000000;\n        assertEq(LibString.normalizeSmallString(x), y);\n        x = 0x00000000000000000000000000000000000000000000000000000000000000ff;\n        y = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        assertEq(LibString.normalizeSmallString(x), y);\n        x = 0x00ff0000000000000000000000000000000000000000000000000000000000ff;\n        y = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        assertEq(LibString.normalizeSmallString(x), y);\n    }\n\n    function testNormalizeSmallString(bytes32 x) public {\n        string memory y = LibString.fromSmallString(x);\n        bytes32 normalized = LibString.normalizeSmallString(x);\n        assertEq(LibString.toSmallString(y), normalized);\n        assertTrue(LibString.eqs(y, normalized));\n        assertTrue(LibString.eqs(y, x));\n    }\n\n    function testToSmallString() public {\n        assertEq(LibString.toSmallString(\"\"), \"\");\n        assertEq(LibString.toSmallString(\"a\"), \"a\");\n        assertEq(LibString.toSmallString(\"ab\"), \"ab\");\n        assertEq(LibString.toSmallString(\"abc\"), \"abc\");\n        assertEq(\n            LibString.toSmallString(\"1234567890123456789012345678901\"),\n            \"1234567890123456789012345678901\"\n        );\n        assertEq(\n            LibString.toSmallString(\"12345678901234567890123456789012\"),\n            \"12345678901234567890123456789012\"\n        );\n        vm.expectRevert(LibString.TooBigForSmallString.selector);\n        LibString.toSmallString(\"123456789012345678901234567890123\");\n    }\n\n    function _lowerOriginal(string memory subject) internal pure returns (string memory result) {\n        unchecked {\n            uint256 n = bytes(subject).length;\n            result = new string(n);\n            for (uint256 i; i != n; ++i) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let b := byte(0, mload(add(add(subject, 0x20), i)))\n                    mstore8(\n                        add(add(result, 0x20), i), add(b, mul(0x20, and(lt(0x40, b), lt(b, 0x5b))))\n                    )\n                }\n            }\n        }\n    }\n\n    function _upperOriginal(string memory subject) internal pure returns (string memory result) {\n        unchecked {\n            uint256 n = bytes(subject).length;\n            result = new string(n);\n            for (uint256 i; i != n; ++i) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let b := byte(0, mload(add(add(subject, 0x20), i)))\n                    mstore8(\n                        add(add(result, 0x20), i), sub(b, mul(0x20, and(lt(0x60, b), lt(b, 0x7b))))\n                    )\n                }\n            }\n        }\n    }\n\n    function _is7BitASCIIOriginal(string memory s) internal pure returns (bool) {\n        unchecked {\n            bytes memory sBytes = bytes(s);\n            for (uint256 i; i < sBytes.length; ++i) {\n                if (uint8(bytes1(sBytes[i])) > 127) return false;\n            }\n            return true;\n        }\n    }\n\n    function _runeCountOriginal(string memory s) internal pure returns (uint256) {\n        unchecked {\n            uint256 len;\n            uint256 i = 0;\n            uint256 bytelength = bytes(s).length;\n            for (len = 0; i < bytelength; len++) {\n                bytes1 b = bytes(s)[i];\n                if (b < 0x80) {\n                    i += 1;\n                } else if (b < 0xE0) {\n                    i += 2;\n                } else if (b < 0xF0) {\n                    i += 3;\n                } else if (b < 0xF8) {\n                    i += 4;\n                } else if (b < 0xFC) {\n                    i += 5;\n                } else {\n                    i += 6;\n                }\n            }\n            return len;\n        }\n    }\n\n    function _repeatOriginal(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory)\n    {\n        unchecked {\n            string memory result;\n            if (!(times == 0 || bytes(subject).length == 0)) {\n                for (uint256 i; i < times; ++i) {\n                    result = string(bytes.concat(bytes(result), bytes(subject)));\n                }\n            }\n            _misalignFreeMemoryPointer();\n            return result;\n        }\n    }\n\n    function _generateFrom(string memory subject) internal returns (uint256) {\n        unchecked {\n            if (_random() % 8 == 0) {\n                return _random();\n            }\n            return _random() % (bytes(subject).length + 10);\n        }\n    }\n\n    function _generateString(string memory byteChoices) internal returns (string memory result) {\n        uint256 randomness = _random();\n        uint256 resultLength = _randomStringLength();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(byteChoices) {\n                result := mload(0x40)\n                mstore(0x00, randomness)\n                mstore(0x40, and(add(add(result, 0x40), resultLength), not(31)))\n                mstore(result, resultLength)\n\n                // forgefmt: disable-next-item\n                for { let i := 0 } lt(i, resultLength) { i := add(i, 1) } {\n                    mstore(0x20, gas())\n                    mstore8(\n                        add(add(result, 0x20), i), \n                        mload(add(add(byteChoices, 1), mod(keccak256(0x00, 0x40), mload(byteChoices))))\n                    )\n                }\n            }\n        }\n    }\n\n    function _randomStringLength() internal returns (uint256 r) {\n        r = _random() % 256;\n        if (r < 64) return _random() % 128;\n        if (r < 128) return _random() % 64;\n        return _random() % 16;\n    }\n\n    function _stringArraysAreSame(string[] memory a, string[] memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        unchecked {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (uint256 i; i < a.length; ++i) {\n                if (keccak256(bytes(a[i])) != keccak256(bytes(b[i]))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n",
        "contractname": "LibString.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Optimized sorts and operations for sorted arrays.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Sort.sol)\nlibrary LibSort {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      INSERTION SORT                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // - Faster on small arrays (32 or lesser elements).\n    // - Faster on almost sorted arrays.\n    // - Smaller bytecode.\n    // - May be suitable for view functions intended for off-chain querying.\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let s := 0x20\n            let w := not(0x1f)\n            for { let i := add(a, s) } 1 {} {\n                i := add(i, s)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, s), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, s), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      INTRO-QUICKSORT                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // - Faster on larger arrays (more than 32 elements).\n    // - Robust performance.\n    // - Larger bytecode.\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let s := 0x20\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n\n            // Let the stack be the start of the free memory.\n            let stack := mload(0x40)\n\n            for {} iszero(lt(n, 2)) {} {\n                // Push `l` and `h` to the stack.\n                // The `shl` by 5 is equivalent to multiplying by `0x20`.\n                let l := add(a, s)\n                let h := add(a, shl(5, n))\n\n                let j := l\n                // forgefmt: disable-next-item\n                for {} iszero(or(eq(j, h), gt(mload(j), mload(add(j, s))))) {} {\n                    j := add(j, s)\n                }\n                // If the array is already sorted.\n                if eq(j, h) { break }\n\n                j := h\n                // forgefmt: disable-next-item\n                for {} iszero(gt(mload(j), mload(add(j, w)))) {} {\n                    j := add(j, w) // `sub(j, 0x20)`.\n                }\n                // If the array is reversed sorted.\n                if eq(j, l) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(h, w) // `sub(h, 0x20)`.\n                        l := add(l, s)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n\n                // Push `l` and `h` onto the stack.\n                mstore(stack, l)\n                mstore(add(stack, s), h)\n                stack := add(stack, 0x40)\n                break\n            }\n\n            for { let stackBottom := mload(0x40) } iszero(eq(stack, stackBottom)) {} {\n                // Pop `l` and `h` from the stack.\n                stack := sub(stack, 0x40)\n                let l := mload(stack)\n                let h := mload(add(stack, s))\n\n                // Do insertion sort if `h - l <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h, l), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i := add(l, s)\n                    if iszero(lt(mload(l), mload(i))) {\n                        let t := mload(i)\n                        mstore(i, mload(l))\n                        mstore(l, t)\n                    }\n                    for {} 1 {} {\n                        i := add(i, s)\n                        if gt(i, h) { break }\n                        let k := mload(i) // Key.\n                        let j := add(i, w) // The slot before the current slot.\n                        let v := mload(j) // The value of `j`.\n                        if iszero(gt(v, k)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j, s), v)\n                            j := add(j, w)\n                            v := mload(j)\n                            if iszero(gt(v, k)) { break }\n                        }\n                        mstore(add(j, s), k)\n                    }\n                    continue\n                }\n                // Pivot slot is the average of `l` and `h`.\n                let p := add(shl(5, shr(6, add(l, h))), and(31, l))\n                // Median of 3 with sorting.\n                {\n                    function swap(a_, b_) -> _b, _a {\n                        _b := a_\n                        _a := b_\n                    }\n                    let e0 := mload(l)\n                    let e1 := mload(h)\n                    if iszero(lt(e0, e1)) { e1, e0 := swap(e0, e1) }\n                    let e2 := mload(p)\n                    if iszero(lt(e2, e1)) { e2, e1 := swap(e1, e2) }\n                    if iszero(lt(e0, e2)) { e2, e0 := swap(e0, e2) }\n                    mstore(p, e2)\n                    mstore(h, e1)\n                    mstore(l, e0)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x := mload(p)\n                    p := h\n                    for { let i := l } 1 {} {\n                        for {} 1 {} {\n                            i := add(i, s)\n                            if iszero(gt(x, mload(i))) { break }\n                        }\n                        let j := p\n                        for {} 1 {} {\n                            j := add(j, w)\n                            if iszero(lt(x, mload(j))) { break }\n                        }\n                        p := j\n                        if iszero(lt(i, p)) { break }\n                        // Swap slots `i` and `p`.\n                        let t := mload(i)\n                        mstore(i, mload(p))\n                        mstore(p, t)\n                    }\n                }\n                // If slice on right of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, add(p, s))\n                    // Skip `mstore(add(stack, 0x20), h)`, as it is already on the stack.\n                    stack := add(stack, shl(6, lt(add(p, s), h)))\n                }\n                // If slice on left of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, l)\n                    mstore(add(stack, s), p)\n                    stack := add(stack, shl(6, gt(p, l)))\n                }\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  OTHER USEFUL OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // For performance, the `uniquifySorted` methods will not revert if the\n    // array is not sorted -- it will simply remove consecutive duplicate elements.\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(uint160(needle)), 0);\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(int256[] memory a) internal pure returns (int256[] memory result) {\n        result = _toInts(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(address[] memory a) internal pure returns (address[] memory result) {\n        result = _toAddresses(copy(_toUints(a)));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an int array.\n    function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an address array.\n    function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Converts an array of signed integers to unsigned\n    /// integers suitable for sorting or vice versa.\n    function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := shl(255, 1)\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, add(mload(a), w))\n            }\n        }\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport \"src/utils/LibSort.sol\";\n\ncontract LibSortTest is SoladyTest {\n    function testInsertionSortAddressesDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 32 == 0 ? _randomArrayLength() : _random() % 4;\n            address[] memory a = _randomAddresses(n);\n            // Make a copy of the `a` and perform insertion sort on it.\n            address[] memory aCopy = _copy(a);\n            for (uint256 i = 1; i < n; ++i) {\n                address key = aCopy[i];\n                uint256 j = i;\n                while (j != 0 && aCopy[j - 1] > key) {\n                    aCopy[j] = aCopy[j - 1];\n                    --j;\n                }\n                aCopy[j] = key;\n            }\n            LibSort.insertionSort(a);\n            assertEq(a, aCopy);\n        }\n    }\n\n    function testInsertionSortPsuedorandom(uint256) public {\n        unchecked {\n            uint256[] memory a = _randomUints(32);\n            LibSort.insertionSort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testInsertionSortPsuedorandom() public {\n        testInsertionSortPsuedorandom(123456789);\n    }\n\n    function testSortChecksumed(uint256) public {\n        unchecked {\n            uint256 n = _randomArrayLength();\n            uint256[] memory a = _randomUints(n);\n            uint256 checksum;\n            for (uint256 i = 0; i != n; ++i) {\n                checksum += a[i];\n            }\n            LibSort.sort(a);\n            uint256 checksumAfterSort;\n            for (uint256 i = 0; i != n; ++i) {\n                checksumAfterSort += a[i];\n            }\n            assertEq(checksum, checksumAfterSort);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortDifferential(uint256) public {\n        unchecked {\n            uint256[] memory a = _randomUints(_randomArrayLength());\n            // Make a copy of the `a` and perform insertion sort on it.\n            uint256[] memory aCopy = _copy(a);\n            LibSort.insertionSort(aCopy);\n            LibSort.sort(a);\n            assertEq(a, aCopy);\n        }\n    }\n\n    function testSort(uint256) public {\n        unchecked {\n            uint256[] memory a = _randomUints(_randomArrayLength());\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortBasicCase() public {\n        unchecked {\n            uint256[] memory a = new uint256[](2);\n            a[0] = 3;\n            a[1] = 0;\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortPsuedorandom(uint256) public {\n        unchecked {\n            uint256[] memory a = _randomUints(100);\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortPsuedorandom() public {\n        testSortPsuedorandom(123456789);\n    }\n\n    function testSortPsuedorandomNonuniform(uint256) public {\n        unchecked {\n            uint256[] memory a = new uint256[](100);\n            for (uint256 i; i < a.length; ++i) {\n                a[i] = _random() << (i & 8 == 0 ? 128 : 0);\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortPsuedorandomNonuniform() public {\n        testSortPsuedorandomNonuniform(123456789);\n    }\n\n    function testSortSorted() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = i;\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortReversed() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = 999 - i;\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortMostlySame() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = i % 8 == 0 ? i : 0;\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortTestOverhead() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            uint256 mask = (1 << 128) - 1;\n            for (uint256 i; i != n; ++i) {\n                a[i] = (i << 128) | (_random() & mask);\n            }\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortAddressesPsuedorandomBrutalizeUpperBits() public {\n        unchecked {\n            uint256 n = 100;\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                address addr = address(uint160(_random()));\n                uint256 randomness = _random();\n                /// @solidity memory-safe-assembly\n                assembly {\n                    addr := or(addr, shl(160, randomness))\n                }\n                a[i] = addr;\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortAddressesDifferential(uint256) public {\n        unchecked {\n            uint256 n = _randomArrayLength();\n            uint256[] memory aRaw = _randomUints(n);\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                address addr;\n                uint256 addrRaw = aRaw[i];\n                /// @solidity memory-safe-assembly\n                assembly {\n                    addr := addrRaw\n                }\n                a[i] = addr;\n            }\n            // Make a copy of the `a` and perform insertion sort on it.\n            address[] memory aCopy = _copy(a);\n            LibSort.insertionSort(aCopy);\n            LibSort.sort(a);\n            assertEq(a, aCopy);\n        }\n    }\n\n    function testSortAddressesPsuedorandom(uint256) public {\n        unchecked {\n            address[] memory a = _randomAddresses(100);\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortAddressesPsuedorandom() public {\n        testSortAddressesPsuedorandom(123456789);\n    }\n\n    function testSortAddressesSorted() public {\n        unchecked {\n            uint256 n = 100;\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = address(uint160(i));\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortAddressesReversed() public {\n        unchecked {\n            uint256 n = 100;\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = address(uint160(999 - i));\n            }\n            LibSort.sort(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortOriginalPsuedorandom(uint256) public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = _random();\n            }\n            _sortOriginal(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortOriginalPsuedorandom() public {\n        testSortOriginalPsuedorandom(123456789);\n    }\n\n    function testSortOriginalSorted() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = i;\n            }\n            _sortOriginal(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortOriginalReversed() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = 999 - i;\n            }\n            _sortOriginal(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testSortOriginalMostlySame() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = i % 8 == 0 ? i : 0;\n            }\n            _sortOriginal(a);\n            assertTrue(_isSorted(a));\n        }\n    }\n\n    function testUniquifySorted() public {\n        uint256[] memory a = new uint256[](5);\n        a[0] = 1;\n        a[1] = 1;\n        a[2] = 3;\n        a[3] = 3;\n        a[4] = 5;\n        LibSort.uniquifySorted(a);\n        assertTrue(_isSortedAndUniquified(a));\n        assertEq(a.length, 3);\n    }\n\n    function testUniquifySortedWithEmptyArray() public {\n        uint256[] memory a = new uint256[](0);\n        LibSort.uniquifySorted(a);\n        assertTrue(_isSortedAndUniquified(a));\n        assertEq(a.length, 0);\n    }\n\n    function testUniquifySortedAddress() public {\n        address[] memory a = new address[](10);\n        a[0] = address(0x1efF47bc3a10a45D4B230B5d10E37751FE6AA718);\n        a[1] = address(0x1efF47bc3a10a45D4B230B5d10E37751FE6AA718);\n        a[2] = address(0x1efF47bC3A10a45d4b630B5D10E37751FE6aA718);\n        a[3] = address(0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF);\n        a[4] = address(0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69);\n        a[5] = address(0x6813eb9362372Eef6200f3B1dbC3f819671cbA70);\n        a[6] = address(0xe1AB8145F7E55DC933d51a18c793F901A3A0b276);\n        a[7] = address(0xe1AB8145F7E55DC933d51a18c793F901A3A0b276);\n        a[8] = address(0xE1Ab8145F7e55Dc933D61a18c793f901A3a0B276);\n        a[9] = address(0xe1ab8145f7E55Dc933D61A18c793f901A3A0B288);\n        LibSort.uniquifySorted(a);\n        assertTrue(_isSortedAndUniquified(a));\n        assertEq(a.length, 8);\n    }\n\n    function testUniquifySorted(uint256) public {\n        uint256[] memory a = _randomUints(_randomArrayLength());\n        LibSort.sort(a);\n        LibSort.uniquifySorted(a);\n        assertTrue(_isSortedAndUniquified(a));\n    }\n\n    function testUniquifySortedAddress(uint256) public {\n        address[] memory a = _randomAddresses(_randomArrayLength());\n        LibSort.sort(a);\n        LibSort.uniquifySorted(a);\n        assertTrue(_isSortedAndUniquified(a));\n    }\n\n    function testUniquifySortedDifferential(uint256) public {\n        uint256 n = _randomArrayLength();\n        uint256[] memory a = _randomUints(n);\n        LibSort.sort(a);\n        uint256[] memory aCopy = new uint256[](n);\n        for (uint256 i; i != n; ++i) {\n            aCopy[i] = a[i];\n        }\n        LibSort.uniquifySorted(a);\n        _uniquifyOriginal(aCopy);\n        assertEq(a, aCopy);\n    }\n\n    function testSearchSortedBasicCases() public {\n        uint256[] memory a = new uint256[](6);\n        a[0] = 0;\n        a[1] = 1;\n        a[2] = 2;\n        a[3] = 3;\n        a[4] = 4;\n        a[5] = 5;\n        (bool found, uint256 index) = LibSort.searchSorted(a, 2);\n        assertTrue(found);\n        assertEq(index, 2);\n\n        a[0] = 0;\n        a[1] = 1;\n        a[2] = 2;\n        a[3] = 3;\n        a[4] = 4;\n        a[5] = 5;\n        (found, index) = LibSort.searchSorted(a, 5);\n        assertTrue(found);\n        assertEq(index, 5);\n    }\n\n    function testSearchSortedEdgeCases() public {\n        uint256[] memory a = new uint256[](1);\n        a[0] = 2;\n        (bool found, uint256 index) = LibSort.searchSorted(a, 1);\n        assertFalse(found);\n\n        a = new uint256[](2);\n        a[0] = 45;\n        a[1] = 46;\n        (found, index) = LibSort.searchSorted(a, 2);\n        assertFalse(found);\n    }\n\n    function testSearchSortedWithEmptyArray() public {\n        uint256[] memory a = new uint256[](0);\n        (bool found, uint256 index) = LibSort.searchSorted(a, 1);\n        assertFalse(found);\n        assertEq(index, 0);\n    }\n\n    function testSearchSortedElementNotInArray() public {\n        uint256[] memory a = new uint256[](5);\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n        a[3] = 4;\n        a[4] = 5;\n        (bool found, uint256 index) = LibSort.searchSorted(a, 0);\n        assertFalse(found);\n        assertEq(index, 0);\n\n        a[0] = 15;\n        a[1] = 25;\n        a[2] = 35;\n        a[3] = 45;\n        a[4] = 55;\n        (found, index) = LibSort.searchSorted(a, 10);\n        assertFalse(found);\n        assertEq(index, 0);\n        (found, index) = LibSort.searchSorted(a, 20);\n        assertFalse(found);\n        assertEq(index, 0);\n        (found, index) = LibSort.searchSorted(a, 30);\n        assertFalse(found);\n        assertEq(index, 1);\n        (found, index) = LibSort.searchSorted(a, 40);\n        assertFalse(found);\n        assertEq(index, 2);\n        (found, index) = LibSort.searchSorted(a, 50);\n        assertFalse(found);\n        assertEq(index, 3);\n        (found, index) = LibSort.searchSorted(a, 60);\n        assertFalse(found);\n        assertEq(index, 4);\n    }\n\n    function testSearchSortedElementInArray(uint256) public {\n        unchecked {\n            _misalignFreeMemoryPointer();\n            uint256[] memory a = _randomUints(_randomNonZeroArrayLength());\n            LibSort.sort(a);\n            if (_random() % 2 == 0) {\n                LibSort.uniquifySorted(a);\n            }\n            uint256 randomIndex = _random() % a.length;\n            uint256 value = a[randomIndex];\n            (bool found, uint256 index) = LibSort.searchSorted(a, value);\n            assertTrue(found);\n            assertEq(a[index], value);\n        }\n    }\n\n    function testSearchSortedElementNotInArray(uint256) public {\n        unchecked {\n            _misalignFreeMemoryPointer();\n            uint256[] memory a = _randomUints(_randomNonZeroArrayLength());\n            LibSort.sort(a);\n            if (_random() % 2 == 0) {\n                LibSort.uniquifySorted(a);\n            }\n            uint256 randomIndex = _random() % a.length;\n            uint256 missingValue;\n            if (_random() % 2 == 0) {\n                if (_random() % 2 == 0) {\n                    missingValue = a[randomIndex] + 1;\n                    if (missingValue == 0) return;\n                } else {\n                    missingValue = a[randomIndex] - 1;\n                    if (missingValue == type(uint256).max) return;\n                }\n                if (_exists(a, missingValue)) return;\n                (bool found, uint256 index) = LibSort.searchSorted(a, missingValue);\n                assertFalse(found);\n                assertEq(a[index], a[_nearestIndexBefore(a, missingValue)]);\n            } else {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore(0x00, missingValue)\n                    missingValue := keccak256(0x00, 0x20)\n                }\n                (bool found,) = LibSort.searchSorted(a, missingValue);\n                assertFalse(found);\n            }\n        }\n    }\n\n    function _exists(uint256[] memory a, uint256 x) internal pure returns (bool result) {\n        unchecked {\n            uint256 n = a.length;\n            for (uint256 i; i != n; ++i) {\n                if (a[i] == x) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function _nearestIndexBefore(uint256[] memory a, uint256 x)\n        internal\n        pure\n        returns (uint256 nearestIndex)\n    {\n        unchecked {\n            uint256 nearestDist = type(uint256).max;\n            uint256 n = a.length;\n            for (uint256 i; i != n; ++i) {\n                uint256 y = a[i];\n                if (y > x) continue;\n                uint256 dist = x - y;\n                if (dist < nearestDist) {\n                    nearestIndex = i;\n                    nearestDist = dist;\n                }\n            }\n        }\n    }\n\n    function testSearchSorted() public {\n        unchecked {\n            uint256 n = 100;\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; i++) {\n                a[i] = i;\n            }\n            for (uint256 i; i != n; i++) {\n                (bool found, uint256 index) = LibSort.searchSorted(a, i);\n                assertTrue(found);\n                assertEq(index, i);\n            }\n        }\n    }\n\n    function testSearchSortedDifferential(uint256) public {\n        uint256[] memory a = _randomUints(_randomArrayLength());\n        uint256 needle = _random();\n        if (_random() % 2 == 0 && a.length != 0) {\n            needle = a[_random() % a.length];\n        }\n        (bool found, uint256 index) = LibSort.searchSorted(a, needle);\n        if (found) {\n            assertEq(a[index], needle);\n        }\n        LibSort.sort(a);\n        (found, index) = LibSort.searchSorted(a, needle);\n        assertEq(found, _exists(a, needle));\n        if (found) {\n            assertEq(a[index], needle);\n        }\n    }\n\n    function testSearchSortedInts() public {\n        unchecked {\n            uint256 n = 100;\n            int256[] memory a = new int256[](n);\n            for (uint256 i = 0; i != n; i++) {\n                a[i] = int256(i) - 50;\n            }\n            for (uint256 i; i != n; i++) {\n                (bool found, uint256 index) = LibSort.searchSorted(a, int256(i) - 50);\n                assertTrue(found);\n                assertEq(index, i);\n            }\n        }\n    }\n\n    function testSearchSortedInts(int256[] memory a, int256 needle) public {\n        (bool found, uint256 index) = LibSort.searchSorted(a, needle);\n        if (found) {\n            assertEq(a[index], needle);\n        }\n    }\n\n    function testSearchSortedAddresses() public {\n        unchecked {\n            uint256 n = 100;\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; i++) {\n                a[i] = address(uint160(i));\n            }\n            for (uint256 i; i != n; i++) {\n                (bool found, uint256 index) = LibSort.searchSorted(a, address(uint160(i)));\n                assertTrue(found);\n                assertEq(index, i);\n                (found,) = LibSort.searchSorted(a, address(uint160(i + n)));\n                assertFalse(found);\n            }\n        }\n    }\n\n    function testInsertionSortInts() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                int256[] memory a = _randomInts(_bound(_random(), 0, 8));\n                LibSort.insertionSort(a);\n                assertTrue(_isSorted(a));\n            }\n        }\n    }\n\n    function testSortInts() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                int256[] memory a = _randomInts(_bound(_random(), 0, 64));\n                LibSort.insertionSort(a);\n                assertTrue(_isSorted(a));\n            }\n        }\n    }\n\n    function testTwoComplementConversionSort(int256 a, int256 b) public {\n        uint256 w = 1 << 255;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aConverted := add(a, w)\n            let bConverted := add(b, w)\n            if iszero(lt(aConverted, bConverted)) {\n                let t := aConverted\n                aConverted := bConverted\n                bConverted := t\n            }\n            a := add(aConverted, w)\n            b := add(bConverted, w)\n        }\n        assertTrue(a <= b);\n    }\n\n    function testReverse() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                uint256 n = _bound(_random(), 0, 8);\n                uint256[] memory a = new uint256[](n);\n                uint256[] memory reversed = new uint256[](n);\n                for (uint256 i; i != n; ++i) {\n                    reversed[n - 1 - i] = (a[i] = _random());\n                }\n                bytes32 originalHash = keccak256(abi.encode(a));\n                LibSort.reverse(a);\n                assertEq(a, reversed);\n                LibSort.reverse(a);\n                assertEq(originalHash, keccak256(abi.encode(a)));\n            }\n        }\n    }\n\n    function testCopy(uint256) public {\n        unchecked {\n            uint256[] memory a;\n            if (_random() % 32 > 0) a = _randomUints(_random() % 4);\n            if (_random() % 32 == 0) _brutalizeMemory();\n            uint256[] memory aCopy = LibSort.copy(a);\n            if (_random() % 32 == 0) _brutalizeMemory();\n            assertEq(aCopy, a);\n            for (uint256 i; i != a.length; ++i) {\n                aCopy[i] *= 2;\n            }\n            for (uint256 i; i != a.length; ++i) {\n                assertEq(aCopy[i], a[i] * 2);\n            }\n        }\n    }\n\n    function testSortedUnionDifferential(uint256) public {\n        (uint256[] memory a, uint256[] memory b) = _randomUintsPair();\n        uint256[] memory c = LibSort.union(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _unionOriginal(a, b));\n    }\n\n    function testSortedUnionDifferential() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                testSortedUnionDifferential(t);\n            }\n        }\n    }\n\n    function testSortedUnionDifferentialInt(uint256) public {\n        (int256[] memory a, int256[] memory b) = _randomIntsPair();\n        int256[] memory c = LibSort.union(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _unionOriginal(a, b));\n    }\n\n    function testSortedIntersectionDifferential(uint256) public {\n        (uint256[] memory a, uint256[] memory b) = _randomUintsPair();\n        uint256[] memory c = LibSort.intersection(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _intersectionOriginal(a, b));\n    }\n\n    function testSortedIntersectionDifferential() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                testSortedIntersectionDifferential(t);\n            }\n        }\n    }\n\n    function testSortedIntersectionDifferentialInt(uint256) public {\n        (int256[] memory a, int256[] memory b) = _randomIntsPair();\n        int256[] memory c = LibSort.intersection(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _intersectionOriginal(a, b));\n    }\n\n    function testSortedDifferenceDifferential(uint256) public {\n        (uint256[] memory a, uint256[] memory b) = _randomUintsPair();\n        uint256[] memory c = LibSort.difference(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _differenceOriginal(a, b));\n    }\n\n    function testSortedDifferenceDifferential() public {\n        unchecked {\n            for (uint256 t; t != 16; ++t) {\n                testSortedDifferenceDifferential(t);\n            }\n        }\n    }\n\n    function testSortedDifferenceDifferentialInt(uint256) public {\n        (int256[] memory a, int256[] memory b) = _randomIntsPair();\n        int256[] memory c = LibSort.difference(a, b);\n        assertTrue(_isSorted(c));\n        assertEq(c, _differenceOriginal(a, b));\n    }\n\n    function testSortedDifferenceUnionIntersection(uint256) public {\n        unchecked {\n            bool found;\n            (uint256[] memory a, uint256[] memory b) = _randomUintsPair();\n\n            uint256[] memory aSubB = LibSort.difference(a, b);\n            assertTrue(_isSorted(aSubB));\n            for (uint256 i; i != aSubB.length; ++i) {\n                (found,) = LibSort.searchSorted(a, aSubB[i]);\n                assertTrue(found);\n                (found,) = LibSort.searchSorted(b, aSubB[i]);\n                assertFalse(found);\n            }\n            for (uint256 i; i != b.length; ++i) {\n                (found,) = LibSort.searchSorted(aSubB, b[i]);\n                assertFalse(found);\n            }\n\n            uint256[] memory bSubA = LibSort.difference(b, a);\n            assertTrue(_isSorted(bSubA));\n            for (uint256 i; i != bSubA.length; ++i) {\n                (found,) = LibSort.searchSorted(b, bSubA[i]);\n                assertTrue(found);\n                (found,) = LibSort.searchSorted(a, bSubA[i]);\n                assertFalse(found);\n            }\n            for (uint256 i; i != a.length; ++i) {\n                (found,) = LibSort.searchSorted(bSubA, a[i]);\n                assertFalse(found);\n            }\n\n            uint256[] memory aIntersectionB = LibSort.intersection(a, b);\n            for (uint256 i; i != aIntersectionB.length; ++i) {\n                (found,) = LibSort.searchSorted(b, aIntersectionB[i]);\n                assertTrue(found);\n                (found,) = LibSort.searchSorted(a, aIntersectionB[i]);\n                assertTrue(found);\n            }\n\n            uint256[] memory aUnionB = LibSort.union(a, b);\n            uint256[] memory aSubBUnionBSubA = LibSort.union(aSubB, bSubA);\n            uint256[] memory emptySet;\n            assertEq(emptySet, LibSort.intersection(aSubB, bSubA));\n            assertEq(emptySet, LibSort.intersection(aSubBUnionBSubA, aIntersectionB));\n            assertEq(a, LibSort.union(aIntersectionB, aSubB));\n            assertEq(b, LibSort.union(aIntersectionB, bSubA));\n            assertEq(aIntersectionB, LibSort.intersection(b, a));\n            assertEq(aUnionB, LibSort.union(b, a));\n            assertEq(LibSort.union(aSubB, b), LibSort.union(b, aSubB));\n            assertEq(LibSort.union(bSubA, a), LibSort.union(a, bSubA));\n            assertEq(aUnionB, LibSort.union(aSubBUnionBSubA, aIntersectionB));\n        }\n    }\n\n    function testIsSortedDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = _random() % 4;\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            if (n != 0) {\n                a[_random() % n] = 0;\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n        }\n    }\n\n    function testIsSortedIntsDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            int256[] memory a = new int256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = int256(_random() % 4);\n                if (_random() % 2 == 0) {\n                    a[i] = -a[i];\n                }\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            if (n != 0) {\n                a[_random() % n] = 0;\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n        }\n    }\n\n    function testIsSortedAddressesDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = address(uint160(_random() % 4));\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n            if (n != 0) {\n                a[_random() % n] = address(0);\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSorted(a), _isSorted(a));\n        }\n    }\n\n    function testIsSortedAndUniquifiedDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            uint256[] memory a = new uint256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = _random() % 4;\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            if (n != 0) {\n                a[_random() % n] = 0;\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n        }\n    }\n\n    function testIsSortedAndUniquifiedIntsDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            int256[] memory a = new int256[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = int256(_random() % 4);\n                if (_random() % 2 == 0) {\n                    a[i] = -a[i];\n                }\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            if (n != 0) {\n                a[_random() % n] = 0;\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n        }\n    }\n\n    function testIsSortedAndUniquifiedAddressesDifferential(uint256) public {\n        unchecked {\n            uint256 n = _random() % 2 == 0 ? _random() % 4 : _randomArrayLength();\n            address[] memory a = new address[](n);\n            for (uint256 i; i != n; ++i) {\n                a[i] = address(uint160(_random() % 4));\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            LibSort.sort(a);\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n            if (n != 0) {\n                a[_random() % n] = address(0);\n                if (_random() % 2 == 0) {\n                    a[_random() % n] = a[_random() % n];\n                }\n            }\n            assertEq(LibSort.isSortedAndUniquified(a), _isSortedAndUniquified(a));\n        }\n    }\n\n    function _unionOriginal(uint256[] memory a, uint256[] memory b)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        unchecked {\n            c = new uint256[](a.length + b.length);\n            uint256 o;\n            for (uint256 i; i != a.length; ++i) {\n                c[o++] = a[i];\n            }\n            for (uint256 i; i != b.length; ++i) {\n                c[o++] = b[i];\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _unionOriginal(int256[] memory a, int256[] memory b)\n        private\n        pure\n        returns (int256[] memory c)\n    {\n        unchecked {\n            c = new int256[](a.length + b.length);\n            uint256 o;\n            for (uint256 i; i != a.length; ++i) {\n                c[o++] = a[i];\n            }\n            for (uint256 i; i != b.length; ++i) {\n                c[o++] = b[i];\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _intersectionOriginal(uint256[] memory a, uint256[] memory b)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        unchecked {\n            c = new uint256[](a.length + b.length);\n            uint256 o;\n            bool found;\n            for (uint256 i; i != a.length; ++i) {\n                (found,) = LibSort.searchSorted(b, a[i]);\n                if (found) c[o++] = a[i];\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(c, o)\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _intersectionOriginal(int256[] memory a, int256[] memory b)\n        private\n        pure\n        returns (int256[] memory c)\n    {\n        unchecked {\n            c = new int256[](a.length + b.length);\n            uint256 o;\n            bool found;\n            for (uint256 i; i != a.length; ++i) {\n                (found,) = LibSort.searchSorted(b, a[i]);\n                if (found) c[o++] = a[i];\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(c, o)\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _differenceOriginal(uint256[] memory a, uint256[] memory b)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        unchecked {\n            c = new uint256[](a.length + b.length);\n            uint256 o;\n            bool found;\n            for (uint256 i; i != a.length; ++i) {\n                (found,) = LibSort.searchSorted(b, a[i]);\n                if (!found) c[o++] = a[i];\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(c, o)\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _differenceOriginal(int256[] memory a, int256[] memory b)\n        private\n        pure\n        returns (int256[] memory c)\n    {\n        unchecked {\n            c = new int256[](a.length + b.length);\n            uint256 o;\n            bool found;\n            for (uint256 i; i != a.length; ++i) {\n                (found,) = LibSort.searchSorted(b, a[i]);\n                if (!found) c[o++] = a[i];\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(c, o)\n            }\n            LibSort.insertionSort(c);\n            LibSort.uniquifySorted(c);\n        }\n    }\n\n    function _isSorted(address[] memory a) private pure returns (bool) {\n        unchecked {\n            for (uint256 i = 1; i < a.length; ++i) {\n                if (a[i - 1] > a[i]) return false;\n            }\n            return true;\n        }\n    }\n\n    function _isSorted(uint256[] memory a) private pure returns (bool) {\n        unchecked {\n            for (uint256 i = 1; i < a.length; ++i) {\n                if (a[i - 1] > a[i]) return false;\n            }\n            return true;\n        }\n    }\n\n    function _isSorted(int256[] memory a) private pure returns (bool) {\n        unchecked {\n            for (uint256 i = 1; i < a.length; ++i) {\n                if (a[i - 1] > a[i]) return false;\n            }\n            return true;\n        }\n    }\n\n    function _isSortedAndUniquified(uint256[] memory a) private pure returns (bool) {\n        if (a.length == 0) {\n            return true;\n        }\n        unchecked {\n            uint256 end = a.length - 1;\n            for (uint256 i = 0; i != end; ++i) {\n                if (a[i] >= a[i + 1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function _isSortedAndUniquified(int256[] memory a) private pure returns (bool) {\n        if (a.length == 0) {\n            return true;\n        }\n        unchecked {\n            uint256 end = a.length - 1;\n            for (uint256 i = 0; i != end; ++i) {\n                if (a[i] >= a[i + 1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function _isSortedAndUniquified(address[] memory a) private pure returns (bool) {\n        if (a.length == 0) {\n            return true;\n        }\n        unchecked {\n            uint256 end = a.length - 1;\n            for (uint256 i = 0; i != end; ++i) {\n                if (a[i] >= a[i + 1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function _sortOriginal(uint256[] memory a) internal pure {\n        _sortOriginal(a, 0, int256(a.length - 1));\n    }\n\n    function _sortOriginal(uint256[] memory arr, int256 left, int256 right) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) {\n                unchecked {\n                    ++i;\n                }\n            }\n            while (pivot < arr[uint256(j)]) {\n                unchecked {\n                    --j;\n                }\n            }\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                unchecked {\n                    ++i;\n                    --j;\n                }\n            }\n        }\n        if (left < j) _sortOriginal(arr, left, j);\n        if (i < right) _sortOriginal(arr, i, right);\n    }\n\n    function _copy(uint256[] memory a) private view returns (uint256[] memory b) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := mload(0x40)\n            let n := add(shl(5, mload(a)), 0x20)\n            pop(staticcall(gas(), 4, a, n, b, n))\n            mstore(0x40, add(b, n))\n        }\n    }\n\n    function _copy(int256[] memory a) private view returns (int256[] memory b) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := mload(0x40)\n            let n := add(shl(5, mload(a)), 0x20)\n            pop(staticcall(gas(), 4, a, n, b, n))\n            mstore(0x40, add(b, n))\n        }\n    }\n\n    function _copy(address[] memory a) private view returns (address[] memory b) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := mload(0x40)\n            let n := add(shl(5, mload(a)), 0x20)\n            pop(staticcall(gas(), 4, a, n, b, n))\n            mstore(0x40, add(b, n))\n        }\n    }\n\n    function _randomUints(uint256 n) private returns (uint256[] memory a) {\n        unchecked {\n            _misalignFreeMemoryPointer();\n            /// @solidity memory-safe-assembly\n            assembly {\n                a := mload(0x40)\n                mstore(a, n)\n                mstore(0x40, add(add(0x20, a), shl(5, n)))\n            }\n            for (uint256 i; i != n; ++i) {\n                a[i] = _random();\n            }\n        }\n    }\n\n    function _randomAddresses(uint256 n) private returns (address[] memory a) {\n        unchecked {\n            _misalignFreeMemoryPointer();\n            /// @solidity memory-safe-assembly\n            assembly {\n                a := mload(0x40)\n                mstore(a, n)\n                mstore(0x40, add(add(0x20, a), shl(5, n)))\n            }\n            for (uint256 i; i != n; ++i) {\n                a[i] = address(uint160(_random()));\n            }\n        }\n    }\n\n    function _randomInts(uint256 n) private returns (int256[] memory a) {\n        unchecked {\n            uint256[] memory aRaw = _randomUints(n);\n            /// @solidity memory-safe-assembly\n            assembly {\n                a := aRaw\n            }\n        }\n    }\n\n    function _uniquifyOriginal(uint256[] memory a) private pure {\n        if (a.length != 0) {\n            unchecked {\n                uint256 n = a.length;\n                uint256 i = 0;\n                for (uint256 j = 1; j < n; j++) {\n                    if (a[i] != a[j]) {\n                        i++;\n                        a[i] = a[j];\n                    }\n                }\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore(a, add(i, 1))\n                }\n            }\n        }\n    }\n\n    function _randomUintsPair() private returns (uint256[] memory a, uint256[] memory b) {\n        uint256 r = _random();\n        a = _randomUints(r & 7);\n        b = _randomUints((r >> 128) & 7);\n        LibSort.insertionSort(a);\n        LibSort.uniquifySorted(a);\n        LibSort.insertionSort(b);\n        LibSort.uniquifySorted(b);\n    }\n\n    function _randomAddressesPair() private returns (address[] memory a, address[] memory b) {\n        uint256 r = _random();\n        a = _randomAddresses(r & 7);\n        b = _randomAddresses((r >> 128) & 7);\n        LibSort.insertionSort(a);\n        LibSort.uniquifySorted(a);\n        LibSort.insertionSort(b);\n        LibSort.uniquifySorted(b);\n    }\n\n    function _randomIntsPair() private returns (int256[] memory a, int256[] memory b) {\n        uint256 r = _random();\n        a = _randomInts(r & 7);\n        b = _randomInts((r >> 128) & 7);\n        LibSort.insertionSort(a);\n        LibSort.uniquifySorted(a);\n        LibSort.insertionSort(b);\n        LibSort.uniquifySorted(b);\n    }\n\n    function _randomArrayLength() internal returns (uint256 r) {\n        r = _random();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := 0x070707070707070707070707070707070f0f0f0f0f0f0f1f1f1f1f1f1f3f7fff\n            r := and(byte(1, r), byte(and(r, 31), m))\n        }\n    }\n\n    function _randomNonZeroArrayLength() internal returns (uint256 r) {\n        do {\n            r = _randomArrayLength();\n        } while (r == 0);\n    }\n}\n",
        "contractname": "LibSort.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\nlibrary LibClone {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(result, 0x28), implementation)\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(result, 0x35) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(result, 0x26), implementation) // 20\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(result, 0x36) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Note: This implementation of CWIA differs from the original implementation.\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        instance = clone(0, implementation, data);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, data, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    function initCode(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let dataLength := mload(data)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            let o := add(result, 0x8c)\n            let end := add(o, dataLength)\n\n            // Copy the `data` into `result`.\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(o, 0x20)\n                if iszero(lt(o, end)) { break }\n            }\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                add(result, 0x4b),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                add(result, 0x32),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                add(result, 0x12),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(end, shl(0xf0, extraLength))\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\n            mstore(0x40, add(0x22, end)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x60),\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\n            )\n            mstore(\n                add(result, 0x40),\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\n            )\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\n            mstore(result, 0x5f) // Store the length.\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             *                                                                                  |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x74),\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\n            )\n            mstore(\n                add(result, 0x54),\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\n            )\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(result, 0x1d), implementation)\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\n            mstore(add(result, 0x94), 0)\n            mstore(result, 0x74) // Store the length.\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\n    // independent of the implementation:\n    // ```\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\n    // ```\n\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\n        bootstrap = constantERC1967BootstrapAddress();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\n                mstore(0x00, 0x60258060093d393df358357f36)\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\n    }\n\n    /// @dev Replaces the implementation at `instance`.\n    function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, shr(96, shl(96, implementation)))\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {Clone} from \"../src/utils/Clone.sol\";\nimport {SafeTransferLib} from \"../src/utils/SafeTransferLib.sol\";\n\ncontract LibCloneTest is SoladyTest, Clone {\n    error CustomError(uint256 currentValue);\n\n    event ReceiveETH(uint256 amount);\n\n    uint256 public value;\n\n    mapping(bytes32 => bool) saltIsUsed;\n\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function setValue(uint256 value_) public {\n        value = value_;\n    }\n\n    function revertWithError() public view {\n        revert CustomError(value);\n    }\n\n    function getCalldataHash() public pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let extraLength := shr(0xf0, calldataload(sub(calldatasize(), 2)))\n            if iszero(lt(extraLength, 2)) {\n                let offset := sub(calldatasize(), extraLength)\n                let m := mload(0x40)\n                calldatacopy(m, offset, sub(extraLength, 2))\n                result := keccak256(m, sub(extraLength, 2))\n            }\n        }\n    }\n\n    function _canReceiveETHCorrectly(address clone, uint256 deposit) internal {\n        deposit = deposit % 1 ether;\n\n        vm.deal(address(this), deposit * 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit ReceiveETH(deposit);\n        SafeTransferLib.safeTransferETH(clone, deposit);\n        assertEq(clone.balance, deposit);\n\n        vm.expectEmit(true, true, true, true);\n        emit ReceiveETH(deposit);\n        payable(clone).transfer(deposit);\n        assertEq(clone.balance, deposit * 2);\n    }\n\n    function _shouldBehaveLikeClone(address clone, uint256 value_) internal {\n        assertTrue(clone != address(0));\n\n        uint256 thisValue = this.value();\n        if (thisValue == value_) {\n            value_ ^= 1;\n        }\n        LibCloneTest(clone).setValue(value_);\n        assertEq(value_, LibCloneTest(clone).value());\n        assertEq(thisValue, this.value());\n        vm.expectRevert(abi.encodeWithSelector(CustomError.selector, value_));\n        LibCloneTest(clone).revertWithError();\n    }\n\n    function testDeployERC1967(uint256 value_) public {\n        address clone = LibClone.deployERC1967(address(this));\n        _shouldBehaveLikeClone(clone, value_);\n        assertEq(\n            vm.load(clone, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function testDeployERC1967I(uint256 value_) public {\n        address clone = LibClone.deployERC1967I(address(this));\n        _shouldBehaveLikeClone(clone, value_);\n        assertEq(\n            vm.load(clone, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function testDeployERC1967() public {\n        testDeployERC1967(1);\n    }\n\n    function testDeployERC1967I() public {\n        testDeployERC1967I(1);\n    }\n\n    function testDeployERC1967ISpecialPath(address impl, bytes1 data) public {\n        address clone = LibClone.deployERC1967I(impl);\n        (, bytes memory rd) = clone.call(abi.encodePacked(data));\n        assertEq(impl, abi.decode(rd, (address)));\n    }\n\n    function testDeployERC1967ISpecialPath() public {\n        address clone = LibClone.deployERC1967I(address(this));\n        (, bytes memory rd) = clone.call(\"I\");\n        assertEq(address(this), abi.decode(rd, (address)));\n    }\n\n    function testDeployERC1967CodeHashAndLength(address impl) public {\n        assertEq(keccak256(LibClone.deployERC1967(impl).code), LibClone.ERC1967_CODE_HASH);\n        assertEq(LibClone.deployERC1967(impl).code.length, 61);\n    }\n\n    function testDeployERC1967ICodeHashAndLength(address impl) public {\n        assertEq(keccak256(LibClone.deployERC1967I(impl).code), LibClone.ERC1967I_CODE_HASH);\n        assertEq(LibClone.deployERC1967I(impl).code.length, 82);\n    }\n\n    function testClone(uint256 value_) public {\n        address clone = LibClone.clone(address(this));\n        _shouldBehaveLikeClone(clone, value_);\n    }\n\n    function testClone() public {\n        testClone(1);\n    }\n\n    function testCloneDeterministic(uint256 value_, bytes32 salt) public {\n        if (saltIsUsed[salt]) {\n            vm.expectRevert(LibClone.DeploymentFailed.selector);\n            this.cloneDeterministic(address(this), salt);\n            return;\n        }\n\n        address clone = this.cloneDeterministic(address(this), salt);\n        saltIsUsed[salt] = true;\n\n        _shouldBehaveLikeClone(clone, value_);\n\n        address predicted = LibClone.predictDeterministicAddress(address(this), salt, address(this));\n        assertEq(clone, predicted);\n    }\n\n    function cloneDeterministic(address implementation, bytes32 salt) external returns (address) {\n        return LibClone.cloneDeterministic(_brutalized(implementation), salt);\n    }\n\n    function cloneDeterministic(address implementation, bytes calldata data, bytes32 salt)\n        external\n        returns (address)\n    {\n        return LibClone.cloneDeterministic(_brutalized(implementation), data, salt);\n    }\n\n    function testCloneDeterministicRevertsIfAddressAlreadyUsed() public {\n        testCloneDeterministic(1, keccak256(\"a\"));\n        testCloneDeterministic(1, keccak256(\"a\"));\n    }\n\n    function testCloneDeterministic() public {\n        testCloneDeterministic(1, keccak256(\"b\"));\n    }\n\n    function testDeployDeterministicERC1967(uint256 value_, bytes32 salt) public {\n        if (saltIsUsed[salt]) {\n            vm.expectRevert(LibClone.DeploymentFailed.selector);\n            this.deployDeterministicERC1967(address(this), salt);\n            return;\n        }\n\n        address clone = this.deployDeterministicERC1967(address(this), salt);\n        saltIsUsed[salt] = true;\n\n        _shouldBehaveLikeClone(clone, value_);\n\n        address predicted =\n            LibClone.predictDeterministicAddressERC1967(address(this), salt, address(this));\n        assertEq(clone, predicted);\n\n        assertEq(\n            vm.load(clone, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        external\n        returns (address)\n    {\n        return LibClone.deployDeterministicERC1967(_brutalized(implementation), salt);\n    }\n\n    function testDeployDeterministicERC1967() public {\n        testDeployDeterministicERC1967(1, keccak256(\"b\"));\n    }\n\n    function testDeployDeterministicERC1967I(uint256 value_, bytes32 salt) public {\n        if (saltIsUsed[salt]) {\n            vm.expectRevert(LibClone.DeploymentFailed.selector);\n            this.deployDeterministicERC1967I(address(this), salt);\n            return;\n        }\n\n        address clone = this.deployDeterministicERC1967I(address(this), salt);\n        saltIsUsed[salt] = true;\n\n        _shouldBehaveLikeClone(clone, value_);\n\n        address predicted =\n            LibClone.predictDeterministicAddressERC1967I(address(this), salt, address(this));\n        assertEq(clone, predicted);\n\n        assertEq(\n            vm.load(clone, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        external\n        returns (address)\n    {\n        return LibClone.deployDeterministicERC1967I(_brutalized(implementation), salt);\n    }\n\n    function testDeployDeterministicERC1967I() public {\n        testDeployDeterministicERC1967I(1, keccak256(\"b\"));\n    }\n\n    function testCreateDeterministicERC1967(uint256 value_, bytes32 salt) public {\n        if (saltIsUsed[salt]) {\n            (bool deployed, address clone) =\n                LibClone.createDeterministicERC1967(address(this), salt);\n            assertEq(deployed, true);\n            assertEq(\n                clone,\n                LibClone.predictDeterministicAddressERC1967(address(this), salt, address(this))\n            );\n            return;\n        }\n\n        (bool deployed_, address clone_) = LibClone.createDeterministicERC1967(address(this), salt);\n        assertEq(deployed_, false);\n        saltIsUsed[salt] = true;\n\n        _shouldBehaveLikeClone(clone_, value_);\n\n        address predicted =\n            LibClone.predictDeterministicAddressERC1967(address(this), salt, address(this));\n        assertEq(clone_, predicted);\n\n        assertEq(\n            vm.load(clone_, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function testCreateDeterministicERC1967I(uint256 value_, bytes32 salt) public {\n        if (saltIsUsed[salt]) {\n            (bool deployed, address clone) =\n                LibClone.createDeterministicERC1967I(address(this), salt);\n            assertEq(deployed, true);\n            assertEq(\n                clone,\n                LibClone.predictDeterministicAddressERC1967I(address(this), salt, address(this))\n            );\n            return;\n        }\n\n        (bool deployed_, address clone_) = LibClone.createDeterministicERC1967I(address(this), salt);\n        assertEq(deployed_, false);\n        saltIsUsed[salt] = true;\n\n        _shouldBehaveLikeClone(clone_, value_);\n\n        address predicted =\n            LibClone.predictDeterministicAddressERC1967I(address(this), salt, address(this));\n        assertEq(clone_, predicted);\n\n        assertEq(\n            vm.load(clone_, _ERC1967_IMPLEMENTATION_SLOT), bytes32(uint256(uint160(address(this))))\n        );\n    }\n\n    function getArgBytes(uint256 argOffset, uint256 length) public pure returns (bytes memory) {\n        return _getArgBytes(argOffset, length);\n    }\n\n    function getArgAddress(uint256 argOffset) public pure returns (address) {\n        return _getArgAddress(argOffset);\n    }\n\n    function getArgUint256(uint256 argOffset) public pure returns (uint256) {\n        uint256 result = _getArgUint256(argOffset);\n        unchecked {\n            require(bytes32(result) == _getArgBytes32(argOffset));\n            require(uint248(result) == _getArgUint248(argOffset + 1));\n            require(uint240(result) == _getArgUint240(argOffset + 2));\n            require(uint232(result) == _getArgUint232(argOffset + 3));\n            require(uint224(result) == _getArgUint224(argOffset + 4));\n            require(uint216(result) == _getArgUint216(argOffset + 5));\n            require(uint208(result) == _getArgUint208(argOffset + 6));\n            require(uint200(result) == _getArgUint200(argOffset + 7));\n            require(uint192(result) == _getArgUint192(argOffset + 8));\n            require(uint184(result) == _getArgUint184(argOffset + 9));\n            require(uint176(result) == _getArgUint176(argOffset + 10));\n            require(uint168(result) == _getArgUint168(argOffset + 11));\n            require(uint160(result) == _getArgUint160(argOffset + 12));\n            require(uint152(result) == _getArgUint152(argOffset + 13));\n            require(uint144(result) == _getArgUint144(argOffset + 14));\n            require(uint136(result) == _getArgUint136(argOffset + 15));\n            require(uint128(result) == _getArgUint128(argOffset + 16));\n            require(uint120(result) == _getArgUint120(argOffset + 17));\n            require(uint112(result) == _getArgUint112(argOffset + 18));\n            require(uint104(result) == _getArgUint104(argOffset + 19));\n            require(uint96(result) == _getArgUint96(argOffset + 20));\n            require(uint88(result) == _getArgUint88(argOffset + 21));\n            require(uint80(result) == _getArgUint80(argOffset + 22));\n            require(uint72(result) == _getArgUint72(argOffset + 23));\n            require(uint64(result) == _getArgUint64(argOffset + 24));\n            require(uint56(result) == _getArgUint56(argOffset + 25));\n            require(uint48(result) == _getArgUint48(argOffset + 26));\n            require(uint40(result) == _getArgUint40(argOffset + 27));\n            require(uint32(result) == _getArgUint32(argOffset + 28));\n            require(uint24(result) == _getArgUint24(argOffset + 29));\n            require(uint16(result) == _getArgUint16(argOffset + 30));\n            require(uint8(result) == _getArgUint8(argOffset + 31));\n        }\n        return result;\n    }\n\n    function getArgUint256Array(uint256 argOffset, uint256 length)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory result = _getArgUint256Array(argOffset, length);\n        bytes32 hash = keccak256(abi.encode(_getArgBytes32Array(argOffset, length)));\n        require(keccak256(abi.encode(result)) == hash);\n        return result;\n    }\n\n    function getArgUint64(uint256 argOffset) public pure returns (uint64) {\n        return _getArgUint64(argOffset);\n    }\n\n    function getArgUint8(uint256 argOffset) public pure returns (uint8) {\n        return _getArgUint8(argOffset);\n    }\n\n    function testCloneWithImmutableArgs(\n        uint256 value_,\n        address argAddress,\n        uint256 argUint256,\n        uint256[] memory argUint256Array,\n        uint64 argUint64,\n        uint8 argUint8\n    ) public {\n        bytes memory data =\n            abi.encodePacked(argAddress, argUint256, argUint256Array, argUint64, argUint8);\n        LibCloneTest clone = LibCloneTest(LibClone.clone(address(this), data));\n        _shouldBehaveLikeClone(address(clone), value_);\n\n        // For avoiding stack too deep. Also, no risk of overflow.\n        unchecked {\n            uint256 argOffset;\n            assertEq(clone.getArgAddress(argOffset), argAddress);\n            argOffset += 20;\n            assertEq(clone.getArgUint256(argOffset), argUint256);\n            argOffset += 32;\n            assertEq(clone.getArgUint256Array(argOffset, argUint256Array.length), argUint256Array);\n            argOffset += 32 * argUint256Array.length;\n            assertEq(clone.getArgUint64(argOffset), argUint64);\n            argOffset += 8;\n            assertEq(clone.getArgUint8(argOffset), argUint8);\n        }\n    }\n\n    function testCloneWithImmutableArgs() public {\n        uint256[] memory argUint256Array = new uint256[](2);\n        argUint256Array[0] = 111;\n        argUint256Array[1] = 222;\n        testCloneWithImmutableArgs(1, address(uint160(0xB00Ba5)), 8, argUint256Array, 7, 6);\n    }\n\n    function testCloneDeteministicWithImmutableArgs(\n        address argAddress,\n        uint256 argUint256,\n        uint256[] memory argUint256Array,\n        bytes memory argBytes,\n        uint64 argUint64,\n        uint8 argUint8,\n        uint256 deposit\n    ) public {\n        bytes memory data;\n        bytes32 salt;\n\n        // For avoiding stack too deep.\n        unchecked {\n            // Recycle for the salt.\n            salt = bytes32(argUint256 + 123);\n\n            data = abi.encodePacked(\n                argUint256,\n                argAddress,\n                argUint256,\n                argUint256Array,\n                argBytes,\n                argUint64,\n                argUint8,\n                argUint256\n            );\n\n            bytes32 saltKey = keccak256(abi.encode(data, salt));\n            if (saltIsUsed[saltKey]) {\n                vm.expectRevert(LibClone.DeploymentFailed.selector);\n                LibCloneTest(this.cloneDeterministic(address(this), data, salt));\n                return;\n            }\n            saltIsUsed[saltKey] = true;\n        }\n\n        bytes32 dataHashBefore = keccak256(data);\n\n        LibCloneTest clone = LibCloneTest(this.cloneDeterministic(address(this), data, salt));\n        // Check that memory management is done properly.\n        assertEq(keccak256(data), dataHashBefore);\n\n        _shouldBehaveLikeClone(address(clone), argUint256);\n        _canReceiveETHCorrectly(address(clone), deposit);\n\n        // For avoiding stack too deep. Also, no risk of overflow.\n        unchecked {\n            uint256 argOffset;\n            assertEq(clone.getArgUint256(argOffset), argUint256);\n            argOffset += (256 / 8);\n            assertEq(clone.getArgAddress(argOffset), argAddress);\n            argOffset += (160 / 8);\n            assertEq(clone.getArgUint256(argOffset), argUint256);\n            argOffset += (256 / 8);\n            assertEq(clone.getArgUint256Array(argOffset, argUint256Array.length), argUint256Array);\n            argOffset += (256 / 8) * argUint256Array.length;\n            assertEq(clone.getArgBytes(argOffset, argBytes.length), argBytes);\n            argOffset += (8 / 8) * argBytes.length;\n            assertEq(clone.getArgUint64(argOffset), argUint64);\n            argOffset += (64 / 8);\n            assertEq(clone.getArgUint8(argOffset), argUint8);\n            argOffset += (8 / 8);\n            assertEq(clone.getArgUint256(argOffset), argUint256);\n        }\n\n        {\n            address predicted =\n                LibClone.predictDeterministicAddress(address(this), data, salt, address(this));\n            assertEq(address(clone), predicted);\n        }\n\n        // Check that memory management is done properly.\n        assertEq(keccak256(data), dataHashBefore);\n\n        assertEq(clone.getCalldataHash(), dataHashBefore);\n    }\n\n    function testCloneDeteministicWithImmutableArgs() public {\n        uint256[] memory argUint256Array = new uint256[](2);\n        argUint256Array[0] = uint256(keccak256(\"zero\"));\n        argUint256Array[1] = uint256(keccak256(\"one\"));\n        bytes memory argBytes = bytes(\"Teehee\");\n        testCloneDeteministicWithImmutableArgs(\n            address(uint160(uint256(keccak256(\"argAddress\")))),\n            uint256(keccak256(\"argUint256\")),\n            argUint256Array,\n            argBytes,\n            uint64(uint256(keccak256(\"argUint64\"))),\n            uint8(uint256(keccak256(\"argUint8\"))),\n            uint256(keccak256(\"deposit\"))\n        );\n    }\n\n    function testStartsWith(uint256) public {\n        uint256 noise = _random() >> 160;\n        this.checkStartsWith(bytes32(noise), address(0));\n\n        address by = _randomNonZeroAddress();\n        this.checkStartsWith(bytes32((uint256(uint160(by)) << 96) | noise), by);\n\n        address notBy;\n        while (by == notBy) notBy = _randomNonZeroAddress();\n        vm.expectRevert(LibClone.SaltDoesNotStartWith.selector);\n        this.checkStartsWith(bytes32((uint256(uint160(by)) << 96) | noise), notBy);\n    }\n\n    function checkStartsWith(bytes32 salt, address by) public pure {\n        LibClone.checkStartsWith(salt, _brutalized(by));\n    }\n\n    function testCloneWithImmutableArgsRevertsIfDataTooBig() public {\n        uint256 n = 0xff9b;\n        bytes memory data = _dummyData(n);\n\n        address clone = this.cloneDeterministic(address(this), data, bytes32(gasleft()));\n        _shouldBehaveLikeClone(clone, 1);\n        assertEq(LibCloneTest(clone).argBytesHash(), keccak256(data));\n\n        vm.expectRevert();\n        this.cloneDeterministic(address(this), _dummyData(n + 1), bytes32(gasleft()));\n    }\n\n    function testInitialDeposit() public {\n        vm.deal(address(this), 1 ether);\n        address t = address(this);\n        assertEq(LibClone.clone(123, t).balance, 123);\n        assertEq(LibClone.cloneDeterministic(123, t, bytes32(gasleft())).balance, 123);\n        assertEq(LibClone.clone(123, t, \"\").balance, 123);\n        assertEq(LibClone.cloneDeterministic(123, t, \"\", bytes32(gasleft())).balance, 123);\n        assertEq(LibClone.deployERC1967(123, t).balance, 123);\n        assertEq(LibClone.deployDeterministicERC1967(123, t, bytes32(gasleft())).balance, 123);\n    }\n\n    function argBytesHash() public pure returns (bytes32) {\n        return keccak256(_getArgBytes());\n    }\n\n    function _dummyData(uint256 n) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x00, n)\n            mstore(0x20, 1)\n            mstore(add(0x20, result), keccak256(0x00, 0x40))\n            mstore(0x20, 2)\n            mstore(add(add(0x20, result), n), keccak256(0x00, 0x40))\n            mstore(0x20, 3)\n            mstore(add(result, n), keccak256(0x00, 0x40))\n            mstore(0x40, add(add(0x20, result), n))\n            mstore(result, n)\n        }\n    }\n\n    function testInitCode(address implementation, uint256 r, uint256 c) public {\n        if (c & (1 << 0) == 0) _testInitCode(implementation);\n        if (c & (1 << 1) == 0) _testInitCode_PUSH0(implementation);\n        if (c & (1 << 2) == 0) _testInitCode(implementation, r);\n        if (c & (1 << 3) == 0) _testInitCodeERC1967(implementation);\n        if (c & (1 << 4) == 0) _testInitCodeERC1967I(implementation);\n    }\n\n    function _testInitCode(address implementation) internal {\n        _brutalizeMemory();\n        bytes memory initCode = LibClone.initCode(_brutalized(implementation));\n        _checkMemory(initCode);\n        _brutalizeMemory();\n        bytes32 expected = LibClone.initCodeHash(_brutalized(implementation));\n        _checkMemory(initCode);\n        assertEq(keccak256(initCode), expected);\n    }\n\n    function _testInitCode_PUSH0(address implementation) internal {\n        _brutalizeMemory();\n        bytes memory initCode = LibClone.initCode_PUSH0(_brutalized(implementation));\n        _checkMemory(initCode);\n        _brutalizeMemory();\n        bytes32 expected = LibClone.initCodeHash_PUSH0(_brutalized(implementation));\n        _checkMemory(initCode);\n        assertEq(keccak256(initCode), expected);\n    }\n\n    function _testInitCode(address implementation, uint256 n) internal {\n        _brutalizeMemory();\n        bytes memory data;\n        if ((n >> 32) & 31 > 0) data = _dummyData((n >> 128) & 0xff);\n        bytes memory initCode = LibClone.initCode(implementation, data);\n        _checkMemory(initCode);\n        _brutalizeMemory();\n        bytes32 expected = LibClone.initCodeHash(implementation, data);\n        _checkMemory(initCode);\n        assertEq(keccak256(initCode), expected);\n    }\n\n    function _testInitCodeERC1967(address implementation) internal {\n        _brutalizeMemory();\n        bytes memory initCode = LibClone.initCodeERC1967(_brutalized(implementation));\n        _checkMemory(initCode);\n        _brutalizeMemory();\n        bytes32 expected = LibClone.initCodeHashERC1967(_brutalized(implementation));\n        _checkMemory(initCode);\n        assertEq(keccak256(initCode), expected);\n    }\n\n    function _testInitCodeERC1967I(address implementation) internal {\n        _brutalizeMemory();\n        bytes memory initCode = LibClone.initCodeERC1967I(_brutalized(implementation));\n        _checkMemory(initCode);\n        _brutalizeMemory();\n        bytes32 expected = LibClone.initCodeHashERC1967I(_brutalized(implementation));\n        _checkMemory(initCode);\n        assertEq(keccak256(initCode), expected);\n    }\n\n    function testERC1967ConstantBootstrap(address implementation, bytes32 salt) public {\n        address bootstrap = LibClone.constantERC1967BootstrapAddress();\n        assertEq(LibClone.constantERC1967Bootstrap(), bootstrap);\n        if (_random() % 2 == 0) {\n            assertEq(LibClone.constantERC1967Bootstrap(), bootstrap);\n        }\n\n        address instance;\n        if (_random() % 2 == 0) {\n            instance = LibClone.predictDeterministicAddressERC1967(bootstrap, salt, address(this));\n            assertEq(LibClone.deployDeterministicERC1967(0, bootstrap, salt), instance);\n        } else {\n            instance = LibClone.predictDeterministicAddressERC1967I(bootstrap, salt, address(this));\n            assertEq(LibClone.deployDeterministicERC1967I(0, bootstrap, salt), instance);\n        }\n\n        if (_random() % 2 == 0) {\n            LibClone.bootstrapERC1967(instance, implementation);\n            assertEq(\n                vm.load(instance, _ERC1967_IMPLEMENTATION_SLOT),\n                bytes32(uint256(uint160(implementation)))\n            );\n        } else {\n            LibClone.bootstrapERC1967(instance, address(this));\n            assertEq(\n                vm.load(instance, _ERC1967_IMPLEMENTATION_SLOT),\n                bytes32(uint256(uint160(address(this))))\n            );\n            _shouldBehaveLikeClone(instance, 1);\n        }\n    }\n}\n",
        "contractname": "LibClone.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary ECDSA {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            for {} 1 {} {\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        result, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            for {} 1 {} {\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        result, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            for {} 1 {} {\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    result, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            for {} 1 {} {\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    result, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {ECDSA} from \"../src/utils/ECDSA.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract ECDSATest is SoladyTest {\n    using ECDSA for bytes32;\n    using ECDSA for bytes;\n\n    bytes32 constant TEST_MESSAGE =\n        0x7dbaf558b0a1a5dc7a67202117ab143c1d8605a983e4a743bc06fcc03162dc0d;\n\n    bytes32 constant WRONG_MESSAGE =\n        0x2d0828dd7c97cff316356da3c16c68ba2316886a0e05ebafb8291939310d51a3;\n\n    address constant SIGNER = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;\n\n    address constant V0_SIGNER = 0x2cc1166f6212628A0deEf2B33BEFB2187D35b86c;\n\n    address constant V1_SIGNER = 0x1E318623aB09Fe6de3C9b8672098464Aeda9100E;\n\n    function testTryRecoverWithInvalidShortSignatureReturnsZero() public {\n        bytes memory signature = hex\"1234\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithInvalidLongSignatureReturnsZero() public {\n        bytes memory signature =\n            hex\"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithValidSignature() public {\n        bytes memory signature =\n            hex\"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n        assertTrue(this.tryRecover(TEST_MESSAGE.toEthSignedMessageHash(), signature) == SIGNER);\n    }\n\n    function testTryRecoverWithWrongSigner() public {\n        bytes memory signature =\n            hex\"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n        assertTrue(this.tryRecover(WRONG_MESSAGE.toEthSignedMessageHash(), signature) != SIGNER);\n    }\n\n    function testTryRecoverWithInvalidSignature() public {\n        bytes memory signature =\n            hex\"332ce75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c\";\n        assertTrue(this.tryRecover(TEST_MESSAGE.toEthSignedMessageHash(), signature) != SIGNER);\n    }\n\n    function testTryRecoverWithV0SignatureWithVersion00ReturnsZero() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89200\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithV0SignatureWithVersion27() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be8921b\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == V0_SIGNER);\n    }\n\n    function testTryRecoverWithV0SignatureWithWrongVersionReturnsZero() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89202\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithV0SignatureWithShortEIP2098Format() public {\n        bytes32 r = 0x5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f;\n        bytes32 vs = 0x3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892;\n        assertTrue(this.tryRecover(TEST_MESSAGE, r, vs) == V0_SIGNER);\n    }\n\n    function testTryRecoverWithV0SignatureWithShortEIP2098FormatAsCalldata() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == V0_SIGNER);\n    }\n\n    function testTryRecoverWithV1SignatureWithVersion01ReturnsZero() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e001\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithV1SignatureWithVersion28() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == V1_SIGNER);\n    }\n\n    function testTryRecoverWithV1SignatureWithWrongVersionReturnsZero() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e002\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == address(0));\n    }\n\n    function testTryRecoverWithV1SignatureWithShortEIP2098Format() public {\n        bytes32 r = 0x331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff;\n        bytes32 vs = 0xc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0;\n        assertTrue(this.tryRecover(TEST_MESSAGE, r, vs) == V1_SIGNER);\n    }\n\n    function testTryRecoverWithV1SignatureWithShortEIP2098FormatAsCalldata() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feffc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0\";\n        assertTrue(this.tryRecover(TEST_MESSAGE, signature) == V1_SIGNER);\n    }\n\n    function testRecoverWithInvalidShortSignatureReturnsZero() public {\n        bytes memory signature = hex\"1234\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithInvalidLongSignatureReverts() public {\n        bytes memory signature =\n            hex\"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithValidSignature() public {\n        bytes memory signature =\n            hex\"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n        address recovered = this.recover(TEST_MESSAGE.toEthSignedMessageHash(), signature);\n        assertTrue(recovered == SIGNER);\n    }\n\n    function testRecoverWithWrongSigner() public {\n        bytes memory signature =\n            hex\"8688e590483917863a35ef230c0f839be8418aa4ee765228eddfcea7fe2652815db01c2c84b0ec746e1b74d97475c599b3d3419fa7181b4e01de62c02b721aea1b\";\n        assertTrue(this.recover(WRONG_MESSAGE.toEthSignedMessageHash(), signature) != SIGNER);\n    }\n\n    function testRecoverWithInvalidSignatureReverts() public {\n        bytes memory signature =\n            hex\"332ce75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE.toEthSignedMessageHash(), signature);\n    }\n\n    function testRecoverWithV0SignatureWithVersion00Reverts() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89200\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithV0SignatureWithVersion27() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be8921b\";\n        assertTrue(this.recover(TEST_MESSAGE, signature) == V0_SIGNER);\n    }\n\n    function testRecoverWithV0SignatureWithWrongVersionReverts() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be89202\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithV0SignatureWithShortEIP2098Format() public {\n        bytes32 r = 0x5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f;\n        bytes32 vs = 0x3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892;\n        assertTrue(this.recover(TEST_MESSAGE, r, vs) == V0_SIGNER);\n    }\n\n    function testRecoverWithV0SignatureWithShortEIP2098FormatAsCalldata() public {\n        bytes memory signature =\n            hex\"5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892\";\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithV1SignatureWithVersion01Reverts() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e001\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithV1SignatureWithVersion28() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c\";\n        assertTrue(this.recover(TEST_MESSAGE, signature) == V1_SIGNER);\n    }\n\n    function testRecoverWithV1SignatureWithWrongVersionReverts() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e002\";\n        vm.expectRevert(ECDSA.InvalidSignature.selector);\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    function testRecoverWithV1SignatureWithShortEIP2098Format() public {\n        bytes32 r = 0x331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff;\n        bytes32 vs = 0xc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0;\n        assertTrue(this.recover(TEST_MESSAGE, r, vs) == V1_SIGNER);\n    }\n\n    function testRecoverWithV1SignatureWithShortEIP2098FormatAsCalldata() public {\n        bytes memory signature =\n            hex\"331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feffc8e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0\";\n        this.recover(TEST_MESSAGE, signature);\n    }\n\n    struct _CheckSignatureTestTemps {\n        bytes argsSignature;\n        bytes encodedCalldataArgs;\n        address signer;\n        bool expected;\n        bool[2] success;\n        bytes[2] result;\n        bytes4 s;\n        address recovered;\n    }\n\n    function _checkSignature(\n        address signer,\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool expected\n    ) internal {\n        _CheckSignatureTestTemps memory t;\n        t.signer = signer;\n        t.expected = expected;\n\n        t.argsSignature = \"(bytes32,uint8,bytes32,bytes32)\";\n        t.encodedCalldataArgs = abi.encode(digest, v, r, s);\n        _checkSignature(t);\n\n        if (v == 27 || v == 28) {\n            bytes32 vs = bytes32((v == 28 ? 1 << 255 : 0) | uint256(s));\n            t.argsSignature = \"(bytes32,bytes32,bytes32)\";\n            t.encodedCalldataArgs = abi.encode(digest, r, vs);\n            _checkSignature(t);\n        }\n\n        if (_random() & 1 == 0) {\n            t.argsSignature = \"(bytes32,bytes)\";\n            t.encodedCalldataArgs = abi.encode(digest, abi.encodePacked(r, s, v));\n            _checkSignature(t);\n        }\n    }\n\n    function _checkSignature(_CheckSignatureTestTemps memory t) internal {\n        t.s = bytes4(keccak256(abi.encodePacked(\"tryRecover\", t.argsSignature)));\n        (t.success[0], t.result[0]) =\n            address(this).call(abi.encodePacked(t.s, t.encodedCalldataArgs));\n        t.recovered = t.success[0] ? abi.decode(t.result[0], (address)) : address(0);\n        assertEq(t.recovered == t.signer, t.expected);\n\n        t.s = bytes4(keccak256(abi.encodePacked(\"tryRecoverBrutalized\", t.argsSignature)));\n        (t.success[1], t.result[1]) =\n            address(this).call(abi.encodePacked(t.s, t.encodedCalldataArgs));\n        t.recovered = t.success[1] ? abi.decode(t.result[1], (address)) : address(0);\n        assertEq(t.recovered == t.signer, t.expected);\n\n        t.s = bytes4(keccak256(abi.encodePacked(\"recover\", t.argsSignature)));\n        (t.success[0], t.result[0]) =\n            address(this).call(abi.encodePacked(t.s, t.encodedCalldataArgs));\n\n        t.s = bytes4(keccak256(abi.encodePacked(\"recoverBrutalized\", t.argsSignature)));\n        (t.success[1], t.result[1]) =\n            address(this).call(abi.encodePacked(t.s, t.encodedCalldataArgs));\n\n        assertEq(t.success[0], t.success[1]);\n        assertEq(t.result[0], t.result[1]);\n\n        if (t.success[0]) {\n            t.recovered = abi.decode(t.result[0], (address));\n            assertEq(t.recovered == t.signer, t.expected);\n        }\n    }\n\n    function testRecoverAndTryRecover(bytes32 digest) public {\n        (address signer, uint256 privateKey) = _randomSigner();\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);\n        if (_random() & 7 == 0) {\n            _checkSignature(signer, digest, v, r, s, true);\n        }\n\n        uint8 vc = v ^ uint8(_random() & 0xff);\n        bytes32 rc = bytes32(uint256(r) ^ _random());\n        bytes32 sc = bytes32(uint256(s) ^ _random());\n        bool anyCorrupted = vc != v || rc != r || sc != s;\n        _checkSignature(signer, digest, vc, rc, sc, !anyCorrupted);\n    }\n\n    function testBytes32ToEthSignedMessageHash() public {\n        assertEq(\n            TEST_MESSAGE.toEthSignedMessageHash(),\n            bytes32(0x7d768af957ef8cbf6219a37e743d5546d911dae3e46449d8a5810522db2ef65e)\n        );\n    }\n\n    function testBytesToEthSignedMessageHashShort() public {\n        bytes memory message = hex\"61626364\";\n        assertEq(\n            message.toEthSignedMessageHash(),\n            bytes32(0xefd0b51a9c4e5f3449f4eeacb195bf48659fbc00d2f4001bf4c088ba0779fb33)\n        );\n    }\n\n    function testBytesToEthSignedMessageHashEmpty() public {\n        bytes memory message = hex\"\";\n        assertEq(\n            message.toEthSignedMessageHash(),\n            bytes32(0x5f35dce98ba4fba25530a026ed80b2cecdaa31091ba4958b99b52ea1d068adad)\n        );\n    }\n\n    function testBytesToEthSignedMessageHashLong() public {\n        bytes memory message =\n            hex\"4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a3031323334353637383921402324255e262a28292d3d5b5d7b7d\";\n        assertEq(\n            message.toEthSignedMessageHash(),\n            bytes32(0xa46dbedd405cff161b6e80c17c8567597621d9f4c087204201097cb34448e71b)\n        );\n    }\n\n    function testBytesToEthSignedMessageHash() public {\n        _testBytesToEthSignedMessageHash(999999);\n        _testBytesToEthSignedMessageHash(135790);\n        _testBytesToEthSignedMessageHash(99999);\n        _testBytesToEthSignedMessageHash(88888);\n        _testBytesToEthSignedMessageHash(3210);\n        _testBytesToEthSignedMessageHash(111);\n        _testBytesToEthSignedMessageHash(22);\n        _testBytesToEthSignedMessageHash(1);\n        _testBytesToEthSignedMessageHash(0);\n    }\n\n    function testBytesToEthSignedMessageHashExceedsMaxLengthReverts() public {\n        vm.expectRevert();\n        _testBytesToEthSignedMessageHash(999999 + 1);\n    }\n\n    function _testBytesToEthSignedMessageHash(uint256 n) internal brutalizeMemory {\n        bytes memory message;\n        /// @solidity memory-safe-assembly\n        assembly {\n            message := mload(0x40)\n            mstore(message, n)\n            mstore(0x40, add(add(message, 0x20), n))\n        }\n        assertEq(\n            message.toEthSignedMessageHash(),\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", LibString.toString(n), message)\n            )\n        );\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, message)\n        }\n    }\n\n    function tryRecover(bytes32 hash, bytes calldata signature) external returns (address result) {\n        result = ECDSA.tryRecoverCalldata(hash, signature);\n        assertEq(ECDSA.tryRecover(hash, signature), result);\n    }\n\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        external\n        view\n        returns (address)\n    {\n        return ECDSA.tryRecover(hash, v, r, s);\n    }\n\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) external view returns (address) {\n        return ECDSA.tryRecover(hash, r, vs);\n    }\n\n    function tryRecoverBrutalized(bytes32 hash, bytes calldata signature)\n        external\n        brutalizeMemory\n        returns (address result)\n    {\n        result = ECDSA.tryRecoverCalldata(hash, signature);\n        assertEq(ECDSA.tryRecover(hash, signature), result);\n    }\n\n    function tryRecoverBrutalized(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        external\n        view\n        brutalizeMemory\n        returns (address)\n    {\n        return ECDSA.tryRecover(hash, v, r, s);\n    }\n\n    function tryRecoverBrutalized(bytes32 hash, bytes32 r, bytes32 vs)\n        external\n        view\n        brutalizeMemory\n        returns (address)\n    {\n        return ECDSA.tryRecover(hash, r, vs);\n    }\n\n    function recover(bytes32 hash, bytes calldata signature) external returns (address result) {\n        result = ECDSA.recoverCalldata(hash, signature);\n        assertEq(ECDSA.recover(hash, signature), result);\n    }\n\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) external view returns (address) {\n        return ECDSA.recover(hash, r, vs);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) external view returns (address) {\n        return ECDSA.recover(hash, v, r, s);\n    }\n\n    function recoverBrutalized(bytes32 hash, bytes calldata signature)\n        external\n        brutalizeMemory\n        returns (address result)\n    {\n        result = ECDSA.recoverCalldata(hash, signature);\n        assertEq(ECDSA.recover(hash, signature), result);\n    }\n\n    function recoverBrutalized(bytes32 hash, bytes32 r, bytes32 vs)\n        external\n        view\n        brutalizeMemory\n        returns (address)\n    {\n        return ECDSA.recover(hash, r, vs);\n    }\n\n    function recoverBrutalized(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        external\n        view\n        brutalizeMemory\n        returns (address)\n    {\n        return ECDSA.recover(hash, v, r, s);\n    }\n\n    function testEmptyCalldataHelpers() public {\n        assertFalse(ECDSA.tryRecover(bytes32(0), ECDSA.emptySignature()) == address(1));\n    }\n}\n",
        "contractname": "ECDSA.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n/// @author Modified from BokkyPooBahsDateTimeLibrary (https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary)\n/// @dev\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Weekdays are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1f1c1f1e1f1e1f1f1e1f1e1f)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(sub(month, 1), 12), lt(sub(day, 1), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../test/utils/SoladyTest.sol\";\nimport {DateTimeLib} from \"../src/utils/DateTimeLib.sol\";\n\ncontract DateTimeLibTest is SoladyTest {\n    struct DateTime {\n        uint256 year;\n        uint256 month;\n        uint256 day;\n        uint256 hour;\n        uint256 minute;\n        uint256 second;\n    }\n\n    function testDateTimeMaxSupported() public {\n        DateTime memory d;\n        assertEq(\n            DateTimeLib.dateToEpochDay(DateTimeLib.MAX_SUPPORTED_YEAR, 12, 31),\n            DateTimeLib.MAX_SUPPORTED_EPOCH_DAY\n        );\n        assertEq(\n            DateTimeLib.dateToTimestamp(DateTimeLib.MAX_SUPPORTED_YEAR, 12, 31) + 86400 - 1,\n            DateTimeLib.MAX_SUPPORTED_TIMESTAMP\n        );\n        (d.year, d.month, d.day) = DateTimeLib.timestampToDate(DateTimeLib.MAX_SUPPORTED_TIMESTAMP);\n        assertTrue(d.year == DateTimeLib.MAX_SUPPORTED_YEAR && d.month == 12 && d.day == 31);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(DateTimeLib.MAX_SUPPORTED_EPOCH_DAY);\n        assertTrue(d.year == DateTimeLib.MAX_SUPPORTED_YEAR && d.month == 12 && d.day == 31);\n        (d.year, d.month, d.day) =\n            DateTimeLib.timestampToDate(DateTimeLib.MAX_SUPPORTED_TIMESTAMP + 1);\n        assertFalse(d.year == DateTimeLib.MAX_SUPPORTED_YEAR && d.month == 12 && d.day == 31);\n        (d.year, d.month, d.day) =\n            DateTimeLib.epochDayToDate(DateTimeLib.MAX_SUPPORTED_EPOCH_DAY + 1);\n        assertFalse(d.year == DateTimeLib.MAX_SUPPORTED_YEAR && d.month == 12 && d.day == 31);\n    }\n\n    function testDateToEpochDay() public {\n        assertEq(DateTimeLib.dateToEpochDay(1970, 1, 1), 0);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 1, 2), 1);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 2, 1), 31);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 3, 1), 59);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 4, 1), 90);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 5, 1), 120);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 6, 1), 151);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 7, 1), 181);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 8, 1), 212);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 9, 1), 243);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 10, 1), 273);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 11, 1), 304);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 12, 1), 334);\n        assertEq(DateTimeLib.dateToEpochDay(1970, 12, 31), 364);\n        assertEq(DateTimeLib.dateToEpochDay(1971, 1, 1), 365);\n        assertEq(DateTimeLib.dateToEpochDay(1980, 11, 3), 3959);\n        assertEq(DateTimeLib.dateToEpochDay(2000, 3, 1), 11017);\n        assertEq(DateTimeLib.dateToEpochDay(2355, 12, 31), 140982);\n        assertEq(DateTimeLib.dateToEpochDay(99999, 12, 31), 35804721);\n        assertEq(DateTimeLib.dateToEpochDay(100000, 12, 31), 35805087);\n        assertEq(DateTimeLib.dateToEpochDay(604800, 2, 29), 220179195);\n        assertEq(DateTimeLib.dateToEpochDay(1667347200, 2, 29), 608985340227);\n        assertEq(DateTimeLib.dateToEpochDay(1667952000, 2, 29), 609206238891);\n    }\n\n    function testDateToEpochDayGas() public {\n        unchecked {\n            uint256 sum;\n            for (uint256 i; i < 256; ++i) {\n                uint256 year = _bound(_random(), 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n                uint256 month = _bound(_random(), 1, 12);\n                uint256 md = DateTimeLib.daysInMonth(year, month);\n                uint256 day = _bound(_random(), 1, md);\n                uint256 epochDay = DateTimeLib.dateToEpochDay(year, month, day);\n                sum += epochDay;\n            }\n            assertTrue(sum != 0);\n        }\n    }\n\n    function testDateToEpochDayGas2() public {\n        unchecked {\n            uint256 sum;\n            for (uint256 i; i < 256; ++i) {\n                uint256 year = _bound(_random(), 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n                uint256 month = _bound(_random(), 1, 12);\n                uint256 md = DateTimeLib.daysInMonth(year, month);\n                uint256 day = _bound(_random(), 1, md);\n                uint256 epochDay = _dateToEpochDayOriginal2(year, month, day);\n                sum += epochDay;\n            }\n            assertTrue(sum != 0);\n        }\n    }\n\n    function testEpochDayToDateGas() public {\n        unchecked {\n            uint256 sum;\n            for (uint256 i; i < 256; ++i) {\n                uint256 epochDay = _bound(_random(), 0, DateTimeLib.MAX_SUPPORTED_EPOCH_DAY);\n                (uint256 year, uint256 month, uint256 day) = DateTimeLib.epochDayToDate(epochDay);\n                sum += year + month + day;\n            }\n            assertTrue(sum != 0);\n        }\n    }\n\n    function testEpochDayToDateGas2() public {\n        unchecked {\n            uint256 sum;\n            for (uint256 i; i < 256; ++i) {\n                uint256 epochDay = _bound(_random(), 0, DateTimeLib.MAX_SUPPORTED_EPOCH_DAY);\n                (uint256 year, uint256 month, uint256 day) = _epochDayToDateOriginal2(epochDay);\n                sum += year + month + day;\n            }\n            assertTrue(sum != 0);\n        }\n    }\n\n    function testDateToEpochDayDifferential(DateTime memory d) public {\n        d.year = _bound(d.year, 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n        d.month = _bound(d.month, 1, 12);\n        d.day = _bound(d.day, 1, DateTimeLib.daysInMonth(d.year, d.month));\n        uint256 expectedResult = _dateToEpochDayOriginal(d.year, d.month, d.day);\n        assertEq(DateTimeLib.dateToEpochDay(d.year, d.month, d.day), expectedResult);\n    }\n\n    function testDateToEpochDayDifferential2(DateTime memory d) public {\n        d.year = _bound(d.year, 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n        d.month = _bound(d.month, 1, 12);\n        d.day = _bound(d.day, 1, DateTimeLib.daysInMonth(d.year, d.month));\n        uint256 expectedResult = _dateToEpochDayOriginal2(d.year, d.month, d.day);\n        assertEq(DateTimeLib.dateToEpochDay(d.year, d.month, d.day), expectedResult);\n    }\n\n    function testEpochDayToDateDifferential(uint256 timestamp) public {\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day) = _epochDayToDateOriginal(timestamp);\n        (b.year, b.month, b.day) = DateTimeLib.epochDayToDate(timestamp);\n        assertTrue(a.year == b.year && a.month == b.month && a.day == b.day);\n    }\n\n    function testEpochDayToDateDifferential2(uint256 timestamp) public {\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day) = _epochDayToDateOriginal2(timestamp);\n        (b.year, b.month, b.day) = DateTimeLib.epochDayToDate(timestamp);\n        assertTrue(a.year == b.year && a.month == b.month && a.day == b.day);\n    }\n\n    function testDaysToDate() public {\n        DateTime memory d;\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(0);\n        assertTrue(d.year == 1970 && d.month == 1 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(31);\n        assertTrue(d.year == 1970 && d.month == 2 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(59);\n        assertTrue(d.year == 1970 && d.month == 3 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(90);\n        assertTrue(d.year == 1970 && d.month == 4 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(120);\n        assertTrue(d.year == 1970 && d.month == 5 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(151);\n        assertTrue(d.year == 1970 && d.month == 6 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(181);\n        assertTrue(d.year == 1970 && d.month == 7 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(212);\n        assertTrue(d.year == 1970 && d.month == 8 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(243);\n        assertTrue(d.year == 1970 && d.month == 9 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(273);\n        assertTrue(d.year == 1970 && d.month == 10 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(304);\n        assertTrue(d.year == 1970 && d.month == 11 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(334);\n        assertTrue(d.year == 1970 && d.month == 12 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(365);\n        assertTrue(d.year == 1971 && d.month == 1 && d.day == 1);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(10987);\n        assertTrue(d.year == 2000 && d.month == 1 && d.day == 31);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(18321);\n        assertTrue(d.year == 2020 && d.month == 2 && d.day == 29);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(156468);\n        assertTrue(d.year == 2398 && d.month == 5 && d.day == 25);\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(35805087);\n        assertTrue(d.year == 100000 && d.month == 12 && d.day == 31);\n    }\n\n    function testEpochDayToDate(uint256 epochDay) public {\n        DateTime memory d;\n        (d.year, d.month, d.day) = DateTimeLib.epochDayToDate(epochDay);\n        assertEq(epochDay, DateTimeLib.dateToEpochDay(d.year, d.month, d.day));\n    }\n\n    function testDateToAndFroEpochDay(DateTime memory a) public {\n        a.year = _bound(a.year, 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n        a.month = _bound(a.month, 1, 12);\n        uint256 md = DateTimeLib.daysInMonth(a.year, a.month);\n        a.day = _bound(a.day, 1, md);\n        uint256 epochDay = DateTimeLib.dateToEpochDay(a.year, a.month, a.day);\n        DateTime memory b;\n        (b.year, b.month, b.day) = DateTimeLib.epochDayToDate(epochDay);\n        assertTrue(a.year == b.year && a.month == b.month && a.day == b.day);\n    }\n\n    function testDateTimeToAndFroTimestamp(DateTime memory a) public {\n        a.year = _bound(a.year, 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n        a.month = _bound(a.month, 1, 12);\n        uint256 md = DateTimeLib.daysInMonth(a.year, a.month);\n        a.day = _bound(a.day, 1, md);\n        a.hour = _bound(a.hour, 0, 23);\n        a.minute = _bound(a.minute, 0, 59);\n        a.second = _bound(a.second, 0, 59);\n        uint256 timestamp =\n            DateTimeLib.dateTimeToTimestamp(a.year, a.month, a.day, a.hour, a.minute, a.second);\n        DateTime memory b;\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        assertTrue(a.year == b.year && a.month == b.month && a.day == b.day);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testDateToAndFroEpochDay() public {\n        unchecked {\n            for (uint256 i; i < 256; ++i) {\n                uint256 year = _bound(_random(), 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n                uint256 month = _bound(_random(), 1, 12);\n                uint256 md = DateTimeLib.daysInMonth(year, month);\n                uint256 day = _bound(_random(), 1, md);\n                uint256 epochDay = DateTimeLib.dateToEpochDay(year, month, day);\n                (uint256 y, uint256 m, uint256 d) = DateTimeLib.epochDayToDate(epochDay);\n                assertTrue(year == y && month == m && day == d);\n            }\n        }\n    }\n\n    function testDateToAndFroTimestamp() public {\n        unchecked {\n            for (uint256 i; i < 256; ++i) {\n                uint256 year = _bound(_random(), 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n                uint256 month = _bound(_random(), 1, 12);\n                uint256 md = DateTimeLib.daysInMonth(year, month);\n                uint256 day = _bound(_random(), 1, md);\n                uint256 timestamp = DateTimeLib.dateToTimestamp(year, month, day);\n                assertEq(timestamp, DateTimeLib.dateToEpochDay(year, month, day) * 86400);\n                (uint256 y, uint256 m, uint256 d) = DateTimeLib.timestampToDate(timestamp);\n                assertTrue(year == y && month == m && day == d);\n            }\n        }\n    }\n\n    function testIsLeapYear() public {\n        assertTrue(DateTimeLib.isLeapYear(2000));\n        assertTrue(DateTimeLib.isLeapYear(2024));\n        assertTrue(DateTimeLib.isLeapYear(2048));\n        assertTrue(DateTimeLib.isLeapYear(2072));\n        assertTrue(DateTimeLib.isLeapYear(2104));\n        assertTrue(DateTimeLib.isLeapYear(2128));\n        assertTrue(DateTimeLib.isLeapYear(10032));\n        assertTrue(DateTimeLib.isLeapYear(10124));\n        assertTrue(DateTimeLib.isLeapYear(10296));\n        assertTrue(DateTimeLib.isLeapYear(10400));\n        assertTrue(DateTimeLib.isLeapYear(10916));\n    }\n\n    function testIsLeapYear(uint256 year) public {\n        assertEq(\n            DateTimeLib.isLeapYear(year), (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0)\n        );\n    }\n\n    function testDaysInMonth() public {\n        assertEq(DateTimeLib.daysInMonth(2022, 1), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 2), 28);\n        assertEq(DateTimeLib.daysInMonth(2022, 3), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 4), 30);\n        assertEq(DateTimeLib.daysInMonth(2022, 5), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 6), 30);\n        assertEq(DateTimeLib.daysInMonth(2022, 7), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 8), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 9), 30);\n        assertEq(DateTimeLib.daysInMonth(2022, 10), 31);\n        assertEq(DateTimeLib.daysInMonth(2022, 11), 30);\n        assertEq(DateTimeLib.daysInMonth(2022, 12), 31);\n        assertEq(DateTimeLib.daysInMonth(2024, 1), 31);\n        assertEq(DateTimeLib.daysInMonth(2024, 2), 29);\n        assertEq(DateTimeLib.daysInMonth(1900, 2), 28);\n    }\n\n    function testDaysInMonth(uint256 year, uint256 month) public {\n        month = _bound(month, 1, 12);\n        if (DateTimeLib.isLeapYear(year) && month == 2) {\n            assertEq(DateTimeLib.daysInMonth(year, month), 29);\n        } else if (\n            month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\n                || month == 12\n        ) {\n            assertEq(DateTimeLib.daysInMonth(year, month), 31);\n        } else if (month == 2) {\n            assertEq(DateTimeLib.daysInMonth(year, month), 28);\n        } else {\n            assertEq(DateTimeLib.daysInMonth(year, month), 30);\n        }\n    }\n\n    function testWeekday() public {\n        assertEq(DateTimeLib.weekday(1), 4);\n        assertEq(DateTimeLib.weekday(86400), 5);\n        assertEq(DateTimeLib.weekday(86401), 5);\n        assertEq(DateTimeLib.weekday(172800), 6);\n        assertEq(DateTimeLib.weekday(259200), 7);\n        assertEq(DateTimeLib.weekday(345600), 1);\n        assertEq(DateTimeLib.weekday(432000), 2);\n        assertEq(DateTimeLib.weekday(518400), 3);\n    }\n\n    function testDayOfWeek() public {\n        uint256 timestamp = 0;\n        uint256 weekday = 3;\n        unchecked {\n            for (uint256 i = 0; i < 1000; ++i) {\n                assertEq(DateTimeLib.weekday(timestamp) - 1, weekday);\n                timestamp += 86400;\n                weekday = (weekday + 1) % 7;\n            }\n        }\n    }\n\n    function testIsSupportedDateTrue() public {\n        assertTrue(DateTimeLib.isSupportedDate(1970, 1, 1));\n        assertTrue(DateTimeLib.isSupportedDate(1971, 5, 31));\n        assertTrue(DateTimeLib.isSupportedDate(1971, 6, 30));\n        assertTrue(DateTimeLib.isSupportedDate(1971, 12, 31));\n        assertTrue(DateTimeLib.isSupportedDate(1972, 2, 28));\n        assertTrue(DateTimeLib.isSupportedDate(1972, 4, 30));\n        assertTrue(DateTimeLib.isSupportedDate(1972, 5, 31));\n        assertTrue(DateTimeLib.isSupportedDate(2000, 2, 29));\n        assertTrue(DateTimeLib.isSupportedDate(DateTimeLib.MAX_SUPPORTED_YEAR, 5, 31));\n    }\n\n    function testIsSupportedDateFalse() public {\n        assertFalse(DateTimeLib.isSupportedDate(0, 0, 0));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 0, 0));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 1, 0));\n        assertFalse(DateTimeLib.isSupportedDate(1969, 1, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1800, 1, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 13, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1700, 13, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 15, 32));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 1, 32));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 13, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1879, 1, 1));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 4, 31));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 6, 31));\n        assertFalse(DateTimeLib.isSupportedDate(1970, 7, 32));\n        assertFalse(DateTimeLib.isSupportedDate(2000, 2, 30));\n        assertFalse(DateTimeLib.isSupportedDate(DateTimeLib.MAX_SUPPORTED_YEAR + 1, 5, 31));\n        assertFalse(DateTimeLib.isSupportedDate(type(uint256).max, 5, 31));\n    }\n\n    function testIsSupportedDateTime(DateTime memory a) public {\n        a.month = _bound(a.month, 0, 20);\n        a.day = _bound(a.day, 0, 50);\n        a.hour = _bound(a.hour, 0, 50);\n        a.minute = _bound(a.minute, 0, 100);\n        a.second = _bound(a.second, 0, 100);\n        bool isSupported = (1970 <= a.year && a.year <= DateTimeLib.MAX_SUPPORTED_YEAR)\n            && (1 <= a.month && a.month <= 12)\n            && (1 <= a.day && a.day <= DateTimeLib.daysInMonth(a.year, a.month)) && (a.hour < 24)\n            && (a.minute < 60) && (a.second < 60);\n        assertEq(\n            DateTimeLib.isSupportedDateTime(a.year, a.month, a.day, a.hour, a.minute, a.second),\n            isSupported\n        );\n    }\n\n    function testIsSupportedEpochDayTrue() public {\n        assertTrue(DateTimeLib.isSupportedEpochDay(0));\n        assertTrue(DateTimeLib.isSupportedEpochDay(DateTimeLib.MAX_SUPPORTED_EPOCH_DAY));\n    }\n\n    function testIsSupportedEpochDayFalse() public {\n        assertFalse(DateTimeLib.isSupportedEpochDay(DateTimeLib.MAX_SUPPORTED_EPOCH_DAY + 1));\n        assertFalse(DateTimeLib.isSupportedEpochDay(DateTimeLib.MAX_SUPPORTED_EPOCH_DAY + 2));\n    }\n\n    function testIsSupportedTimestampTrue() public {\n        assertTrue(DateTimeLib.isSupportedTimestamp(0));\n        assertTrue(DateTimeLib.isSupportedTimestamp(DateTimeLib.MAX_SUPPORTED_TIMESTAMP));\n    }\n\n    function testIsSupportedTimestampFalse() public {\n        assertFalse(DateTimeLib.isSupportedTimestamp(DateTimeLib.MAX_SUPPORTED_TIMESTAMP + 1));\n        assertFalse(DateTimeLib.isSupportedTimestamp(DateTimeLib.MAX_SUPPORTED_TIMESTAMP + 2));\n    }\n\n    function testNthWeekdayInMonthOfYearTimestamp() public {\n        uint256 wd;\n        // 1st 2nd 3rd 4th monday in November 2022.\n        wd = DateTimeLib.MON;\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 1, wd), 1667779200);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 2, wd), 1668384000);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 3, wd), 1668988800);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 4, wd), 1669593600);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 5, wd), 0);\n\n        // 1st... 5th Wednesday in November 2022.\n        wd = DateTimeLib.WED;\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 1, wd), 1667347200);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 2, wd), 1667952000);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 3, wd), 1668556800);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 4, wd), 1669161600);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 5, wd), 1669766400);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 11, 6, wd), 0);\n\n        // 1st... 5th Friday in December 2022.\n        wd = DateTimeLib.FRI;\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 1, wd), 1669939200);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 2, wd), 1670544000);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 3, wd), 1671148800);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 4, wd), 1671753600);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 5, wd), 1672358400);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2022, 12, 6, wd), 0);\n\n        // 1st... 5th Sunday in January 2023.\n        wd = DateTimeLib.SUN;\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 1, wd), 1672531200);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 2, wd), 1673136000);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 3, wd), 1673740800);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 4, wd), 1674345600);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 5, wd), 1674950400);\n        assertEq(DateTimeLib.nthWeekdayInMonthOfYearTimestamp(2023, 1, 6, wd), 0);\n    }\n\n    function testNthWeekdayInMonthOfYearTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 n,\n        uint256 weekday\n    ) public {\n        unchecked {\n            year = _bound(year, 1970, DateTimeLib.MAX_SUPPORTED_YEAR);\n            month = _bound(month, 1, 12);\n            n = _bound(n, 1, 10);\n            weekday = _bound(weekday, 1, 7);\n            // Count number of weekdays for the month in the year.\n            uint256 md = DateTimeLib.daysInMonth(year, month);\n            uint256 timestamp = DateTimeLib.dateToTimestamp(year, month, 1);\n            uint256 m;\n            uint256 found;\n            for (uint256 i; i < md;) {\n                if (DateTimeLib.weekday(timestamp) == weekday) {\n                    if (++m == n) {\n                        found = 1;\n                        break;\n                    }\n                }\n                if (m == 0) {\n                    timestamp += 86400;\n                    i += 1;\n                } else {\n                    timestamp += 86400 * 7;\n                    i += 7;\n                }\n            }\n            assertEq(\n                DateTimeLib.nthWeekdayInMonthOfYearTimestamp(year, month, n, weekday),\n                found * timestamp\n            );\n        }\n    }\n\n    function testMondayTimestamp() public {\n        // Thursday 01 January 1970 -> 0\n        assertEq(DateTimeLib.mondayTimestamp(0), 0);\n        // Friday 02 January 1970 -> 86400\n        assertEq(DateTimeLib.mondayTimestamp(86400), 0);\n        // Saturday 03 January 1970 -> 172800\n        assertEq(DateTimeLib.mondayTimestamp(172800), 0);\n        // Sunday 04 January 1970 -> 259200\n        assertEq(DateTimeLib.mondayTimestamp(259200), 0);\n        // Monday 05 January 19700 -> 345600\n        assertEq(DateTimeLib.mondayTimestamp(345600), 345600);\n        // Monday 07 November 2022 -> 1667779200\n        assertEq(DateTimeLib.mondayTimestamp(1667779200), 1667779200);\n        // Sunday 06 November 2022 -> 1667692800\n        assertEq(DateTimeLib.mondayTimestamp(1667692800), 1667174400);\n        // Saturday 05 November 2022 -> 1667606400\n        assertEq(DateTimeLib.mondayTimestamp(1667606400), 1667174400);\n        // Friday 04 November 2022 -> 1667520000\n        assertEq(DateTimeLib.mondayTimestamp(1667520000), 1667174400);\n        // Thursday 03 November 2022 -> 1667433600\n        assertEq(DateTimeLib.mondayTimestamp(1667433600), 1667174400);\n        // Wednesday 02 November 2022 -> 1667347200\n        assertEq(DateTimeLib.mondayTimestamp(1667347200), 1667174400);\n        // Tuesday 01 November 2022 -> 1667260800\n        assertEq(DateTimeLib.mondayTimestamp(1667260800), 1667174400);\n        // Monday 01 November 2022 -> 1667260800\n        assertEq(DateTimeLib.mondayTimestamp(1667174400), 1667174400);\n    }\n\n    function testMondayTimestamp(uint256 timestamp) public {\n        uint256 day = timestamp / 86400;\n        uint256 weekday = (day + 3) % 7;\n        assertEq(\n            DateTimeLib.mondayTimestamp(timestamp), timestamp > 345599 ? (day - weekday) * 86400 : 0\n        );\n    }\n\n    function testIsWeekEnd(uint256 timestamp) public {\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP);\n        uint256 weekday = DateTimeLib.weekday(timestamp);\n        assertEq(\n            DateTimeLib.isWeekEnd(timestamp),\n            weekday == DateTimeLib.SAT || weekday == DateTimeLib.SUN\n        );\n    }\n\n    function testAddSubDiffYears(uint256 timestamp, uint256 numYears) public {\n        uint256 maxNumYears = 1000000;\n        numYears = _bound(numYears, 0, maxNumYears);\n        timestamp =\n            _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumYears * 366 * 86400);\n        uint256 result = DateTimeLib.addYears(timestamp, numYears);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numYears != 0) assertTrue(a.year != b.year);\n        if (a.day <= 28) assertEq(a.day, b.day);\n        assertTrue(a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n        uint256 diff = DateTimeLib.diffYears(timestamp, result);\n        assertTrue(diff == numYears);\n        result = DateTimeLib.subYears(result, numYears);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testDateTimeArithmeticReverts() public {\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addYears(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subYears(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffYears(2 ** 128 - 1, 2 ** 127 - 1);\n\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addMonths(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subMonths(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffMonths(2 ** 128 - 1, 2 ** 127 - 1);\n\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addDays(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subDays(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffDays(2 ** 128 - 1, 2 ** 127 - 1);\n\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addHours(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subHours(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffHours(2 ** 128 - 1, 2 ** 127 - 1);\n\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addMinutes(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subMinutes(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffMinutes(2 ** 128 - 1, 2 ** 127 - 1);\n\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.addSeconds(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.subSeconds(2 ** 128 - 1, 2 ** 255 - 1);\n        vm.expectRevert(stdError.arithmeticError);\n        DateTimeLib.diffSeconds(2 ** 128 - 1, 2 ** 127 - 1);\n    }\n\n    function testAddSubDiffMonths(uint256 timestamp, uint256 numMonths) public {\n        uint256 maxNumMonths = 1000000;\n        numMonths = _bound(numMonths, 0, maxNumMonths);\n        timestamp =\n            _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumMonths * 32 * 86400);\n        uint256 result = DateTimeLib.addMonths(timestamp, numMonths);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numMonths != 0) assertTrue(a.year != b.year || a.month != b.month);\n        if (a.day <= 28) assertEq(a.day, b.day);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n        uint256 diff = DateTimeLib.diffMonths(timestamp, result);\n        assertTrue(diff == numMonths);\n        result = DateTimeLib.subMonths(result, numMonths);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testAddSubDiffDays(uint256 timestamp, uint256 numDays) public {\n        uint256 maxNumDays = 100000000;\n        numDays = _bound(numDays, 0, maxNumDays);\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumDays * 86400);\n        uint256 result = DateTimeLib.addDays(timestamp, numDays);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numDays != 0) {\n            assertTrue(a.year != b.year || a.month != b.month || a.day != b.day);\n        }\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n        uint256 diff = DateTimeLib.diffDays(timestamp, result);\n        assertTrue(diff == numDays);\n        result = DateTimeLib.subDays(result, numDays);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testAddSubDiffHours(uint256 timestamp, uint256 numHours) public {\n        uint256 maxNumHours = 10000000000;\n        numHours = _bound(numHours, 0, maxNumHours);\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumHours * 3600);\n        uint256 result = DateTimeLib.addHours(timestamp, numHours);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numHours != 0) {\n            assertTrue(a.year != b.year || a.month != b.month || a.day != b.day || a.hour != b.hour);\n        }\n        assertTrue(a.minute == b.minute && a.second == b.second);\n        uint256 diff = DateTimeLib.diffHours(timestamp, result);\n        assertTrue(diff == numHours);\n        result = DateTimeLib.subHours(result, numHours);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testAddSubDiffMinutes(uint256 timestamp, uint256 numMinutes) public {\n        uint256 maxNumMinutes = 10000000000;\n        numMinutes = _bound(numMinutes, 0, maxNumMinutes);\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumMinutes * 60);\n        uint256 result = DateTimeLib.addMinutes(timestamp, numMinutes);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numMinutes != 0) {\n            assertTrue(\n                (a.year != b.year || a.month != b.month || a.day != b.day)\n                    || (a.hour != b.hour || a.minute != b.minute)\n            );\n        }\n        assertTrue(a.second == b.second);\n        uint256 diff = DateTimeLib.diffMinutes(timestamp, result);\n        assertTrue(diff == numMinutes);\n        result = DateTimeLib.subMinutes(result, numMinutes);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function testAddSubDiffSeconds(uint256 timestamp, uint256 numSeconds) public {\n        uint256 maxNumSeconds = 1000000000000;\n        numSeconds = _bound(numSeconds, 0, maxNumSeconds);\n        timestamp = _bound(timestamp, 0, DateTimeLib.MAX_SUPPORTED_TIMESTAMP - maxNumSeconds);\n        uint256 result = DateTimeLib.addSeconds(timestamp, numSeconds);\n        DateTime memory a;\n        DateTime memory b;\n        (a.year, a.month, a.day, a.hour, a.minute, a.second) =\n            DateTimeLib.timestampToDateTime(timestamp);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        if (numSeconds != 0) {\n            assertTrue(\n                (a.year != b.year || a.month != b.month || a.day != b.day)\n                    || (a.hour != b.hour || a.minute != b.minute || a.second != b.second)\n            );\n        }\n        uint256 diff = DateTimeLib.diffSeconds(timestamp, result);\n        assertTrue(diff == numSeconds);\n        result = DateTimeLib.subSeconds(result, numSeconds);\n        (b.year, b.month, b.day, b.hour, b.minute, b.second) =\n            DateTimeLib.timestampToDateTime(result);\n        assertTrue(a.year == b.year && a.month == b.month);\n        assertTrue(a.hour == b.hour && a.minute == b.minute && a.second == b.second);\n    }\n\n    function _dateToEpochDayOriginal(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (month <= 2) {\n                year -= 1;\n            }\n            uint256 era = year / 400;\n            uint256 yoe = year - era * 400;\n            uint256 doy = (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5 + day - 1;\n            uint256 doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n            return era * 146097 + doe - 719468;\n        }\n    }\n\n    function _dateToEpochDayOriginal2(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 _days)\n    {\n        unchecked {\n            int256 _year = int256(year);\n            int256 _month = int256(month);\n            int256 _day = int256(day);\n\n            int256 _m = (_month - 14) / 12;\n            int256 __days = _day - 32075 + ((1461 * (_year + 4800 + _m)) / 4)\n                + ((367 * (_month - 2 - _m * 12)) / 12) - ((3 * ((_year + 4900 + _m) / 100)) / 4)\n                - 2440588;\n\n            _days = uint256(__days);\n        }\n    }\n\n    function _epochDayToDateOriginal(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        unchecked {\n            timestamp += 719468;\n            uint256 era = timestamp / 146097;\n            uint256 doe = timestamp - era * 146097;\n            uint256 yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;\n            year = yoe + era * 400;\n            uint256 doy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n            uint256 mp = (5 * doy + 2) / 153;\n            day = doy - (153 * mp + 2) / 5 + 1;\n            month = mp < 10 ? mp + 3 : mp - 9;\n            if (month <= 2) {\n                year += 1;\n            }\n        }\n    }\n\n    function _epochDayToDateOriginal2(uint256 _days)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        unchecked {\n            int256 __days = int256(_days);\n\n            int256 L = __days + 68569 + 2440588;\n            int256 N = (4 * L) / 146097;\n            L = L - (146097 * N + 3) / 4;\n            int256 _year = (4000 * (L + 1)) / 1461001;\n            L = L - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * L) / 2447;\n            int256 _day = L - (2447 * _month) / 80;\n            L = _month / 11;\n            _month = _month + 2 - 12 * L;\n            _year = 100 * (N - 49) + _year + L;\n\n            year = uint256(_year);\n            month = uint256(_month);\n            day = uint256(_day);\n        }\n    }\n}\n",
        "contractname": "DateTimeLib.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to deploy the contract.\n    error DeploymentFailed();\n\n    /// @dev Unable to initialize the contract.\n    error InitializationFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      BYTECODE CONSTANTS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /**\n     * -------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 36          | CALLDATASIZE     | cds          |                    |\n     * 3d          | RETURNDATASIZE   | 0 cds        |                    |\n     * 3d          | RETURNDATASIZE   | 0 0 cds      |                    |\n     * 37          | CALLDATACOPY     |              | [0..cds): calldata |\n     * 36          | CALLDATASIZE     | cds          | [0..cds): calldata |\n     * 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |\n     * 34          | CALLVALUE        | value 0 cds  | [0..cds): calldata |\n     * f0          | CREATE           | newContract  | [0..cds): calldata |\n     * -------------------------------------------------------------------|\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 67 bytecode | PUSH8 bytecode   | bytecode     |                    |\n     * 3d          | RETURNDATASIZE   | 0 bytecode   |                    |\n     * 52          | MSTORE           |              | [0..8): bytecode   |\n     * 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |\n     * 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |\n     * f3          | RETURN           |              | [0..8): bytecode   |\n     * -------------------------------------------------------------------+\n     */\n\n    /// @dev The proxy bytecode.\n    uint256 private constant _PROXY_BYTECODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_PROXY_BYTECODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 private constant _PROXY_BYTECODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      CREATE3 OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys `creationCode` deterministically with a `salt`.\n    /// The deployed contract is funded with `value` (in wei) ETH.\n    /// Returns the deterministic address of the deployed contract,\n    /// which solely depends on `salt`.\n    function deploy(bytes32 salt, bytes memory creationCode, uint256 value)\n        internal\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the `_PROXY_BYTECODE` into scratch space.\n            mstore(0x00, _PROXY_BYTECODE)\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            let proxy := create2(0, 0x10, 0x10, salt)\n\n            // If the result of `create2` is the zero address, revert.\n            if iszero(proxy) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the proxy's address.\n            mstore(0x14, proxy)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n\n            // If the `call` fails, revert.\n            if iszero(\n                call(\n                    gas(), // Gas remaining.\n                    proxy, // Proxy's address.\n                    value, // Ether value.\n                    add(creationCode, 0x20), // Start of `creationCode`.\n                    mload(creationCode), // Length of `creationCode`.\n                    0x00, // Offset of output.\n                    0x00 // Length of output.\n                )\n            ) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If the code size of `deployed` is zero, revert.\n            if iszero(extcodesize(deployed)) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the deterministic address for `salt` with `deployer`.\n    function getDeployed(bytes32 salt, address deployer) internal pure returns (address deployed) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the free memory pointer.\n            let m := mload(0x40)\n            // Store `deployer`.\n            mstore(0x00, deployer)\n            // Store the prefix.\n            mstore8(0x0b, 0xff)\n            // Store the salt.\n            mstore(0x20, salt)\n            // Store the bytecode hash.\n            mstore(0x40, _PROXY_BYTECODE_HASH)\n\n            // Store the proxy's address.\n            mstore(0x14, keccak256(0x0b, 0x55))\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /// @dev Returns the deterministic address for `salt`.\n    function getDeployed(bytes32 salt) internal view returns (address deployed) {\n        deployed = getDeployed(salt, address(this));\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {WETH} from \"../src/tokens/WETH.sol\";\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockCd} from \"./utils/mocks/MockCd.sol\";\n\nimport {CREATE3} from \"../src/utils/CREATE3.sol\";\n\nimport \"./utils/SoladyTest.sol\";\n\ncontract CREATE3Test is SoladyTest {\n    function testDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n\n        MockERC20 deployed = MockERC20(\n            this.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testDeployedUpperBitsSafeForPlainSolidity() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n        address deployed = CREATE3.getDeployed(salt);\n        uint256 someNumber = 123456789;\n        uint256 packed = (someNumber << 160) | uint160(deployed);\n        uint256 someNumberUnpacked = packed >> 160;\n        assertEq(someNumber, someNumberUnpacked);\n    }\n\n    function testDoubleDeploySameBytecodeReverts() public {\n        bytes32 salt = keccak256(bytes(\"Salty...\"));\n\n        this.deploy(salt, type(MockCd).creationCode, 0);\n        vm.expectRevert(CREATE3.DeploymentFailed.selector);\n        this.deploy(salt, type(MockCd).creationCode, 0);\n    }\n\n    function testDoubleDeployDifferentBytecodeReverts() public {\n        bytes32 salt = keccak256(bytes(\"and sweet!\"));\n\n        this.deploy(salt, type(WETH).creationCode, 0);\n        vm.expectRevert(CREATE3.DeploymentFailed.selector);\n        this.deploy(salt, type(MockCd).creationCode, 0);\n    }\n\n    function testDeployERC20(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 deployed = MockERC20(\n            this.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), name);\n        assertEq(deployed.symbol(), symbol);\n        assertEq(deployed.decimals(), decimals);\n    }\n\n    function testDoubleDeploySameBytecodeReverts(bytes32 salt, bytes calldata bytecode) public {\n        bytes memory creationCode = _creationCode(bytecode);\n        this.deploy(salt, creationCode, 0);\n        vm.expectRevert(CREATE3.DeploymentFailed.selector);\n        this.deploy(salt, creationCode, 0);\n    }\n\n    function testDoubleDeployDifferentBytecodeReverts(\n        bytes32 salt,\n        bytes memory bytecode1,\n        bytes memory bytecode2\n    ) public {\n        this.deploy(salt, _creationCode(bytecode1), 0);\n        vm.expectRevert(CREATE3.DeploymentFailed.selector);\n        this.deploy(salt, _creationCode(bytecode2), 0);\n    }\n\n    function deploy(bytes32 salt, bytes calldata creationCode, uint256 value)\n        external\n        returns (address)\n    {\n        return CREATE3.deploy(salt, creationCode, value);\n    }\n\n    function _creationCode(bytes memory bytecode) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Trim the length if needed.\n            let length := mload(bytecode)\n            let maxLength := 24566 // `24576 - 0xa`.\n            if iszero(lt(length, maxLength)) { mstore(bytecode, maxLength) }\n            // The following snippet is from SSTORE2.\n            result := mload(0x40)\n            length := mload(bytecode)\n            let dataSize := add(length, 1)\n            mstore(0x40, and(add(add(result, dataSize), 0x60), not(0x1f)))\n            mstore(add(result, 0x0b), or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n            mstore(result, add(dataSize, 0xa)) // Store the length of result.\n            // Copy the bytes over.\n            for { let i := 0 } lt(i, length) { i := add(i, 0x20) } {\n                mstore(add(add(bytecode, 0x20), i), mload(add(add(result, 0x2b), i)))\n            }\n        }\n    }\n}\n",
        "contractname": "CREATE3.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Deployless queryer for predeploys.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DeploylessPredeployQueryer.sol)\n/// @author Wilson Cusack (Coinbase)\n/// (https://github.com/coinbase/smart-wallet/blob/main/src/utils/ERC1271InputGenerator.sol)\n/// (https://github.com/wilsoncusack/scw-tx/blob/main/utils/ERC1271.ts)\n///\n/// @dev\n/// This contract is not meant to ever actually be deployed,\n/// only mock deployed and used via a static `eth_call`.\n///\n/// Creation code (hex-encoded):\n/// `3860b63d393d516020805190606051833b15607e575b5059926040908285528351938460051b9459523d604087015260005b858103603e578680590390f35b6000828683820101510138908688820151910147875af115607457603f19875903018482890101523d59523d6000593e84016031565b3d6000803e3d6000fd5b816000828193519083479101906040515af11560ad5783815114601f3d111660155763d1f6b81290526004601cfd5b3d81803e3d90fdfe`\n/// See: https://gist.github.com/Vectorized/f77fce00a03dfa99aee526d2a77fd2aa\n///\n/// May be useful for generating ERC-6492 compliant signatures.\n/// Inspired by Ambire's DeploylessUniversalSigValidator\n/// (https://github.com/AmbireTech/signature-validator/blob/main/contracts/DeploylessUniversalSigValidator.sol)\ncontract DeploylessPredeployQueryer {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The returned address by the factory does not match the provided address.\n    error ReturnedAddressMismatch();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The code of the deployed contract can be `abi.decoded` into an array of bytes,\n    /// where each entry can be `abi.decoded` into the required variables.\n    ///\n    /// For example, if `targetQueryCalldata`'s 0th call is expected to return a `uint256`,\n    /// you will use `abi.decode(abi.decode(deployed.code, (bytes[]))[0], (uint256))` to\n    /// get the returned `uint256`.\n    constructor(\n        address target,\n        bytes[] memory targetQueryCalldata,\n        address factory,\n        bytes memory factoryCalldata\n    ) payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // If the target does not exist, deploy it.\n            if iszero(extcodesize(target)) {\n                if iszero(\n                    call(\n                        gas(),\n                        factory,\n                        selfbalance(),\n                        add(factoryCalldata, 0x20),\n                        mload(factoryCalldata),\n                        m,\n                        0x20\n                    )\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                if iszero(and(gt(returndatasize(), 0x1f), eq(mload(m), target))) {\n                    mstore(0x00, 0xd1f6b812) // `ReturnedAddressMismatch()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            let l := mload(targetQueryCalldata)\n            let n := shl(5, l)\n            let r := add(m, 0x40)\n            let o := add(r, n)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(0x20, i) } {\n                let j := mload(add(add(targetQueryCalldata, 0x20), i))\n                if iszero(\n                    call(gas(), target, selfbalance(), add(j, 0x20), mload(j), codesize(), 0x00)\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(add(r, i), sub(o, r))\n                mstore(o, returndatasize())\n                returndatacopy(add(o, 0x20), 0x00, returndatasize())\n                o := and(add(add(o, returndatasize()), 0x3f), not(0x1f))\n            }\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), l)\n            return(m, sub(o, m))\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {DeploylessPredeployQueryer} from \"../src/utils/DeploylessPredeployQueryer.sol\";\n\nlibrary RandomBytesGeneratorLib {\n    function generate(uint256 seed) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := add(0x20, mload(0x40))\n            mstore(0x00, seed)\n            let n := mod(keccak256(0x00, 0x20), 50)\n            mstore(result, n)\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(0x20, i)\n                mstore(add(i, add(result, 0x20)), keccak256(0x00, 0x40))\n            }\n            mstore(0x40, add(n, add(result, 0x20)))\n        }\n    }\n\n    function next(uint256 seed) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, seed)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n}\n\ncontract Target {\n    function generate(uint256 seed) public pure returns (bytes memory result) {\n        result = RandomBytesGeneratorLib.generate(seed);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(sub(result, 0x20), 0x20)\n            return(sub(result, 0x20), add(add(0x40, mod(seed, 50)), mload(result)))\n        }\n    }\n\n    function next(uint256 seed) public pure returns (uint256 result) {\n        result = RandomBytesGeneratorLib.next(seed);\n    }\n}\n\ncontract Factory {\n    address public implementation;\n\n    constructor() {\n        implementation = address(new Target());\n    }\n\n    function deploy(bytes32 salt) public returns (address) {\n        if (predictDeployment(salt).code.length != 0) return predictDeployment(salt);\n        return LibClone.cloneDeterministic(implementation, salt);\n    }\n\n    function predictDeployment(bytes32 salt) public view returns (address) {\n        return LibClone.predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n\ncontract DeploylessPredeployQueryerTest is SoladyTest {\n    Factory factory;\n\n    bytes internal constant _CREATION_CODE =\n        hex\"3860b63d393d516020805190606051833b15607e575b5059926040908285528351938460051b9459523d604087015260005b858103603e578680590390f35b6000828683820101510138908688820151910147875af115607457603f19875903018482890101523d59523d6000593e84016031565b3d6000803e3d6000fd5b816000828193519083479101906040515af11560ad5783815114601f3d111660155763d1f6b81290526004601cfd5b3d81803e3d90fdfe\";\n\n    function setUp() public {\n        factory = new Factory();\n    }\n\n    struct _TestTemps {\n        address target;\n        uint256 n;\n        uint256[] seeds;\n        address deployed;\n        bytes factoryCalldata;\n        bytes[] targetQueryCalldata;\n        bytes[] decoded;\n    }\n\n    function _deployQuery(\n        address target,\n        bytes[] memory targetQueryCalldata,\n        bytes memory factoryCalldata\n    ) internal returns (address result) {\n        if (_random() % 2 == 0) {\n            return address(\n                new DeploylessPredeployQueryer(\n                    target, targetQueryCalldata, address(factory), factoryCalldata\n                )\n            );\n        }\n        bytes memory args =\n            abi.encode(target, targetQueryCalldata, address(factory), factoryCalldata);\n        bytes memory initcode;\n        if (_random() % 2 == 0) {\n            initcode = _CREATION_CODE;\n        } else {\n            initcode = type(DeploylessPredeployQueryer).creationCode;\n        }\n        initcode = abi.encodePacked(initcode, args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := create(0, add(0x20, initcode), mload(initcode))\n        }\n    }\n\n    function testPredeployQueryer(bytes32 salt) public {\n        unchecked {\n            _TestTemps memory t;\n            t.target = factory.predictDeployment(salt);\n            if (_random() % 2 == 0) {\n                assertEq(factory.deploy(salt), t.target);\n            }\n            t.factoryCalldata = abi.encodeWithSignature(\"deploy(bytes32)\", salt);\n            t.n = _random() % 3;\n            t.targetQueryCalldata = new bytes[](t.n);\n            t.seeds = new uint256[](t.n);\n            if (_random() % 2 == 0) {\n                vm.expectRevert(DeploylessPredeployQueryer.ReturnedAddressMismatch.selector);\n                address wrongTarget = address(uint160(t.target) ^ 1);\n                t.deployed = _deployQuery(wrongTarget, t.targetQueryCalldata, t.factoryCalldata);\n            }\n            if (_random() % 2 == 0) {\n                for (uint256 i; i < t.n; ++i) {\n                    t.seeds[i] = _random();\n                    t.targetQueryCalldata[i] =\n                        abi.encodeWithSignature(\"generate(uint256)\", t.seeds[i]);\n                }\n                t.deployed = _deployQuery(t.target, t.targetQueryCalldata, t.factoryCalldata);\n                t.decoded = abi.decode(t.deployed.code, (bytes[]));\n                assertEq(t.decoded.length, t.n);\n                for (uint256 i; i < t.n; ++i) {\n                    assertEq(\n                        abi.decode(t.decoded[i], (bytes)),\n                        RandomBytesGeneratorLib.generate(t.seeds[i])\n                    );\n                }\n            }\n            for (uint256 i; i < t.n; ++i) {\n                t.seeds[i] = _random();\n                t.targetQueryCalldata[i] = abi.encodeWithSignature(\"next(uint256)\", t.seeds[i]);\n            }\n            t.deployed = _deployQuery(t.target, t.targetQueryCalldata, t.factoryCalldata);\n            t.decoded = abi.decode(t.deployed.code, (bytes[]));\n            for (uint256 i; i < t.n; ++i) {\n                assertEq(\n                    abi.decode(t.decoded[i], (uint256)), RandomBytesGeneratorLib.next(t.seeds[i])\n                );\n            }\n        }\n    }\n}\n",
        "contractname": "DeploylessPredeployQueryer.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 dataSize | PUSH2 dataSize  | dataSize                |                     |\n             * 80          | DUP1            | dataSize dataSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa dataSize dataSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa dataSize dataSize |                     |\n             * 39          | CODECOPY        | dataSize                | [0..dataSize): code |\n             * 3D          | RETURNDATASIZE  | 0 dataSize              | [0..dataSize): code |\n             * F3          | RETURN          |                         | [0..dataSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), shr(16, dataSize))\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         READ LOGIC                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {SSTORE2} from \"../src/utils/SSTORE2.sol\";\n\ncontract SSTORE2Test is SoladyTest {\n    function testWriteRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        address pointer = SSTORE2.write(testBytes);\n\n        assertEq(SSTORE2.read(pointer), testBytes);\n    }\n\n    function testWriteReadFullStartBound() public {\n        assertEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 0), hex\"11223344\");\n    }\n\n    function testWriteReadCustomStartBound() public {\n        assertEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1), hex\"223344\");\n    }\n\n    function testWriteReadFullBoundedRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        assertEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);\n    }\n\n    function testWriteReadCustomBounds() public {\n        assertEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1, 3), hex\"2233\");\n    }\n\n    function testWriteReadEmptyBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 3, 3);\n    }\n\n    function testReadInvalidPointerReverts() public {\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(address(1));\n    }\n\n    function testReadInvalidPointerCustomStartBoundReverts() public {\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(address(1), 1);\n    }\n\n    function testReadInvalidPointerCustomBoundsReverts() public {\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(address(1), 2, 4);\n    }\n\n    function testWriteReadOutOfStartBoundReverts() public {\n        address pointer = SSTORE2.write(hex\"11223344\");\n        vm.expectRevert(SSTORE2.ReadOutOfBounds.selector);\n        SSTORE2.read(pointer, 41000);\n    }\n\n    function testWriteReadEmptyOutOfBoundsReverts() public {\n        address pointer = SSTORE2.write(hex\"11223344\");\n        vm.expectRevert(SSTORE2.ReadOutOfBounds.selector);\n        SSTORE2.read(pointer, 42000, 42000);\n    }\n\n    function testWriteReadOutOfBoundsReverts() public {\n        address pointer = SSTORE2.write(hex\"11223344\");\n        vm.expectRevert(SSTORE2.ReadOutOfBounds.selector);\n        SSTORE2.read(pointer, 41000, 42000);\n    }\n\n    function testWriteRead(bytes calldata testBytes) public brutalizeMemory {\n        _misalignFreeMemoryPointer();\n        bytes memory readResult = SSTORE2.read(SSTORE2.write(testBytes));\n        _checkMemory(readResult);\n        assertEq(readResult, testBytes);\n    }\n\n    function testWriteReadCustomStartBound(bytes calldata testBytes, uint256 startIndex)\n        public\n        brutalizeMemory\n    {\n        if (testBytes.length == 0) return;\n\n        startIndex = _bound(startIndex, 0, testBytes.length);\n\n        _misalignFreeMemoryPointer();\n        bytes memory readResult = SSTORE2.read(SSTORE2.write(testBytes), startIndex);\n        _checkMemory(readResult);\n        assertEq(readResult, bytes(testBytes[startIndex:]));\n    }\n\n    function testWriteReadCustomBounds(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex\n    ) public brutalizeMemory {\n        if (testBytes.length == 0) return;\n\n        endIndex = _bound(endIndex, 0, testBytes.length);\n        startIndex = _bound(startIndex, 0, testBytes.length);\n\n        if (startIndex > endIndex) return;\n\n        _misalignFreeMemoryPointer();\n        bytes memory readResult = SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);\n        _checkMemory(readResult);\n        assertEq(readResult, bytes(testBytes[startIndex:endIndex]));\n    }\n\n    function testReadInvalidPointerRevert(address pointer) public brutalizeMemory {\n        if (pointer.code.length > 0) return;\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(pointer);\n    }\n\n    function testReadInvalidPointerCustomStartBoundReverts(address pointer, uint256 startIndex)\n        public\n        brutalizeMemory\n    {\n        if (pointer.code.length > 0) return;\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testReadInvalidPointerCustomBoundsReverts(\n        address pointer,\n        uint256 startIndex,\n        uint256 endIndex\n    ) public brutalizeMemory {\n        if (pointer.code.length > 0) return;\n        vm.expectRevert(SSTORE2.InvalidPointer.selector);\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testWriteReadCustomStartBoundOutOfRangeReverts(\n        bytes calldata testBytes,\n        uint256 startIndex\n    ) public brutalizeMemory {\n        startIndex = _bound(startIndex, testBytes.length + 1, type(uint256).max);\n        address pointer = SSTORE2.write(testBytes);\n        vm.expectRevert(SSTORE2.ReadOutOfBounds.selector);\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testWriteReadCustomBoundsOutOfRangeReverts(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex\n    ) public brutalizeMemory {\n        endIndex = _bound(endIndex, testBytes.length + 1, type(uint256).max);\n        address pointer = SSTORE2.write(testBytes);\n        vm.expectRevert(SSTORE2.ReadOutOfBounds.selector);\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testWriteReadDeterministic(bytes calldata testBytes) public brutalizeMemory {\n        bytes32 salt = bytes32(_random());\n        address deployer = address(this);\n        if (_random() % 8 == 0) {\n            (deployer,) = _randomSigner();\n        }\n        vm.prank(deployer);\n        address deterministicPointer = SSTORE2.writeDeterministic(testBytes, salt);\n        assertEq(SSTORE2.read(deterministicPointer), testBytes);\n        assertEq(\n            SSTORE2.predictDeterministicAddress(testBytes, salt, deployer), deterministicPointer\n        );\n\n        address pointer = SSTORE2.write(testBytes);\n        assertEq(pointer.code, deterministicPointer.code);\n    }\n\n    function testWriteWithTooBigDataReverts() public {\n        bytes memory data = _dummyData(0xfffe);\n        address pointer = this.write(data);\n        assertEq(SSTORE2.read(pointer), data);\n        vm.expectRevert();\n        pointer = this.write(_dummyData(0xffff));\n    }\n\n    function write(bytes memory data) public returns (address) {\n        return SSTORE2.write(data);\n    }\n\n    function _dummyData(uint256 n) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, n)\n            mstore(0x00, n)\n            mstore(0x20, 1)\n            mstore(add(0x20, result), keccak256(0x00, 0x40))\n            mstore(0x20, 2)\n            mstore(add(add(0x20, result), n), keccak256(0x00, 0x40))\n            mstore(0x20, 3)\n            mstore(add(result, n), keccak256(0x00, 0x40))\n            mstore(0x40, add(add(0x20, result), n))\n        }\n    }\n}\n",
        "contractname": "SSTORE2.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC1155 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)\n///\n/// @dev Note:\n/// - The ERC1155 standard allows for self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The transfer functions use the identity precompile (0x4)\n///   to copy memory internally.\n///\n/// If you are overriding:\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC1155 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The lengths of the input arrays are not the same.\n    error ArrayLengthsMismatch();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Only the token owner or an approved account can manage the tokens.\n    error NotOwnerNorApproved();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC1155Receiver interface.\n    error TransferToNonERC1155ReceiverImplementer();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when `amount` of token `id` is transferred\n    /// from `from` to `to` by `operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    /// @dev Emitted when `amounts` of token `ids` are transferred\n    /// from `from` to `to` by `operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`\n    /// is updated to `value`. This event is not used in the base contract.\n    /// You may need to emit this event depending on your URI logic.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    event URI(string value, uint256 indexed id);\n\n    /// @dev `keccak256(bytes(\"TransferSingle(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\n\n    /// @dev `keccak256(bytes(\"TransferBatch(address,address,address,uint256[],uint256[])\"))`.\n    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\n    /// ```\n    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))\n    /// ```\n    ///\n    /// The balance slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, id)\n    ///     let balanceSlot := keccak256(0x00, 0x40)\n    /// ```\n    ///\n    /// The operator approval slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, operator)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC1155 METADATA                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the URI for token `id`.\n    ///\n    /// You can either return the same templated URI for all token IDs,\n    /// (e.g. \"https://example.com/api/{id}.json\"),\n    /// or return a unique URI for each `id`.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          ERC1155                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the amount of `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }\n\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - If the caller is not `from`,\n    ///   it must be approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferSingle} event.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - `ids` and `amounts` must have the same length.\n    /// - If the caller is not `from`,\n    ///   it must be approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, ids.length))\n                let o := add(m, 0x40)\n                calldatacopy(o, sub(ids.offset, 0x20), n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                calldatacopy(add(o, n), sub(amounts.offset, 0x20), n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x40), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := add(0x20, shl(5, ids.length))\n                let o := add(m, 0xc0)\n                calldatacopy(o, sub(ids.offset, 0x20), n)\n                // Copy the `amounts`.\n                let s := add(0xa0, n)\n                mstore(add(m, 0x80), s)\n                calldatacopy(add(o, n), sub(amounts.offset, 0x20), n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(s, n))\n                calldatacopy(add(o, add(n, n)), sub(data.offset, 0x20), add(0x20, data.length))\n                let nAll := add(0xc4, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(m, 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the amounts of `ids` for `owners.\n    ///\n    /// Requirements:\n    /// - `owners` and `ids` must have the same length.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `amount` of `id` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferSingle} event.\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }\n\n    /// @dev Mints `amounts` of `ids` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `ids` and `amounts` must have the same length.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }\n\n    /// @dev Destroys `amount` of `id` from `from`.\n    ///\n    /// Requirements:\n    /// - `from` must have at least `amount` of `id`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    ///\n    /// Emits a {TransferSingle} event.\n    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }\n\n    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.\n    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }\n\n    /// @dev Destroys `amounts` of `ids` from `from`.\n    ///\n    /// Requirements:\n    /// - `ids` and `amounts` must have the same length.\n    /// - `from` must have at least `amounts` of `ids`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Approve or remove the `operator` as an operator for `by`,\n    /// without authorization checks.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.\n    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }\n\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferSingle} event.\n    function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }\n\n    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.\n    function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }\n\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `ids` and `amounts` must have the same length.\n    /// - `from` must have at least `amounts` of `ids`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    HOOKS FOR OVERRIDING                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev Hook that is called before any token transfer.\n    /// This includes minting and burning, as well as batched variants.\n    ///\n    /// The same hook is called on both single and batched variants.\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /// @dev Override this function to return true if `_afterTokenTransfer` is used.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev Hook that is called after any token transfer.\n    /// This includes minting and burning, as well as batched variants.\n    ///\n    /// The same hook is called on both single and batched variants.\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper for calling the `_afterTokenTransfer` hook.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }\n\n    /// @dev Returns if `a` has bytecode of non-zero length.\n    function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            pop(staticcall(gas(), 4, ids, n, o, n))\n            // Copy the `amounts`.\n            let s := add(0xa0, returndatasize())\n            mstore(add(m, 0x80), s)\n            o := add(o, returndatasize())\n            n := add(0x20, shl(5, mload(amounts)))\n            pop(staticcall(gas(), 4, amounts, n, o, n))\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, returndatasize()))\n            o := add(o, returndatasize())\n            n := add(0x20, mload(data))\n            pop(staticcall(gas(), 4, data, n, o, n))\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns `x` in an array with a single element.\n    function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\n\nimport {ERC1155, MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\n\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        virtual\n        returns (bytes4)\n    {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        public\n        pure\n        override\n        returns (bytes4)\n    {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        public\n        pure\n        override\n        returns (bytes4)\n    {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract MockERC1155WithHooks is MockERC1155 {\n    uint256 public beforeCounter;\n    uint256 public afterCounter;\n\n    function _useBeforeTokenTransfer() internal view virtual override returns (bool) {\n        return true;\n    }\n\n    function _useAfterTokenTransfer() internal view virtual override returns (bool) {\n        return true;\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) internal virtual override {\n        beforeCounter++;\n    }\n\n    function _afterTokenTransfer(address, address, uint256[] memory, uint256[] memory, bytes memory)\n        internal\n        virtual\n        override\n    {\n        afterCounter++;\n    }\n}\n\ncontract ERC1155HooksTest is SoladyTest, ERC1155TokenReceiver {\n    uint256 public expectedBeforeCounter;\n    uint256 public expectedAfterCounter;\n\n    function _checkCounters() internal view {\n        require(\n            expectedBeforeCounter == MockERC1155WithHooks(msg.sender).beforeCounter(),\n            \"Before counter mismatch.\"\n        );\n        require(\n            expectedAfterCounter == MockERC1155WithHooks(msg.sender).afterCounter(),\n            \"After counter mismatch.\"\n        );\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        virtual\n        override\n        returns (bytes4)\n    {\n        _checkCounters();\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        _checkCounters();\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n\n    function _testHooks(MockERC1155WithHooks token) internal {\n        address from = _randomNonZeroAddress();\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.mint(address(this), 1, 1000, \"\");\n\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.safeTransferFrom(address(this), from, 1, 1000, \"\");\n\n        vm.prank(from);\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.safeTransferFrom(from, address(this), 1, 1, \"\");\n\n        vm.prank(from);\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.directSafeTransferFrom(from, address(this), 1, 1, \"\");\n\n        uint256[] memory ids = new uint256[](1);\n        uint256[] memory amounts = new uint256[](1);\n        ids[0] = 1;\n        amounts[0] = 1;\n\n        vm.prank(from);\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.safeBatchTransferFrom(from, address(this), ids, amounts, \"\");\n\n        vm.prank(from);\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.directSafeBatchTransferFrom(from, address(this), ids, amounts, \"\");\n    }\n\n    function testERC1155Hooks() public {\n        MockERC1155WithHooks token = new MockERC1155WithHooks();\n\n        for (uint256 i; i < 32; ++i) {\n            _testHooks(token);\n        }\n    }\n}\n\ncontract ERC1155Test is SoladyTest, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;\n    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;\n\n    struct _TestTemps {\n        address from;\n        address to;\n        uint256 n;\n        uint256[] ids;\n        uint256[] mintAmounts;\n        uint256[] transferAmounts;\n        uint256[] burnAmounts;\n        uint256 id;\n        uint256 mintAmount;\n        uint256 transferAmount;\n        uint256 burnAmount;\n        bytes mintData;\n        bytes burnData;\n        bytes transferData;\n    }\n\n    function _randomBytes() internal returns (bytes memory b) {\n        uint256 r = _random();\n        /// @solidity memory-safe-assembly\n        assembly {\n            b := mload(0x40)\n            mstore(b, mod(r, 65))\n            let t := add(b, 0x20)\n            mstore(t, r)\n            mstore(add(b, 0x40), keccak256(t, 0x20))\n            mstore(0x40, add(b, 0x60))\n        }\n    }\n\n    function _randomArray(uint256 n) internal returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            a := mload(0x40)\n            mstore(a, n)\n            mstore(0x40, add(add(a, 0x20), shl(5, n)))\n        }\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                a[i] = _random();\n            }\n        }\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        unchecked {\n            t.from = _randomNonZeroAddress();\n            do {\n                t.to = _randomNonZeroAddress();\n            } while (t.from == t.to);\n            uint256 n = _random() % 4;\n            t.n = n;\n            t.ids = _randomArray(n);\n            t.mintAmounts = _randomArray(n);\n            t.transferAmounts = _randomArray(n);\n            t.burnAmounts = _randomArray(n);\n            t.mintData = _randomBytes();\n            t.burnData = _randomBytes();\n            t.transferData = _randomBytes();\n            t.id = _random();\n            t.transferAmount = _random();\n            t.burnAmount = _random();\n            t.mintAmount = _random();\n        }\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        if (_random() % 2 == 0) {\n            token.safeTransferFrom(from, to, id, amount, data);\n        } else {\n            token.directSafeTransferFrom(from, to, id, amount, data);\n        }\n    }\n\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        if (_random() % 2 == 0) {\n            token.safeBatchTransferFrom(from, to, ids, amounts, data);\n        } else {\n            token.directSafeBatchTransferFrom(from, to, ids, amounts, data);\n        }\n    }\n\n    function _setApprovalForAll(address operator, bool approved) internal {\n        if (_random() % 2 == 0) {\n            token.setApprovalForAll(operator, approved);\n        } else {\n            token.directSetApprovalForAll(operator, approved);\n        }\n    }\n\n    function _expectMintEvent(address to, uint256 id, uint256 amount) internal {\n        _expectMintEvent(address(this), to, id, amount);\n    }\n\n    function _expectMintEvent(address operator, address to, uint256 id, uint256 amount) internal {\n        _expectTransferEvent(operator, address(0), to, id, amount);\n    }\n\n    function _expectBurnEvent(address from, uint256 id, uint256 amount) internal {\n        _expectBurnEvent(address(this), from, id, amount);\n    }\n\n    function _expectBurnEvent(address operator, address from, uint256 id, uint256 amount)\n        internal\n    {\n        _expectTransferEvent(operator, from, address(0), id, amount);\n    }\n\n    function _expectTransferEvent(address from, address to, uint256 id, uint256 amount) internal {\n        _expectTransferEvent(address(this), from, to, id, amount);\n    }\n\n    function _expectTransferEvent(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        vm.expectEmit(true, true, true, true);\n        emit TransferSingle(operator, from, to, id, amount);\n    }\n\n    function _expectMintEvent(address to, uint256[] memory ids, uint256[] memory amounts)\n        internal\n    {\n        _expectMintEvent(address(this), to, ids, amounts);\n    }\n\n    function _expectMintEvent(\n        address operator,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        _expectTransferEvent(operator, address(0), to, ids, amounts);\n    }\n\n    function _expectBurnEvent(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n    {\n        _expectBurnEvent(address(this), from, ids, amounts);\n    }\n\n    function _expectBurnEvent(\n        address operator,\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        _expectTransferEvent(operator, from, address(0), ids, amounts);\n    }\n\n    function _expectTransferEvent(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        _expectTransferEvent(address(this), from, to, ids, amounts);\n    }\n\n    function _expectTransferEvent(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        vm.expectEmit(true, true, true, true);\n        emit TransferBatch(operator, from, to, ids, amounts);\n    }\n\n    function _expectApprovalForAllEvent(address operator, bool isApproved) internal {\n        _expectApprovalForAllEvent(address(this), operator, isApproved);\n    }\n\n    function _expectApprovalForAllEvent(address owner, address operator, bool isApproved)\n        internal\n    {\n        vm.expectEmit(true, true, true, true);\n        emit ApprovalForAll(owner, operator, isApproved);\n    }\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testDirectSetApprovalForAll(address by, address operator, bool approved) public {\n        _expectApprovalForAllEvent(by, operator, approved);\n        vm.prank(by);\n        token.directSetApprovalForAll(operator, approved);\n    }\n\n    function testAuthorizedEquivalence(address by, address from, bool isApprovedAccount) public {\n        bool a = true;\n        bool b = true;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if by { if iszero(eq(by, from)) { a := isApprovedAccount } }\n            if iszero(or(iszero(by), eq(by, from))) { b := isApprovedAccount }\n        }\n        assertEq(a, b);\n    }\n\n    function testMintToEOA(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        _expectMintEvent(t.to, t.id, t.mintAmount);\n        token.mint(t.to, t.id, t.mintAmount, t.mintData);\n\n        assertEq(token.balanceOf(t.to, t.id), t.mintAmount);\n    }\n\n    function testMintToERC1155Recipient(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        _expectMintEvent(address(to), t.id, t.mintAmount);\n        token.mint(address(to), t.id, t.mintAmount, t.mintData);\n\n        assertEq(token.balanceOf(address(to), t.id), t.mintAmount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), t.id);\n        assertEq(to.mintData(), t.mintData);\n    }\n\n    function testBatchMintToEOA(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[t.to][id] += mintAmount;\n        }\n\n        _expectMintEvent(t.to, t.ids, t.mintAmounts);\n        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            assertEq(token.balanceOf(t.to, id), userMintAmounts[t.to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        _expectMintEvent(address(to), t.ids, t.mintAmounts);\n        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertEq(to.batchIds(), t.ids);\n        assertEq(to.batchAmounts(), t.mintAmounts);\n        assertEq(to.batchData(), t.mintData);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        t.burnAmount = _bound(t.burnAmount, 0, t.mintAmount);\n\n        _expectMintEvent(t.to, t.id, t.mintAmount);\n        token.mint(t.to, t.id, t.mintAmount, t.mintData);\n\n        if (_random() % 2 == 0) {\n            _expectBurnEvent(t.to, t.id, t.burnAmount);\n            token.uncheckedBurn(t.to, t.id, t.burnAmount);\n        } else if (_random() % 8 == 0) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            token.burn(t.to, t.id, t.burnAmount);\n            return;\n        } else {\n            vm.prank(t.to);\n            _setApprovalForAll(address(this), true);\n\n            _expectBurnEvent(t.to, t.id, t.burnAmount);\n            token.burn(t.to, t.id, t.burnAmount);\n        }\n\n        assertEq(token.balanceOf(t.to, t.id), t.mintAmount - t.burnAmount);\n    }\n\n    function testBatchBurn(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];\n\n            t.mintAmounts[i] = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            t.burnAmounts[i] = _bound(t.burnAmounts[i], 0, t.mintAmounts[i]);\n\n            userMintAmounts[t.to][id] += t.mintAmounts[i];\n            userTransferOrBurnAmounts[t.to][id] += t.burnAmounts[i];\n        }\n\n        _expectMintEvent(t.to, t.ids, t.mintAmounts);\n        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);\n\n        if (_random() % 2 == 0) {\n            _expectBurnEvent(t.to, t.ids, t.burnAmounts);\n            token.uncheckedBatchBurn(t.to, t.ids, t.burnAmounts);\n        } else if (_random() % 8 == 0) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            token.batchBurn(t.to, t.ids, t.burnAmounts);\n            return;\n        } else {\n            vm.prank(t.to);\n            _setApprovalForAll(address(this), true);\n\n            _expectBurnEvent(t.to, t.ids, t.burnAmounts);\n            token.batchBurn(t.to, t.ids, t.burnAmounts);\n        }\n\n        for (uint256 i = 0; i < t.ids.length; i++) {\n            uint256 id = t.ids[i];\n\n            assertEq(\n                token.balanceOf(t.to, id),\n                userMintAmounts[t.to][id] - userTransferOrBurnAmounts[t.to][id]\n            );\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        _expectApprovalForAllEvent(to, approved);\n        _setApprovalForAll(to, approved);\n        assertEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(t.from, t.id, t.mintAmount);\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        if (_random() % 2 == 0) {\n            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);\n            token.uncheckedSafeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n        } else if (_random() % 8 == 0) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n            return;\n        } else {\n            vm.prank(t.from);\n            _setApprovalForAll(address(this), true);\n\n            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);\n            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n        }\n\n        if (t.to == t.from) {\n            assertEq(token.balanceOf(t.to, t.id), t.mintAmount);\n        } else {\n            assertEq(token.balanceOf(t.to, t.id), t.transferAmount);\n            assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);\n        }\n    }\n\n    function testSafeTransferFromToERC1155Recipient(uint256) public {\n        _TestTemps memory t = _testTemps();\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(t.from, t.id, t.mintAmount);\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        _expectTransferEvent(t.from, address(to), t.id, t.transferAmount);\n        _safeTransferFrom(t.from, address(to), t.id, t.transferAmount, t.transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), t.from);\n        assertEq(to.id(), t.id);\n        assertEq(to.mintData(), t.transferData);\n\n        assertEq(token.balanceOf(address(to), t.id), t.transferAmount);\n        assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);\n    }\n\n    function testSafeTransferFromSelf(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(address(this), t.id, t.mintAmount);\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        _expectTransferEvent(address(this), t.to, t.id, t.transferAmount);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n\n        assertEq(token.balanceOf(t.to, t.id), t.transferAmount);\n        assertEq(token.balanceOf(address(this), t.id), t.mintAmount - t.transferAmount);\n    }\n\n    function testSafeBatchTransfer() public {\n        for (uint256 i; i != 8; ++i) {\n            testSafeTransferFromToEOA(_random());\n            testSafeBatchTransferFromToERC1155Recipient(_random());\n        }\n    }\n\n    function testSafeBatchTransferFromToEOA(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n            userTransferOrBurnAmounts[t.from][id] += transferAmount;\n        }\n        _expectMintEvent(t.from, t.ids, t.mintAmounts);\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        if (_random() % 2 == 0) {\n            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);\n            token.uncheckedSafeBatchTransferFrom(\n                t.from, t.to, t.ids, t.transferAmounts, t.transferData\n            );\n        } else if (_random() % 8 == 0) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n            return;\n        } else {\n            vm.prank(t.from);\n            _setApprovalForAll(address(this), true);\n\n            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);\n            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n        }\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            assertEq(token.balanceOf(t.to, id), userTransferOrBurnAmounts[t.from][id]);\n            assertEq(\n                token.balanceOf(t.from, id),\n                userMintAmounts[t.from][id] - userTransferOrBurnAmounts[t.from][id]\n            );\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n            userTransferOrBurnAmounts[t.from][id] += transferAmount;\n        }\n\n        _expectMintEvent(t.from, t.ids, t.mintAmounts);\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        _expectTransferEvent(t.from, address(to), t.ids, t.transferAmounts);\n        _safeBatchTransferFrom(t.from, address(to), t.ids, t.transferAmounts, t.transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), t.from);\n        assertEq(to.batchIds(), t.ids);\n        assertEq(to.batchAmounts(), t.transferAmounts);\n        assertEq(to.batchData(), t.transferData);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[t.from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(t.from, id), userMintAmounts[t.from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        address[] memory tos = new address[](t.n);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n            address to = _randomNonZeroAddress();\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            tos[i] = to;\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, t.mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(tos, t.ids);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            assertEq(balances[i], token.balanceOf(tos[i], t.ids[i]));\n        }\n    }\n\n    function testMintToZeroReverts(uint256) public {\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        token.mint(address(0), _random(), _random(), _randomBytes());\n    }\n\n    function testMintToNonERC155RecipientReverts(uint256) public {\n        address to = address(new NonERC1155Recipient());\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        token.mint(to, _random(), _random(), _randomBytes());\n    }\n\n    function testMintToRevertingERC155RecipientReverts(uint256) public {\n        address to = address(new RevertingERC1155Recipient());\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector));\n        token.mint(to, _random(), _random(), _randomBytes());\n    }\n\n    function testMintToWrongReturnDataERC155RecipientReverts(uint256) public {\n        address to = address(new WrongReturnDataERC1155Recipient());\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        token.mint(to, _random(), _random(), _randomBytes());\n    }\n\n    function testBurnInsufficientBalanceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();\n        t.burnAmount = _bound(t.burnAmount, t.mintAmount + 1, type(uint256).max);\n\n        token.mint(t.to, t.id, t.mintAmount, t.mintData);\n\n        vm.prank(t.to);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        token.burn(t.to, t.id, t.burnAmount);\n    }\n\n    function testSafeTransferFromInsufficientBalanceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();\n\n        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);\n\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeTransferFromSelfInsufficientBalanceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();\n\n        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeTransferFromToZeroReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        _safeTransferFrom(address(this), address(0), t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeTransferFromToNonERC155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new NonERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeTransferFromToRevertingERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new RevertingERC1155Recipient());\n\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector));\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new WrongReturnDataERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }\n\n    function testSafeBatchTransferInsufficientBalanceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        while (t.n == 0) t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            if (mintAmount == type(uint256).max) return;\n            uint256 transferAmount = _bound(t.transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }\n\n    function testSafeBatchTransferFromToZeroReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        _safeBatchTransferFrom(t.from, address(0), t.ids, t.transferAmounts, t.transferData);\n    }\n\n    function testSafeBatchTransferFromToNonERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new NonERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }\n\n    function testSafeBatchTransferFromToRevertingERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new RevertingERC1155Recipient());\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector));\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }\n\n    function testSafeBatchTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new WrongReturnDataERC1155Recipient());\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }\n\n    function testSafeBatchTransferFromWithArrayLengthMismatchReverts(uint256) public {\n        uint256[] memory ids = new uint256[](_random() % 4);\n        uint256[] memory mintAmounts = new uint256[](_random() % 4);\n\n        if (ids.length == mintAmounts.length) return;\n\n        address from = address(0xABCD);\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.batchMint(from, ids, mintAmounts, _randomBytes());\n\n        uint256[] memory transferAmounts = new uint256[](_random() % 4);\n        if (ids.length == transferAmounts.length) return;\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        address to = _randomNonZeroAddress();\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        _safeBatchTransferFrom(from, to, ids, transferAmounts, _randomBytes());\n    }\n\n    function testBatchMintToZeroReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        token.batchMint(address(0), t.ids, t.mintAmounts, t.mintData);\n    }\n\n    function testBatchMintToNonERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);\n    }\n\n    function testBatchMintToRevertingERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector));\n        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);\n    }\n\n    function testBatchMintToWrongReturnDataERC1155RecipientReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n\n            t.mintAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        token.batchMint(address(to), t.ids, t.mintAmounts, t.mintData);\n    }\n\n    function testBatchMintWithArrayMismatchReverts(uint256) public {\n        uint256[] memory ids = new uint256[](_random() % 4);\n        uint256[] memory amounts = new uint256[](_random() % 4);\n\n        if (ids.length == amounts.length) return;\n\n        address to = _randomNonZeroAddress();\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.batchMint(to, ids, amounts, _randomBytes());\n    }\n\n    function testBatchBurnInsufficientBalanceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        while (t.n == 0) t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.to][id];\n\n            t.mintAmounts[i] = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            if (t.mintAmounts[i] == type(uint256).max) return;\n            t.burnAmounts[i] = _bound(t.burnAmounts[i], t.mintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[t.to][id] += t.mintAmounts[i];\n        }\n\n        token.batchMint(t.to, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.to);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        token.batchBurn(t.to, t.ids, t.burnAmounts);\n    }\n\n    function testBatchBurnWithArrayLengthMismatchReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        if (t.ids.length == t.burnAmounts.length) t.burnAmounts = _randomArray(t.n + 1);\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.batchBurn(t.to, t.ids, t.burnAmounts);\n    }\n\n    function testBalanceOfBatchWithArrayMismatchReverts(uint256) public {\n        address[] memory tos = new address[](_random() % 4);\n        uint256[] memory ids = new uint256[](_random() % 4);\n        if (tos.length == ids.length) return;\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.balanceOfBatch(tos, ids);\n    }\n}\n",
        "contractname": "ERC1155.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC2981 NFT Royalty Standard implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC2981.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/common/ERC2981.sol)\nabstract contract ERC2981 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The royalty fee numerator exceeds the fee denominator.\n    error RoyaltyOverflow();\n\n    /// @dev The royalty receiver cannot be the zero address.\n    error RoyaltyReceiverIsZeroAddress();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The default royalty info is given by:\n    /// ```\n    ///     let packed := sload(_ERC2981_MASTER_SLOT_SEED)\n    ///     let receiver := shr(96, packed)\n    ///     let royaltyFraction := xor(packed, shl(96, receiver))\n    /// ```\n    ///\n    /// The per token royalty info is given by.\n    /// ```\n    ///     mstore(0x00, tokenId)\n    ///     mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n    ///     let packed := sload(keccak256(0x00, 0x40))\n    ///     let receiver := shr(96, packed)\n    ///     let royaltyFraction := xor(packed, shl(96, receiver))\n    /// ```\n    uint256 private constant _ERC2981_MASTER_SLOT_SEED = 0xaa4ec00224afccfdb7;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          ERC2981                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Checks that `_feeDenominator` is non-zero.\n    constructor() {\n        require(_feeDenominator() != 0, \"Fee denominator cannot be zero.\");\n    }\n\n    /// @dev Returns the denominator for the royalty amount.\n    /// Defaults to 10000, which represents fees in basis points.\n    /// Override this function to return a custom amount if needed.\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC2981: 0x2a55205a.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x2a55205a))\n        }\n    }\n\n    /// @dev Returns the `receiver` and `royaltyAmount` for `tokenId` sold at `salePrice`.\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        public\n        view\n        virtual\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            let packed := sload(keccak256(0x00, 0x40))\n            receiver := shr(96, packed)\n            if iszero(receiver) {\n                packed := sload(mload(0x20))\n                receiver := shr(96, packed)\n            }\n            let x := salePrice\n            let y := xor(packed, shl(96, receiver)) // `feeNumerator`.\n            // Overflow check, equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            // Out-of-gas revert. Should not be triggered in practice, but included for safety.\n            returndatacopy(returndatasize(), returndatasize(), mul(y, gt(x, div(not(0), y))))\n            royaltyAmount := div(mul(x, y), feeDenominator)\n        }\n    }\n\n    /// @dev Sets the default royalty `receiver` and `feeNumerator`.\n    ///\n    /// Requirements:\n    /// - `receiver` must not be the zero address.\n    /// - `feeNumerator` must not be greater than the fee denominator.\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_ERC2981_MASTER_SLOT_SEED, or(packed, feeNumerator))\n        }\n    }\n\n    /// @dev Sets the default royalty `receiver` and `feeNumerator` to zero.\n    function _deleteDefaultRoyalty() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC2981_MASTER_SLOT_SEED, 0)\n        }\n    }\n\n    /// @dev Sets the royalty `receiver` and `feeNumerator` for `tokenId`.\n    ///\n    /// Requirements:\n    /// - `receiver` must not be the zero address.\n    /// - `feeNumerator` must not be greater than the fee denominator.\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator)\n        internal\n        virtual\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), or(packed, feeNumerator))\n        }\n    }\n\n    /// @dev Sets the royalty `receiver` and `feeNumerator` for `tokenId` to zero.\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), 0)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\n\nimport {ERC2981, MockERC2981} from \"./utils/mocks/MockERC2981.sol\";\n\ncontract ERC2981Test is SoladyTest {\n    MockERC2981 token;\n\n    function setUp() public {\n        token = new MockERC2981();\n    }\n\n    struct _TestTemps {\n        uint256 feeDenominator;\n        address[2] receivers;\n        uint256[2] tokenIds;\n        uint256[2] salePrices;\n        uint256[2] royaltyFractions;\n        address defaultReceiver;\n        uint256 defaultRoyaltyFraction;\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        t.feeDenominator = token.feeDenominator();\n        t.tokenIds[0] = _random();\n        do {\n            t.tokenIds[1] = _random();\n        } while (t.tokenIds[0] == t.tokenIds[1]);\n        t.receivers[0] = _randomNonZeroAddress();\n        do {\n            t.receivers[1] = _randomNonZeroAddress();\n        } while (t.receivers[0] == t.receivers[1]);\n        t.salePrices[0] = _bound(_random(), 0, type(uint160).max);\n        t.salePrices[1] = _bound(_random(), 0, type(uint160).max);\n        t.defaultReceiver = _randomNonZeroAddress();\n        t.defaultRoyaltyFraction = _bound(_random(), 0, t.feeDenominator);\n        t.royaltyFractions[0] = _bound(_random(), 0, t.feeDenominator);\n        t.royaltyFractions[1] = _bound(_random(), 0, t.feeDenominator);\n    }\n\n    function testRoyaltyOverflowCheckDifferential(uint256 x, uint256 y) public {\n        unchecked {\n            bool expected = x != 0 && (x * y) / x != y;\n            bool computed;\n            /// @solidity memory-safe-assembly\n            assembly {\n                computed := mul(y, gt(x, div(not(0), y)))\n            }\n            assertEq(computed, expected);\n        }\n    }\n\n    function testSetAndGetRoyaltyInfo(uint256) public {\n        _TestTemps memory t = _testTemps();\n\n        if (_random() % 16 == 0) _checkReverts(t);\n\n        _checkRoyaltyInfoIsZero(t);\n\n        token.setDefaultRoyalty(t.defaultReceiver, uint96(t.defaultRoyaltyFraction));\n        _checkRoyaltyInfoIsDefault(t, 0);\n        _checkRoyaltyInfoIsDefault(t, 1);\n\n        token.setTokenRoyalty(t.tokenIds[0], t.receivers[0], uint96(t.royaltyFractions[0]));\n        _checkRoyaltyInfo(t, 0);\n        _checkRoyaltyInfoIsDefault(t, 1);\n        token.setTokenRoyalty(t.tokenIds[1], t.receivers[1], uint96(t.royaltyFractions[1]));\n        _checkRoyaltyInfo(t, 0);\n        _checkRoyaltyInfo(t, 1);\n\n        if (_random() % 16 == 0) _checkReverts(t);\n\n        token.resetTokenRoyalty(t.tokenIds[0]);\n        _checkRoyaltyInfoIsDefault(t, 0);\n        _checkRoyaltyInfo(t, 1);\n        token.resetTokenRoyalty(t.tokenIds[1]);\n        _checkRoyaltyInfoIsDefault(t, 0);\n        _checkRoyaltyInfoIsDefault(t, 1);\n\n        if (_random() % 16 == 0) _checkReverts(t);\n\n        token.deleteDefaultRoyalty();\n\n        _checkRoyaltyInfoIsZero(t);\n\n        if (_random() % 16 == 0) _checkReverts(t);\n    }\n\n    function _getInvalidFeeNumerator(_TestTemps memory t) internal returns (uint96 r) {\n        while (true) {\n            r = uint96(_random());\n            if (r > t.feeDenominator) break;\n        }\n    }\n\n    function _checkReverts(_TestTemps memory t) internal {\n        vm.expectRevert(ERC2981.RoyaltyReceiverIsZeroAddress.selector);\n        token.setDefaultRoyalty(address(0), 1);\n        vm.expectRevert(ERC2981.RoyaltyOverflow.selector);\n        token.setDefaultRoyalty(t.defaultReceiver, _getInvalidFeeNumerator(t));\n\n        vm.expectRevert(ERC2981.RoyaltyReceiverIsZeroAddress.selector);\n        token.setTokenRoyalty(t.tokenIds[0], address(0), 1);\n        vm.expectRevert(ERC2981.RoyaltyOverflow.selector);\n        token.setTokenRoyalty(t.tokenIds[0], t.receivers[0], _getInvalidFeeNumerator(t));\n\n        vm.expectRevert(ERC2981.RoyaltyReceiverIsZeroAddress.selector);\n        token.setTokenRoyalty(t.tokenIds[1], address(0), 1);\n        vm.expectRevert(ERC2981.RoyaltyOverflow.selector);\n        token.setTokenRoyalty(t.tokenIds[1], t.receivers[1], _getInvalidFeeNumerator(t));\n    }\n\n    function _checkRoyaltyInfoIsZero(_TestTemps memory t) internal {\n        _checkRoyaltyInfo(t, 0, address(0), 0);\n        _checkRoyaltyInfo(t, 1, address(0), 0);\n    }\n\n    function _checkRoyaltyInfoIsDefault(_TestTemps memory t, uint256 i) internal {\n        uint256 expected = t.salePrices[i] * t.defaultRoyaltyFraction / t.feeDenominator;\n        _checkRoyaltyInfo(t, i, t.defaultReceiver, expected);\n    }\n\n    function _checkRoyaltyInfo(_TestTemps memory t, uint256 i) internal {\n        uint256 expected = t.salePrices[i] * t.royaltyFractions[i] / t.feeDenominator;\n        _checkRoyaltyInfo(t, i, t.receivers[i], expected);\n    }\n\n    function _checkRoyaltyInfo(\n        _TestTemps memory t,\n        uint256 i,\n        address expectedReceiver,\n        uint256 expectedAmount\n    ) internal {\n        (address receiver, uint256 amount) = token.royaltyInfo(t.tokenIds[i], t.salePrices[i]);\n        assertEq(receiver, expectedReceiver);\n        assertEq(amount, expectedAmount);\n    }\n}\n",
        "contractname": "ERC2981.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC20} from \"./ERC20.sol\";\n\n/// @notice Simple Wrapped Ether implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/WETH.sol)\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when `amount` is deposited from `from`.\n    event Deposit(address indexed from, uint256 amount);\n\n    /// @dev Emitted when `amount` is withdrawn to `to`.\n    event Withdrawal(address indexed to, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Deposit(address,uint256)\"))`.\n    uint256 private constant _DEPOSIT_EVENT_SIGNATURE =\n        0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c;\n\n    /// @dev `keccak256(bytes(\"Withdrawal(address,uint256)\"))`.\n    uint256 private constant _WITHDRAWAL_EVENT_SIGNATURE =\n        0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Ether\";\n    }\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual override returns (string memory) {\n        return \"WETH\";\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                            WETH                            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deposits `amount` ETH of the caller and mints `amount` WETH to the caller.\n    ///\n    /// Emits a {Deposit} event.\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, callvalue())\n            log2(0x00, 0x20, _DEPOSIT_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Burns `amount` WETH of the caller and sends `amount` ETH to the caller.\n    ///\n    /// Emits a {Withdrawal} event.\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdrawal} event.\n            mstore(0x00, amount)\n            log2(0x00, 0x20, _WITHDRAWAL_EVENT_SIGNATURE, caller())\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), caller(), amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Equivalent to `deposit()`.\n    receive() external payable virtual {\n        deposit();\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport \"./utils/InvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../src/utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../src/tokens/WETH.sol\";\n\ncontract ContractWithoutReceive {}\n\ncontract WETHTest is SoladyTest {\n    WETH weth;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function _expectDepositEvent(address from, uint256 amount) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(from, amount);\n    }\n\n    function _expectDepositEvent(uint256 amount) internal {\n        _expectDepositEvent(address(this), amount);\n    }\n\n    function _expectWithdrawalEvent(address to, uint256 amount) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Withdrawal(to, amount);\n    }\n\n    function _expectWithdrawalEvent(uint256 amount) internal {\n        _expectWithdrawalEvent(address(this), amount);\n    }\n\n    function testMetadata() public {\n        assertEq(weth.name(), \"Wrapped Ether\");\n        assertEq(weth.symbol(), \"WETH\");\n        assertEq(weth.decimals(), 18);\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        _expectDepositEvent(1 ether);\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        _expectDepositEvent(1 ether);\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        _expectDepositEvent(1 ether);\n        weth.deposit{value: 1 ether}();\n\n        _expectWithdrawalEvent(1 ether);\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        _expectDepositEvent(1 ether);\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        _expectWithdrawalEvent(0.5 ether);\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testWithdrawToContractWithoutReceiveReverts() public {\n        address owner = address(new ContractWithoutReceive());\n\n        vm.deal(owner, 1 ether);\n\n        vm.prank(owner);\n        _expectDepositEvent(owner, 1 ether);\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(owner), 1 ether);\n\n        vm.expectRevert(WETH.ETHTransferFailed.selector);\n        vm.prank(owner);\n        weth.withdraw(1 ether);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        amount = _bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        _expectDepositEvent(amount);\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testDeposit(uint256 amount) public {\n        amount = _bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        _expectDepositEvent(amount);\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        depositAmount = _bound(depositAmount, 0, address(this).balance);\n        withdrawAmount = _bound(withdrawAmount, 0, depositAmount);\n\n        _expectDepositEvent(depositAmount);\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        _expectWithdrawalEvent(withdrawAmount);\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is SoladyTest, InvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        _addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n",
        "contractname": "WETH.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple EIP-6909 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC6909.sol)\n///\n/// @dev Note:\n/// The ERC6909 standard allows minting and transferring to and from the zero address,\n/// minting and transferring zero tokens, as well as self-approvals.\n/// For performance, this implementation WILL NOT revert for such actions.\n/// Please add any checks with overrides if desired.\n///\n/// If you are overriding:\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isOperator` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC6909 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient permission to perform the action.\n    error InsufficientPermission();\n\n    /// @dev The balance has overflowed.\n    error BalanceOverflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when `by` transfers `amount` of token `id` from `from` to `to`.\n    event Transfer(\n        address by, address indexed from, address indexed to, uint256 indexed id, uint256 amount\n    );\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    /// @dev Emitted when `owner` approves `spender` to use `amount` of `id` token.\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id, uint256 amount\n    );\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859;\n\n    /// @dev `keccak256(bytes(\"OperatorSet(address,address,bool)\"))`.\n    uint256 private constant _OPERATOR_SET_EVENT_SIGNATURE =\n        0xceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0xb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a7;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\n    /// ```\n    ///     let ownerSlotSeed := or(_ERC6909_MASTER_SLOT_SEED, shl(96, owner))\n    /// ```\n    ///\n    /// The balance slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, id)\n    ///     let balanceSlot := keccak256(0x00, 0x40)\n    /// ```\n    ///\n    /// The operator approval slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, operator)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\n    /// ```\n    ///\n    /// The allowance slot of (`owner`, `spender`, `id`) is given by:\n    /// ```\n    ///     mstore(0x34, ownerSlotSeed)\n    ///     mstore(0x14, spender)\n    ///     mstore(0x00, id)\n    ///     let allowanceSlot := keccak256(0x00, 0x54)\n    /// ```\n    uint256 private constant _ERC6909_MASTER_SLOT_SEED = 0xedcaa89a82293940;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC6909 METADATA                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the name for token `id`.\n    function name(uint256 id) public view virtual returns (string memory);\n\n    /// @dev Returns the symbol for token `id`.\n    function symbol(uint256 id) public view virtual returns (string memory);\n\n    /// @dev Returns the number of decimals for token `id`.\n    /// Returns 18 by default.\n    /// Please override this function if you need to return a custom value.\n    function decimals(uint256 id) public view virtual returns (uint8) {\n        id = id; // Silence compiler warning.\n        return 18;\n    }\n\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          ERC6909                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the amount of token `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Returns the amount of token `id` that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender, uint256 id)\n        public\n        view\n        virtual\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x54))\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }\n\n    /// @dev Checks if a `spender` is approved by `owner` to manage all of their tokens.\n    function isOperator(address owner, address spender) public view virtual returns (bool status) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, spender)\n            status := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Transfers `amount` of token `id` from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - caller must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(msg.sender, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            /// Compute the balance slot and load its value.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(msg.sender, to, id, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` of token `id` from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount` of token `id`.\n    /// -  The caller must have at least `amount` of allowance to transfer the\n    ///    tokens of `from` or approved as an operator.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            mstore(0x14, caller())\n            // Check if the caller is an operator.\n            if iszero(sload(keccak256(0x20, 0x34))) {\n                // Compute the allowance slot and load its value.\n                mstore(0x00, id)\n                let allowanceSlot := keccak256(0x00, 0x54)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if add(allowance_, 1) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n        return true;\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` for the caller for token `id`.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, caller())\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        return true;\n    }\n\n    ///  @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits {OperatorSet} event.\n    function setOperator(address operator, bool approved) public payable virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        return true;\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6909: 0x0f632fb3.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x0f632fb3))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `amount` of token `id` to `to`.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            // Add and store the updated balance\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(address(0), to, id, amount);\n    }\n\n    /// @dev Burns `amount` token `id` from `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0, id)\n        }\n        _afterTokenTransfer(from, address(0), id, amount);\n    }\n\n    /// @dev Transfers `amount` of token `id` from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount` of token `id`.\n    /// - If `by` is not the zero address,\n    ///   it must have at least `amount` of allowance to transfer the\n    ///   tokens of `from` or approved as an operator.\n    ///\n    /// Emits a {Transfer} event.\n    function _transfer(address by, address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let bitmaskAddress := 0xffffffffffffffffffffffffffffffffffffffff\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            // If `by` is not the zero address.\n            if and(bitmaskAddress, by) {\n                mstore(0x14, by)\n                // Check if the `by` is an operator.\n                if iszero(sload(keccak256(0x20, 0x34))) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x00, id)\n                    let allowanceSlot := keccak256(0x00, 0x54)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if add(allowance_, 1) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, and(bitmaskAddress, by))\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, and(bitmaskAddress, from), and(bitmaskAddress, to), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` for `owner` for token `id`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x34)), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }\n\n    ///  @dev Sets whether `operator` is approved to manage the tokens of `owner`.\n    ///\n    /// Emits {OperatorSet} event.\n    function _setOperator(address owner, address operator, bool approved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            // forgefmt: disable-next-line\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, mload(0x0c)))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\n\nimport {ERC6909, MockERC6909} from \"./utils/mocks/MockERC6909.sol\";\n\ncontract ERC6909Test is SoladyTest {\n    MockERC6909 token;\n\n    event Transfer(\n        address by, address indexed from, address indexed to, uint256 indexed id, uint256 amount\n    );\n\n    event OperatorSet(address indexed owner, address indexed spender, bool approved);\n\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id, uint256 amount\n    );\n\n    function setUp() public {\n        token = new MockERC6909();\n    }\n\n    function testMetadata(uint256 id) public {\n        assertEq(token.name(id), \"Solady Token\");\n        assertEq(token.symbol(id), \"ST\");\n    }\n\n    function testMint() public {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0), address(0xBEEF), 1, 1e18);\n\n        token.mint(address(0xBEEF), 1, 1e18);\n        assertEq(token.balanceOf(address(0xBEEF), 1), 1e18);\n    }\n\n    function testDecimals() public {\n        assertEq(token.decimals(1), 18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1, 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0xBEEF), address(0), 1, 0.9e18);\n        token.burn(address(0xBEEF), 1, 0.9e18);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1), 0.1e18);\n    }\n\n    function testApprove() public {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(address(this), address(0xBEEF), 1, 1e18);\n        assertTrue(token.approve(address(0xBEEF), 1, 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF), 1), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1, 1e18);\n\n        assertEq(token.balanceOf(address(this), 1), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(this), address(0xBEEF), 1, 1e18);\n        assertTrue(token.transfer(address(0xBEEF), 1, 1e18));\n        assertEq(token.balanceOf(address(this), 1), 0);\n        assertEq(token.balanceOf(address(0xBEEF), 1), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1, 1e18);\n\n        _approve(from, address(this), 1, 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), from, address(0xBEEF), 1, 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1, 1e18));\n\n        assertEq(token.allowance(from, address(this), 1), 0);\n\n        assertEq(token.balanceOf(from, 1), 0);\n        assertEq(token.balanceOf(address(0xBEEF), 1), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1, 1e18);\n\n        _approve(from, address(this), 1, type(uint256).max);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), from, address(0xBEEF), 1, 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1, 1e18));\n\n        assertEq(token.allowance(from, address(this), 1), type(uint256).max);\n\n        assertEq(token.balanceOf(from, 1), 0);\n        assertEq(token.balanceOf(address(0xBEEF), 1), 1e18);\n    }\n\n    function testOperatorTransferFrom() public {\n        address from = address(0xABcD);\n\n        token.mint(from, 1, 1e18);\n\n        _setOperator(from, address(this), true);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), from, address(0xBEEF), 1, 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1, 1e18));\n\n        assertEq(token.balanceOf(from, 1), 0);\n        assertEq(token.balanceOf(address(0xBEEF), 1), 1e18);\n    }\n\n    function testSetOperator() public {\n        assertEq(token.isOperator(address(this), address(0xBEEF)), false);\n\n        vm.expectEmit(true, true, true, true);\n        emit OperatorSet(address(this), address(0xBEEF), true);\n        token.setOperator(address(0xBEEF), true);\n        assertEq(token.isOperator(address(this), address(0xBEEF)), true);\n    }\n\n    function testTokenURI() public {\n        token.mint(address(0xBEEF), 1, 1e18);\n        assertEq(token.tokenURI(1), \"http://solady.org/1\");\n    }\n\n    function testMintOverMaxUintReverts() public {\n        token.mint(address(this), 1, type(uint256).max);\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.mint(address(this), 1, 1);\n    }\n\n    function testTransferOverMaxUintReverts() public {\n        token.mint(address(this), 1, type(uint256).max);\n        token.transfer(address(0xBEEF), 1, type(uint256).max);\n        token.mint(address(this), 1, 1);\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.transfer(address(0xBEEF), 1, 1);\n    }\n\n    function testTransferFromOverMaxUintReverts() public {\n        address from = address(0xABCD);\n\n        _approve(from, address(this), 1, type(uint256).max);\n\n        token.mint(from, 1, type(uint256).max);\n        token.transferFrom(from, address(0xBEEF), 1, type(uint256).max);\n\n        token.mint(from, 1, 1);\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.transferFrom(from, address(0xBEEF), 1, 1);\n    }\n\n    function testTransferInsufficientBalanceReverts() public {\n        token.mint(address(this), 1, 0.9e18);\n        _expectInsufficientBalanceRevert();\n        token.transfer(address(0xBEEF), 1, 1e18);\n    }\n\n    function testTransferFromInsufficientPermission() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1, 1e18);\n\n        _approve(from, address(this), 1, 0.9e18);\n\n        _expectInsufficientPermissionRevert();\n        token.transferFrom(from, address(0xBEEF), 1, 1e18);\n    }\n\n    function testTransferFromInsufficientBalanceReverts() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1, 0.9e18);\n\n        _approve(from, address(this), 1, 1e18);\n\n        _expectInsufficientBalanceRevert();\n        token.transferFrom(from, address(0xBEEF), 1, 1e18);\n    }\n\n    function testMint(address to, uint256 id, uint256 amount) public {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0), to, id, amount);\n        token.mint(to, id, amount);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testBurn(address from, uint256 id, uint256 mintAmount, uint256 burnAmount) public {\n        burnAmount = _bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount);\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), from, address(0), id, burnAmount);\n        token.burn(from, id, burnAmount);\n\n        assertEq(token.balanceOf(from, id), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 id, uint256 amount) public {\n        _approve(address(this), to, id, amount);\n    }\n\n    function testTransfer(address to, uint256 id, uint256 amount) public {\n        token.mint(address(this), id, amount);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(this), to, id, amount);\n        assertTrue(token.transfer(to, id, amount));\n\n        if (address(this) == to) {\n            assertEq(token.balanceOf(address(this), id), amount);\n        } else {\n            assertEq(token.balanceOf(address(this), id), 0);\n            assertEq(token.balanceOf(to, id), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address spender,\n        address from,\n        address to,\n        uint256 id,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = _bound(amount, 0, approval);\n\n        token.mint(from, id, amount);\n        assertEq(token.balanceOf(from, id), amount);\n\n        _approve(from, spender, id, approval);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(spender, from, to, id, amount);\n        vm.prank(spender);\n        assertTrue(token.transferFrom(from, to, id, amount));\n\n        if (approval == type(uint256).max) {\n            assertEq(token.allowance(from, spender, id), approval);\n        } else {\n            assertEq(token.allowance(from, spender, id), approval - amount);\n        }\n\n        if (from == to) {\n            assertEq(token.balanceOf(from, id), amount);\n        } else {\n            assertEq(token.balanceOf(from, id), 0);\n            assertEq(token.balanceOf(to, id), amount);\n        }\n    }\n\n    function testSetOperator(address owner, address spender, bool approved) public {\n        _setOperator(owner, spender, approved);\n    }\n\n    function testMintOverMaxUintReverts(address to, uint256 id, uint256 amount0, uint256 amount1)\n        public\n    {\n        amount0 = _bound(amount0, 1, type(uint256).max);\n        amount1 = _bound(amount1, type(uint256).max - amount0 + 1, type(uint256).max);\n        token.mint(to, id, amount0);\n\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.mint(to, id, amount1);\n    }\n\n    function testBurnInsufficientBalanceReverts(\n        address to,\n        uint256 mintAmount,\n        uint256 id,\n        uint256 burnAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        burnAmount = _bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount);\n\n        _expectInsufficientBalanceRevert();\n        token.burn(to, id, burnAmount);\n    }\n\n    function testTransferOverMaxUintReverts(\n        address to,\n        uint256 id,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        amount0 = _bound(amount0, 1, type(uint256).max);\n        amount1 = _bound(amount1, type(uint256).max - amount0 + 1, type(uint256).max);\n\n        token.mint(address(this), id, amount0);\n        if (to == address(this) && amount1 > type(uint256).max - amount0) {\n            to = address(uint160(to) ^ 1);\n        }\n        token.transfer(to, id, amount0);\n        token.mint(address(this), id, amount1);\n\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.transfer(to, id, amount1);\n    }\n\n    function testTransferInsufficientBalanceReverts(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount);\n\n        _expectInsufficientBalanceRevert();\n        token.transfer(to, id, sendAmount);\n    }\n\n    function testTransferFromOverMaxUintReverts(\n        address to,\n        uint256 id,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        amount0 = _bound(amount0, 1, type(uint256).max);\n        amount1 = _bound(amount1, type(uint256).max - amount0 + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, amount0);\n        _approve(from, address(this), id, amount0);\n\n        token.transferFrom(from, to, id, amount0);\n\n        if (to == from) {\n            vm.expectRevert(ERC6909.BalanceOverflow.selector);\n            token.mint(from, id, amount1);\n            return;\n        }\n\n        token.mint(from, id, amount1);\n        _approve(from, address(this), id, amount1);\n\n        vm.expectRevert(ERC6909.BalanceOverflow.selector);\n        token.transferFrom(from, to, id, amount1);\n    }\n\n    function testTransferFromInsufficientAllowanceReverts(\n        address to,\n        uint256 id,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (approval == type(uint256).max) approval--;\n        amount = _bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount, id);\n\n        _approve(from, address(this), id, approval);\n\n        _expectInsufficientPermissionRevert();\n        token.transferFrom(from, to, id, amount);\n    }\n\n    function testTransferFromInsufficientBalanceReverts(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount);\n\n        _approve(from, address(this), id, sendAmount);\n\n        _expectInsufficientBalanceRevert();\n        token.transferFrom(from, to, id, sendAmount);\n    }\n\n    function testTransferFromCallerIsNotOperator(address to, uint256 id, uint256 amount) public {\n        amount = _bound(amount, 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, amount);\n\n        _expectInsufficientPermissionRevert();\n        token.transferFrom(from, to, id, amount);\n    }\n\n    struct _TestTemps {\n        uint256 id;\n        uint256 allowance;\n        bool isOperator;\n        uint256 balance;\n        uint256 amount;\n        address by;\n        address from;\n        address to;\n        bool success;\n    }\n\n    function testDirectSetOperator() public {\n        _directSetOperator(address(1), address(2), true);\n    }\n\n    function testDirectApprove() public {\n        _directApprove(address(1), address(2), 1, 123);\n    }\n\n    function testDirectTransfer() public {\n        token.mint(address(2), 1, 1);\n        vm.prank(address(2));\n        token.approve(address(1), 1, 1);\n        token.directTransferFrom(address(1), address(2), address(3), 1, 1);\n    }\n\n    function testDirectFunctions(uint256) public {\n        _TestTemps memory t;\n        t.id = _random();\n        t.by = _random() % 16 == 0 ? address(0) : _randomAddress();\n        t.from = _randomAddress();\n        t.to = _randomAddress();\n\n        for (uint256 q; q != 2; ++q) {\n            t.success = false;\n            t.allowance = _random();\n            t.balance = _random();\n            t.amount = _random();\n            t.isOperator = _random() % 4 == 0;\n            t.id ^= 1;\n\n            token.mint(t.from, t.id, t.balance);\n            if (_random() % 2 == 0) {\n                _directSetOperator(t.from, t.by, t.isOperator);\n                _directApprove(t.from, t.by, t.id, t.allowance);\n            } else {\n                _setOperator(t.from, t.by, t.isOperator);\n                _directApprove(t.from, t.by, t.id, t.allowance);\n            }\n\n            if (t.balance >= t.amount) {\n                if (t.by == address(0) || t.isOperator || t.allowance >= t.amount) {\n                    t.success = true;\n                } else {\n                    _expectInsufficientPermissionRevert();\n                }\n            } else {\n                if (t.by == address(0) || t.isOperator || t.allowance >= t.amount) {\n                    _expectInsufficientBalanceRevert();\n                } else {\n                    _expectInsufficientPermissionRevert();\n                }\n            }\n\n            if (t.by == address(0) && _random() % 4 == 0) {\n                if (t.success) {\n                    vm.expectEmit(true, true, true, true);\n                    emit Transfer(t.from, t.from, t.to, t.id, t.amount);\n                }\n                vm.prank(t.from);\n                token.transfer(t.to, t.id, t.amount);\n            } else if (t.by != address(0) && _random() % 4 == 0) {\n                if (t.success) {\n                    vm.expectEmit(true, true, true, true);\n                    emit Transfer(t.by, t.from, t.to, t.id, t.amount);\n                }\n                vm.prank(t.by);\n                token.transferFrom(t.from, t.to, t.id, t.amount);\n            } else {\n                if (t.success) {\n                    vm.expectEmit(true, true, true, true);\n                    emit Transfer(t.by, t.from, t.to, t.id, t.amount);\n                }\n                token.directTransferFrom(t.by, t.from, t.to, t.id, t.amount);\n            }\n\n            if (t.by == address(0) || t.isOperator || t.allowance == type(uint256).max) {\n                assertEq(token.allowance(t.from, t.by, t.id), t.allowance);\n            }\n\n            if (t.success) {\n                if (t.to == t.from) {\n                    assertEq(token.balanceOf(t.to, t.id), t.balance);\n                } else {\n                    assertEq(token.balanceOf(t.from, t.id), t.balance - t.amount);\n                    assertEq(token.balanceOf(t.to, t.id), t.amount);\n                }\n            }\n        }\n    }\n\n    function _expectInsufficientBalanceRevert() internal {\n        vm.expectRevert(ERC6909.InsufficientBalance.selector);\n    }\n\n    function _expectInsufficientPermissionRevert() internal {\n        vm.expectRevert(ERC6909.InsufficientPermission.selector);\n    }\n\n    function _approve(address owner, address spender, uint256 id, uint256 amount) internal {\n        vm.prank(owner);\n        vm.expectEmit(true, true, true, true);\n        emit Approval(owner, spender, id, amount);\n        token.approve(spender, id, amount);\n        assertEq(token.allowance(owner, spender, id), amount);\n    }\n\n    function _setOperator(address owner, address operator, bool approved) internal {\n        vm.prank(owner);\n        vm.expectEmit(true, true, true, true);\n        emit OperatorSet(owner, operator, approved);\n        token.directSetOperator(owner, operator, approved);\n        assertEq(token.isOperator(owner, operator), approved);\n    }\n\n    function _directApprove(address owner, address spender, uint256 id, uint256 amount) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(owner, spender, id, amount);\n        token.directApprove(owner, spender, id, amount);\n        assertEq(token.allowance(owner, spender, id), amount);\n    }\n\n    function _directSetOperator(address owner, address operator, bool approved) internal {\n        vm.expectEmit(true, true, true, true);\n        emit OperatorSet(owner, operator, approved);\n        token.directSetOperator(owner, operator, approved);\n        assertEq(token.isOperator(owner, operator), approved);\n    }\n}\n",
        "contractname": "ERC6909.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC721 implementation with storage hitchhiking.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)\n///\n/// @dev Note:\n/// - The ERC721 standard allows for self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - For performance, methods are made payable where permitted by the ERC721 standard.\n/// - The `safeTransfer` functions use the identity precompile (0x4)\n///   to copy memory internally.\n///\n/// If you are overriding:\n/// - NEVER violate the ERC721 invariant:\n///   the balance of an owner MUST always be equal to their number of ownership slots.\n///   The transfer functions do not have an underflow guard for user token balances.\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC721 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev An account can hold up to 4294967295 tokens.\n    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Only the token owner or an approved account can manage the token.\n    error NotOwnerNorApproved();\n\n    /// @dev The token does not exist.\n    error TokenDoesNotExist();\n\n    /// @dev The token already exists.\n    error TokenAlreadyExists();\n\n    /// @dev Cannot query the balance for the zero address.\n    error BalanceQueryForZeroAddress();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The token must be owned by `from`.\n    error TransferFromIncorrectOwner();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC721Receiver interface.\n    error TransferToNonERC721ReceiverImplementer();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ownership data slot of `id` is given by:\n    /// ```\n    ///     mstore(0x00, id)\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n    /// ```\n    /// Bits Layout:\n    /// - [0..159]   `addr`\n    /// - [160..255] `extraData`\n    ///\n    /// The approved address slot is given by: `add(1, ownershipSlot)`.\n    ///\n    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip\n    ///\n    /// The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x1c)\n    /// ```\n    /// Bits Layout:\n    /// - [0..31]   `balance`\n    /// - [32..255] `aux`\n    ///\n    /// The `operator` approval slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n    ///     mstore(0x00, owner)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)\n    /// ```\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\n\n    /// @dev Pre-shifted and pre-masked constant.\n    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC721 METADATA                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the token collection name.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the token collection symbol.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           ERC721                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the owner of token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the number of tokens owned by `owner`.\n    ///\n    /// Requirements:\n    /// - `owner` must not be the zero address.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }\n\n    /// @dev Returns the account approved to manage token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - The caller must be the owner of the token,\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits an {Approval} event.\n    function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits an {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL QUERY FUNCTIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns if token `id` exists.\n    function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }\n\n    /// @dev Returns the owner of token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // For performance, no events are emitted for the hitchhiking setters.\n    // Please emit your own events if required.\n\n    /// @dev Returns the auxiliary data for `owner`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }\n\n    /// @dev Set the auxiliary data for `owner` to `value`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }\n\n    /// @dev Returns the extra data for token `id`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Sets the extra data for token `id` to `value`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    /// @dev Mints token `id` to `to`, and updates the extra data for token `id` to `value`.\n    /// Does NOT check if token `id` already exists (assumes `id` is auto-incrementing).\n    ///\n    /// Requirements:\n    ///\n    /// - `to` cannot be the zero address.\n    ///\n    /// Emits a {Transfer} event.\n    function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    /// @dev Equivalent to `_safeMint(to, id, \"\")`.\n    function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `_burn(address(0), id)`.\n    function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }\n\n    /// @dev Destroys token `id`, using `by`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns whether `account` is the owner of token `id`, or is approved to manage it.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the account approved to manage token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Equivalent to `_approve(address(0), account, id)`.\n    function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address, `by` must be the owner\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address by, address account, uint256 id) internal virtual {\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }\n\n    /// @dev Approve or remove the `operator` as an operator for `by`,\n    /// without authorization checks.\n    ///\n    /// Emits an {ApprovalForAll} event.\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.\n    function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(from, to, id, \"\")`.\n    function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(by, from, to, id, \"\")`.\n    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    HOOKS FOR OVERRIDING                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any token transfers, including minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /// @dev Hook that is called after any token transfers, including minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns if `a` has bytecode of non-zero length.\n    function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\n\nimport {ERC721, MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        virtual\n        returns (bytes4)\n    {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(address _operator, address _from, uint256 _id, bytes calldata _data)\n        public\n        virtual\n        override\n        returns (bytes4)\n    {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        public\n        virtual\n        override\n        returns (bytes4)\n    {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        public\n        virtual\n        override\n        returns (bytes4)\n    {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract MockERC721WithHooks is MockERC721 {\n    uint256 public beforeCounter;\n    uint256 public afterCounter;\n\n    function _beforeTokenTransfer(address, address, uint256) internal virtual override {\n        beforeCounter++;\n    }\n\n    function _afterTokenTransfer(address, address, uint256) internal virtual override {\n        afterCounter++;\n    }\n}\n\ncontract ERC721HooksTest is SoladyTest, ERC721TokenReceiver {\n    uint256 public expectedBeforeCounter;\n    uint256 public expectedAfterCounter;\n    uint256 public ticker;\n\n    function _checkCounters() internal view {\n        require(\n            expectedBeforeCounter == MockERC721WithHooks(msg.sender).beforeCounter(),\n            \"Before counter mismatch.\"\n        );\n        require(\n            expectedAfterCounter == MockERC721WithHooks(msg.sender).afterCounter(),\n            \"After counter mismatch.\"\n        );\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        virtual\n        override\n        returns (bytes4)\n    {\n        _checkCounters();\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function _testHooks(MockERC721WithHooks token) internal {\n        address from = _randomNonZeroAddress();\n        uint256 tokenId =\n            uint256(keccak256(abi.encode(expectedBeforeCounter, expectedAfterCounter)));\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.mint(address(this), tokenId);\n\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        token.transferFrom(address(this), from, tokenId);\n\n        expectedBeforeCounter++;\n        expectedAfterCounter++;\n        uint256 r = ticker < 4 ? ticker : _random() % 4;\n        vm.prank(from);\n        if (r == 0) {\n            token.safeTransferFrom(from, address(this), tokenId);\n        } else if (r == 1) {\n            token.safeTransferFrom(from, address(this), tokenId, \"\");\n        } else if (r == 2) {\n            token.directSafeTransferFrom(from, address(this), tokenId);\n        } else if (r == 3) {\n            token.directSafeTransferFrom(from, address(this), tokenId, \"\");\n        } else {\n            revert();\n        }\n    }\n\n    function testERC721Hooks() public {\n        MockERC721WithHooks token = new MockERC721WithHooks();\n\n        for (uint256 i; i < 32; ++i) {\n            _testHooks(token);\n        }\n    }\n}\n\ncontract ERC721Test is SoladyTest {\n    MockERC721 token;\n\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setUp() public {\n        token = new MockERC721();\n    }\n\n    function _expectMintEvent(address to, uint256 id) internal {\n        _expectTransferEvent(address(0), to, id);\n    }\n\n    function _expectBurnEvent(address from, uint256 id) internal {\n        _expectTransferEvent(from, address(0), id);\n    }\n\n    function _expectTransferEvent(address from, address to, uint256 id) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, to, id);\n    }\n\n    function _expectApprovalEvent(address owner, address approved, uint256 id) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(owner, approved, id);\n    }\n\n    function _expectApprovalForAllEvent(address owner, address operator, bool approved) internal {\n        vm.expectEmit(true, true, true, true);\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _aux(address owner) internal pure returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, owner)\n            result := shr(32, shl(32, keccak256(0x0c, 0x14)))\n        }\n    }\n\n    function _extraData(uint256 id) internal pure returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            result := shr(160, shl(160, keccak256(0x00, 0x20)))\n        }\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        if (_random() % 2 == 0) {\n            token.transferFrom(from, to, id);\n        } else {\n            token.directTransferFrom(from, to, id);\n        }\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 id) internal {\n        if (_random() % 2 == 0) {\n            token.safeTransferFrom(from, to, id);\n        } else {\n            token.directSafeTransferFrom(from, to, id);\n        }\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 id, bytes memory data) internal {\n        if (_random() % 2 == 0) {\n            token.safeTransferFrom(from, to, id, data);\n        } else {\n            token.directSafeTransferFrom(from, to, id, data);\n        }\n    }\n\n    function _approve(address spender, uint256 id) internal {\n        if (_random() % 2 == 0) {\n            token.approve(spender, id);\n        } else {\n            token.directApprove(spender, id);\n        }\n    }\n\n    function _setApprovalForAll(address operator, bool approved) internal {\n        if (_random() % 2 == 0) {\n            token.setApprovalForAll(operator, approved);\n        } else {\n            token.directSetApprovalForAll(operator, approved);\n        }\n    }\n\n    function _ownerOf(uint256 id) internal returns (address) {\n        if (_random() % 2 == 0) {\n            return token.ownerOf(id);\n        } else {\n            return token.directOwnerOf(id);\n        }\n    }\n\n    function _getApproved(uint256 id) internal returns (address) {\n        if (_random() % 2 == 0) {\n            return token.getApproved(id);\n        } else {\n            return token.directGetApproved(id);\n        }\n    }\n\n    function _owners() internal returns (address a, address b) {\n        a = _randomNonZeroAddress();\n        b = _randomNonZeroAddress();\n        while (a == b) b = _randomNonZeroAddress();\n    }\n\n    function testSafetyOfCustomStorage(uint256 id0, uint256 id1) public {\n        bool safe;\n        while (id0 == id1) id1 = _random();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id0)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let slot0 := add(id0, add(id0, keccak256(0x00, 0x20)))\n            let slot2 := add(1, slot0)\n            mstore(0x00, id1)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let slot1 := add(id1, add(id1, keccak256(0x00, 0x20)))\n            let slot3 := add(1, slot1)\n            safe := 1\n            if eq(slot0, slot1) { safe := 0 }\n            if eq(slot0, slot2) { safe := 0 }\n            if eq(slot0, slot3) { safe := 0 }\n            if eq(slot1, slot2) { safe := 0 }\n            if eq(slot1, slot3) { safe := 0 }\n            if eq(slot2, slot3) { safe := 0 }\n        }\n        require(safe, \"Custom storage not safe\");\n    }\n\n    function testAuthorizedEquivalence(address by, bool isOwnerOrOperator, bool isApprovedAccount)\n        public\n    {\n        bool a = true;\n        bool b = true;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if by { if iszero(isOwnerOrOperator) { a := isApprovedAccount } }\n            if iszero(or(iszero(by), isOwnerOrOperator)) { b := isApprovedAccount }\n        }\n        assertEq(a, b);\n    }\n\n    function testCannotExceedMaxBalance() public {\n        bytes32 balanceSlot;\n        (address owner0, address owner1) = _owners();\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner0)\n            balanceSlot := keccak256(0x0c, 0x1c)\n        }\n\n        vm.store(address(token), balanceSlot, bytes32(uint256(0xfffffffe)));\n        token.setAux(owner0, type(uint224).max);\n        assertEq(token.balanceOf(owner0), 0xfffffffe);\n        assertEq(token.getAux(owner0), type(uint224).max);\n        token.mint(owner0, 0);\n        assertEq(token.balanceOf(owner0), 0xffffffff);\n\n        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);\n        token.mint(owner0, 1);\n\n        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);\n        token.mintWithExtraDataUnchecked(owner0, 1, _extraData(1));\n\n        token.uncheckedBurn(0);\n        assertEq(token.balanceOf(owner0), 0xfffffffe);\n\n        token.mint(owner1, 0);\n        vm.prank(owner1);\n        _transferFrom(owner1, owner0, 0);\n\n        token.mint(owner1, 1);\n        vm.expectRevert(ERC721.AccountBalanceOverflow.selector);\n        vm.prank(owner1);\n        _transferFrom(owner1, owner0, 1);\n        assertEq(token.getAux(owner0), type(uint224).max);\n    }\n\n    function testMint(uint256 id) public {\n        address owner = _randomNonZeroAddress();\n\n        _expectMintEvent(owner, id);\n        token.mint(owner, id);\n\n        assertEq(token.balanceOf(owner), 1);\n        assertEq(_ownerOf(id), owner);\n    }\n\n    function testMintAndSetExtraDataUnchecked(uint256 id) public {\n        address owner = _randomNonZeroAddress();\n\n        _expectMintEvent(owner, id);\n        token.mintWithExtraDataUnchecked(owner, id, _extraData(id));\n\n        assertEq(token.balanceOf(owner), 1);\n        assertEq(_ownerOf(id), owner);\n        assertEq(token.getExtraData(id), _extraData(id));\n    }\n\n    function testMintAndSetExtraDataUncheckedWithOverwrite(uint256 id, uint96 random) public {\n        address owner = _randomNonZeroAddress();\n\n        token.setExtraData(id, random);\n        assertEq(token.getExtraData(id), random);\n\n        _expectMintEvent(owner, id);\n        token.mintWithExtraDataUnchecked(owner, id, _extraData(id));\n\n        assertEq(token.getExtraData(id), _extraData(id));\n    }\n\n    function testBurn(uint256 id) public {\n        address owner = _randomNonZeroAddress();\n\n        _expectMintEvent(owner, id);\n        token.mint(owner, id);\n\n        if (_random() % 2 == 0) {\n            _expectBurnEvent(owner, id);\n            token.uncheckedBurn(id);\n        } else {\n            vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n            token.burn(id);\n            uint256 r = _random() % 3;\n            if (r == 0) {\n                vm.prank(owner);\n                _transferFrom(owner, address(this), id);\n                _expectBurnEvent(address(this), id);\n                token.burn(id);\n            }\n            if (r == 1) {\n                vm.prank(owner);\n                _setApprovalForAll(address(this), true);\n                _expectBurnEvent(owner, id);\n                token.burn(id);\n            }\n            if (r == 2) {\n                vm.prank(owner);\n                _approve(address(this), id);\n                _expectBurnEvent(owner, id);\n                token.burn(id);\n            }\n        }\n\n        assertEq(token.balanceOf(owner), 0);\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }\n\n    function testTransferFrom() public {\n        address owner = _randomNonZeroAddress();\n        token.mint(owner, 0);\n        vm.prank(owner);\n        token.transferFrom(owner, address(this), 0);\n    }\n\n    function testEverything(uint256) public {\n        address[2] memory owners;\n        uint256[][2] memory tokens;\n\n        unchecked {\n            (owners[0], owners[1]) = _owners();\n            for (uint256 j; j != 2; ++j) {\n                tokens[j] = new uint256[](_random() % 3);\n            }\n\n            for (uint256 j; j != 2; ++j) {\n                token.setAux(owners[j], _aux(owners[j]));\n                for (uint256 i; i != tokens[j].length;) {\n                    uint256 id = _random();\n                    if (!token.exists(id)) {\n                        tokens[j][i++] = id;\n                        _expectMintEvent(owners[j], id);\n                        token.mint(owners[j], id);\n                        token.setExtraData(id, _extraData(id));\n                    }\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                assertEq(token.balanceOf(owners[j]), tokens[j].length);\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    vm.prank(owners[j]);\n                    _expectApprovalEvent(owners[j], address(this), tokens[j][i]);\n                    _approve(address(this), tokens[j][i]);\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    assertEq(_getApproved(tokens[j][i]), address(this));\n                    uint256 fromBalanceBefore = token.balanceOf(owners[j]);\n                    uint256 toBalanceBefore = token.balanceOf(owners[j ^ 1]);\n                    _expectTransferEvent(owners[j], owners[j ^ 1], tokens[j][i]);\n                    _transferFrom(owners[j], owners[j ^ 1], tokens[j][i]);\n                    assertEq(token.balanceOf(owners[j]), fromBalanceBefore - 1);\n                    assertEq(token.balanceOf(owners[j ^ 1]), toBalanceBefore + 1);\n                    assertEq(_getApproved(tokens[j][i]), address(0));\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    assertEq(_ownerOf(tokens[j][i]), owners[j ^ 1]);\n                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));\n                }\n            }\n            if (_random() % 2 == 0) {\n                for (uint256 j; j != 2; ++j) {\n                    for (uint256 i; i != tokens[j].length; ++i) {\n                        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);\n                        vm.prank(owners[j ^ 1]);\n                        _expectApprovalEvent(owners[j ^ 1], address(this), tokens[j][i]);\n                        _approve(address(this), tokens[j][i]);\n                        _expectTransferEvent(owners[j ^ 1], owners[j], tokens[j][i]);\n                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);\n                    }\n                }\n            } else {\n                for (uint256 j; j != 2; ++j) {\n                    vm.prank(owners[j ^ 1]);\n                    _expectApprovalForAllEvent(owners[j ^ 1], address(this), true);\n                    token.setApprovalForAll(address(this), true);\n                    for (uint256 i; i != tokens[j].length; ++i) {\n                        _expectTransferEvent(owners[j ^ 1], owners[j], tokens[j][i]);\n                        _transferFrom(owners[j ^ 1], owners[j], tokens[j][i]);\n                    }\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                assertEq(token.getAux(owners[j]), _aux(owners[j]));\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    assertEq(_ownerOf(tokens[j][i]), owners[j]);\n                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    token.uncheckedBurn(tokens[j][i]);\n                }\n            }\n            for (uint256 j; j != 2; ++j) {\n                assertEq(token.balanceOf(owners[j]), 0);\n                for (uint256 i; i != tokens[j].length; ++i) {\n                    assertEq(token.getExtraData(tokens[j][i]), _extraData(tokens[j][i]));\n                }\n            }\n        }\n    }\n\n    function testIsApprovedOrOwner(uint256 id) public {\n        (address owner0, address owner1) = _owners();\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        token.isApprovedOrOwner(owner0, id);\n\n        token.mint(owner0, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n\n        vm.prank(owner0);\n        _transferFrom(owner0, owner1, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), false);\n\n        vm.prank(owner1);\n        _setApprovalForAll(owner0, true);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n\n        vm.prank(owner1);\n        _setApprovalForAll(owner0, false);\n        assertEq(token.isApprovedOrOwner(owner0, id), false);\n\n        vm.prank(owner1);\n        _approve(owner0, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n    }\n\n    function testExtraData(uint256 id) public {\n        (address owner0, address owner1) = _owners();\n\n        bool setExtraData = _random() % 2 == 0;\n        uint96 extraData = uint96(_bound(_random(), 0, type(uint96).max));\n        if (setExtraData) {\n            token.setExtraData(id, extraData);\n        }\n        _expectMintEvent(owner0, id);\n        token.mint(owner0, id);\n        if (setExtraData) {\n            assertEq(token.getExtraData(id), extraData);\n        } else {\n            assertEq(token.getExtraData(id), 0);\n        }\n\n        vm.prank(owner0);\n        _expectTransferEvent(owner0, owner1, id);\n        _transferFrom(owner0, owner1, id);\n        if (setExtraData) {\n            assertEq(token.getExtraData(id), extraData);\n        } else {\n            assertEq(token.getExtraData(id), 0);\n        }\n        assertEq(_ownerOf(id), owner1);\n\n        if (_random() % 2 == 0) {\n            extraData = uint96(_bound(_random(), 0, type(uint96).max));\n            token.setExtraData(id, extraData);\n            setExtraData = true;\n        }\n\n        _expectBurnEvent(owner1, id);\n        token.uncheckedBurn(id);\n        if (setExtraData) {\n            assertEq(token.getExtraData(id), extraData);\n        } else {\n            assertEq(token.getExtraData(id), 0);\n        }\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }\n\n    function testExtraData2(uint256 id0, uint256 id1) public {\n        while (id0 == id1) id1 = _random();\n        token.setExtraData(id0, _extraData(id0));\n        token.setExtraData(id1, _extraData(id1));\n        assertEq(token.getExtraData(id0), _extraData(id0));\n        assertEq(token.getExtraData(id1), _extraData(id1));\n    }\n\n    function testAux(uint256) public {\n        (address owner0, address owner1) = _owners();\n\n        bool setAux = _random() % 2 == 0;\n        if (setAux) {\n            token.setAux(owner0, _aux(owner0));\n            token.setAux(owner1, _aux(owner1));\n        }\n\n        for (uint256 i; i < 2; ++i) {\n            _expectMintEvent(owner0, i * 2 + 0);\n            token.mint(owner0, i * 2 + 0);\n            assertEq(token.balanceOf(owner0), i + 1);\n\n            _expectMintEvent(owner1, i * 2 + 1);\n            token.mint(owner1, i * 2 + 1);\n            assertEq(token.balanceOf(owner1), i + 1);\n\n            if (setAux) {\n                assertEq(token.getAux(owner0), _aux(owner0));\n                assertEq(token.getAux(owner1), _aux(owner1));\n            } else {\n                assertEq(token.getAux(owner0), 0);\n                assertEq(token.getAux(owner1), 0);\n            }\n        }\n\n        for (uint256 i; i < 2; ++i) {\n            _expectBurnEvent(owner0, i * 2 + 0);\n            token.uncheckedBurn(i * 2 + 0);\n            assertEq(token.balanceOf(owner0), 1 - i);\n\n            _expectBurnEvent(owner1, i * 2 + 1);\n            token.uncheckedBurn(i * 2 + 1);\n            assertEq(token.balanceOf(owner1), 1 - i);\n\n            if (setAux) {\n                assertEq(token.getAux(owner0), _aux(owner0));\n                assertEq(token.getAux(owner1), _aux(owner1));\n            } else {\n                assertEq(token.getAux(owner0), 0);\n                assertEq(token.getAux(owner1), 0);\n            }\n        }\n    }\n\n    function testApprove(uint256 id) public {\n        (address spender,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _expectApprovalEvent(address(this), spender, id);\n        _approve(spender, id);\n        assertEq(_getApproved(id), spender);\n    }\n\n    function testApproveBurn(uint256 id) public {\n        (address spender,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _approve(spender, id);\n\n        token.uncheckedBurn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _getApproved(id);\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }\n\n    function testApproveAll(uint256) public {\n        (address operator,) = _randomSigner();\n        bool approved = _random() % 2 == 0;\n        _expectApprovalForAllEvent(address(this), operator, approved);\n        _setApprovalForAll(operator, approved);\n        assertEq(token.isApprovedForAll(address(this), operator), approved);\n    }\n\n    function testTransferFrom(uint256 id) public {\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        if (_random() % 2 == 0) {\n            uint256 r = _random() % 3;\n            if (r == 0) {\n                vm.prank(from);\n                _approve(address(this), id);\n                _expectTransferEvent(from, to, id);\n                _transferFrom(from, to, id);\n            }\n            if (r == 1) {\n                vm.prank(from);\n                _setApprovalForAll(address(this), true);\n                _expectTransferEvent(from, to, id);\n                _transferFrom(from, to, id);\n            }\n            if (r == 2) {\n                vm.prank(from);\n                _expectTransferEvent(from, address(this), id);\n                _transferFrom(from, address(this), id);\n                _expectTransferEvent(address(this), to, id);\n                _transferFrom(address(this), to, id);\n            }\n        } else {\n            (address temp,) = _randomSigner();\n            while (temp == from || temp == to) (temp,) = _randomSigner();\n            if (_random() % 2 == 0) {\n                _expectTransferEvent(from, temp, id);\n                token.uncheckedTransferFrom(from, temp, id);\n            } else {\n                vm.prank(from);\n                _expectTransferEvent(from, temp, id);\n                _transferFrom(from, temp, id);\n            }\n            _expectTransferEvent(temp, to, id);\n            token.uncheckedTransferFrom(temp, to, id);\n        }\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id) public {\n        (address to,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _transferFrom(address(this), to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id) public {\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _transferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id) public {\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes memory data) public {\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(recipient.data(), data);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeMintToEOA(uint256 id) public {\n        (address to,) = _randomSigner();\n\n        token.safeMint(to, id);\n\n        assertEq(_ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(_ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes memory data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(_ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertEq(to.data(), data);\n    }\n\n    function testMintToZeroReverts(uint256 id) public {\n        vm.expectRevert(ERC721.TransferToZeroAddress.selector);\n        token.mint(address(0), id);\n\n        vm.expectRevert(ERC721.TransferToZeroAddress.selector);\n        token.mintWithExtraDataUnchecked(address(0), id, _extraData(id));\n    }\n\n    function testDoubleMintReverts(uint256 id) public {\n        (address to,) = _randomSigner();\n\n        token.mint(to, id);\n        vm.expectRevert(ERC721.TokenAlreadyExists.selector);\n        token.mint(to, id);\n    }\n\n    function testBurnNonExistentReverts(uint256 id) public {\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        token.uncheckedBurn(id);\n    }\n\n    function testDoubleBurnReverts(uint256 id) public {\n        (address to,) = _randomSigner();\n\n        token.mint(to, id);\n\n        token.uncheckedBurn(id);\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        token.uncheckedBurn(id);\n    }\n\n    function testApproveNonExistentReverts(uint256 id, address to) public {\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _approve(to, id);\n    }\n\n    function testApproveUnauthorizedReverts(uint256 id) public {\n        (address owner, address to) = _owners();\n\n        token.mint(owner, id);\n        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n        _approve(to, id);\n    }\n\n    function testTransferFromNotExistentReverts(address from, address to, uint256 id) public {\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _transferFrom(from, to, id);\n    }\n\n    function testTransferFromWrongFromReverts(address to, uint256 id) public {\n        (address owner, address from) = _owners();\n\n        token.mint(owner, id);\n        vm.expectRevert(ERC721.TransferFromIncorrectOwner.selector);\n        _transferFrom(from, to, id);\n    }\n\n    function testTransferFromToZeroReverts(uint256 id) public {\n        token.mint(address(this), id);\n\n        vm.expectRevert(ERC721.TransferToZeroAddress.selector);\n        _transferFrom(address(this), address(0), id);\n    }\n\n    function testTransferFromNotOwner(uint256 id) public {\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n        _transferFrom(from, to, id);\n    }\n\n    function testSafeTransferFromToNonERC721RecipientReverts(uint256 id) public {\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), address(to), id);\n    }\n\n    function testSafeTransferFromToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        public\n    {\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }\n\n    function testSafeTransferFromToRevertingERC721RecipientReverts(uint256 id) public {\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id);\n    }\n\n    function testSafeTransferFromToRevertingERC721RecipientWithDataReverts(\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id, data);\n    }\n\n    function testSafeTransferFromToERC721RecipientWithWrongReturnDataReverts(uint256 id) public {\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id);\n    }\n\n    function testSafeTransferFromToERC721RecipientWithWrongReturnDataWithDataReverts(\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }\n\n    function testSafeMintToNonERC721RecipientReverts(uint256 id) public {\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        token.safeMint(to, id);\n    }\n\n    function testSafeMintToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        public\n    {\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        token.safeMint(to, id, data);\n    }\n\n    function testSafeMintToRevertingERC721RecipientReverts(uint256 id) public {\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        token.safeMint(to, id);\n    }\n\n    function testSafeMintToRevertingERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        public\n    {\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        token.safeMint(to, id, data);\n    }\n\n    function testSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        token.safeMint(to, id);\n    }\n\n    function testSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes memory data)\n        public\n    {\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        token.safeMint(to, id, data);\n    }\n\n    function testOwnerOfNonExistent(uint256 id) public {\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }\n}\n",
        "contractname": "ERC721.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 private constant _VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           ERC20                            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          EIP-2612                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport \"./utils/InvariantTest.sol\";\n\nimport {ERC20, MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is SoladyTest {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    struct _TestTemps {\n        address owner;\n        address to;\n        uint256 amount;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 privateKey;\n        uint256 nonce;\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        (t.owner, t.privateKey) = _randomSigner();\n        t.to = _randomNonZeroAddress();\n        t.amount = _random();\n        t.deadline = _random();\n    }\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function testMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), address(0xBEEF), 1e18);\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0xBEEF), address(0), 0.9e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0xBEEF), 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        _TestTemps memory t = _testTemps();\n        t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n\n        _checkAllowanceAndNonce(t);\n    }\n\n    function testMintOverMaxUintReverts() public {\n        token.mint(address(this), type(uint256).max);\n        vm.expectRevert(ERC20.TotalSupplyOverflow.selector);\n        token.mint(address(this), 1);\n    }\n\n    function testTransferInsufficientBalanceReverts() public {\n        token.mint(address(this), 0.9e18);\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromInsufficientAllowanceReverts() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromInsufficientBalanceReverts() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testMint(address to, uint256 amount) public {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), to, amount);\n        token.mint(to, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(to), amount);\n    }\n\n    function testBurn(address from, uint256 mintAmount, uint256 burnAmount) public {\n        burnAmount = _bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0), burnAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address to, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), to, amount);\n        assertTrue(token.transfer(to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == to) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address spender,\n        address from,\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = _bound(amount, 0, approval);\n\n        token.mint(from, amount);\n        assertEq(token.balanceOf(from), amount);\n\n        vm.prank(from);\n        token.approve(spender, approval);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, to, amount);\n        vm.prank(spender);\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (approval == type(uint256).max) {\n            assertEq(token.allowance(from, spender), approval);\n        } else {\n            assertEq(token.allowance(from, spender), approval - amount);\n        }\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testDirectTransfer(uint256) public {\n        _TestTemps memory t = _testTemps();\n        while (t.owner == t.to) (t.to,) = _randomSigner();\n\n        uint256 totalSupply = _random();\n        token.mint(t.owner, totalSupply);\n        assertEq(token.balanceOf(t.owner), totalSupply);\n        assertEq(token.balanceOf(t.to), 0);\n        if (t.amount > totalSupply) {\n            vm.expectRevert(ERC20.InsufficientBalance.selector);\n            token.directTransfer(t.owner, t.to, t.amount);\n        } else {\n            vm.expectEmit(true, true, true, true);\n            emit Transfer(t.owner, t.to, t.amount);\n            token.directTransfer(t.owner, t.to, t.amount);\n            assertEq(token.balanceOf(t.owner), totalSupply - t.amount);\n            assertEq(token.balanceOf(t.to), t.amount);\n        }\n    }\n\n    function testDirectSpendAllowance(uint256) public {\n        _TestTemps memory t = _testTemps();\n        uint256 allowance = _random();\n        vm.prank(t.owner);\n        token.approve(t.to, allowance);\n        assertEq(token.allowance(t.owner, t.to), allowance);\n        if (allowance == type(uint256).max) {\n            token.directSpendAllowance(t.owner, t.to, t.amount);\n            assertEq(token.allowance(t.owner, t.to), allowance);\n        } else if (t.amount > allowance) {\n            vm.expectRevert(ERC20.InsufficientAllowance.selector);\n            token.directSpendAllowance(t.owner, t.to, t.amount);\n        } else {\n            token.directSpendAllowance(t.owner, t.to, t.amount);\n            assertEq(token.allowance(t.owner, t.to), allowance - t.amount);\n        }\n    }\n\n    function testPermit(uint256) public {\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n\n        _checkAllowanceAndNonce(t);\n    }\n\n    function _checkAllowanceAndNonce(_TestTemps memory t) internal {\n        assertEq(token.allowance(t.owner, t.to), t.amount);\n        assertEq(token.nonces(t.owner), t.nonce + 1);\n    }\n\n    function testBurnInsufficientBalanceReverts(address to, uint256 mintAmount, uint256 burnAmount)\n        public\n    {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        burnAmount = _bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.burn(to, burnAmount);\n    }\n\n    function testTransferInsufficientBalanceReverts(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transfer(to, sendAmount);\n    }\n\n    function testTransferFromInsufficientAllowanceReverts(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (approval == type(uint256).max) approval--;\n        amount = _bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        vm.prank(from);\n        token.approve(address(this), approval);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, to, amount);\n    }\n\n    function testTransferFromInsufficientBalanceReverts(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        vm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testPermitBadNonceReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n        while (t.nonce == 0) t.nonce = _random();\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        _permit(t);\n    }\n\n    function testPermitBadDeadlineReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        if (t.deadline == type(uint256).max) t.deadline--;\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        t.deadline += 1;\n        _permit(t);\n    }\n\n    function testPermitPastDeadlineReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        t.deadline = _bound(t.deadline, 0, block.timestamp - 1);\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.PermitExpired.selector);\n        _permit(t);\n    }\n\n    function testPermitReplayReverts(uint256) public {\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        _permit(t);\n    }\n\n    function _signPermit(_TestTemps memory t) internal view {\n        bytes32 innerHash =\n            keccak256(abi.encode(PERMIT_TYPEHASH, t.owner, t.to, t.amount, t.nonce, t.deadline));\n        bytes32 domainSeparator = token.DOMAIN_SEPARATOR();\n        bytes32 outerHash = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, innerHash));\n        (t.v, t.r, t.s) = vm.sign(t.privateKey, outerHash);\n    }\n\n    function _expectPermitEmitApproval(_TestTemps memory t) internal {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(t.owner, t.to, t.amount);\n    }\n\n    function _permit(_TestTemps memory t) internal {\n        address token_ = address(token);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(sub(t, 0x20))\n            mstore(sub(t, 0x20), 0xd505accf)\n            pop(call(gas(), token_, 0, sub(t, 0x04), 0xe4, 0x00, 0x00))\n            mstore(sub(t, 0x20), m)\n        }\n    }\n}\n\ncontract ERC20Invariants is SoladyTest, InvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n        _addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n",
        "contractname": "ERC20.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Simple ERC4626 tokenized Vault implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC4626.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The default underlying decimals.\n    uint8 internal constant _DEFAULT_UNDERLYING_DECIMALS = 18;\n\n    /// @dev The default decimals offset.\n    uint8 internal constant _DEFAULT_DECIMALS_OFFSET = 0;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Cannot deposit more than the max limit.\n    error DepositMoreThanMax();\n\n    /// @dev Cannot mint more than the max limit.\n    error MintMoreThanMax();\n\n    /// @dev Cannot withdraw more than the max limit.\n    error WithdrawMoreThanMax();\n\n    /// @dev Cannot redeem more than the max limit.\n    error RedeemMoreThanMax();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted during a mint call or deposit call.\n    event Deposit(address indexed by, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @dev Emitted during a withdraw call or redeem call.\n    event Withdraw(\n        address indexed by,\n        address indexed to,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @dev `keccak256(bytes(\"Deposit(address,address,uint256,uint256)\"))`.\n    uint256 private constant _DEPOSIT_EVENT_SIGNATURE =\n        0xdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d7;\n\n    /// @dev `keccak256(bytes(\"Withdraw(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _WITHDRAW_EVENT_SIGNATURE =\n        0xfbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     ERC4626 CONSTANTS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev To be overridden to return the address of the underlying asset.\n    ///\n    /// - MUST be an ERC20 token contract.\n    /// - MUST NOT revert.\n    function asset() public view virtual returns (address);\n\n    /// @dev To be overridden to return the number of decimals of the underlying asset.\n    /// Default: 18.\n    ///\n    /// - MUST NOT revert.\n    function _underlyingDecimals() internal view virtual returns (uint8) {\n        return _DEFAULT_UNDERLYING_DECIMALS;\n    }\n\n    /// @dev Override to return a non-zero value to make the inflation attack even more unfeasible.\n    /// Only used when {_useVirtualShares} returns true.\n    /// Default: 0.\n    ///\n    /// - MUST NOT revert.\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return _DEFAULT_DECIMALS_OFFSET;\n    }\n\n    /// @dev Returns whether virtual shares will be used to mitigate the inflation attack.\n    /// See: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706\n    /// Override to return true or false.\n    /// Default: true.\n    ///\n    /// - MUST NOT revert.\n    function _useVirtualShares() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Returns the decimals places of the token.\n    ///\n    /// - MUST NOT revert.\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        if (!_useVirtualShares()) return _underlyingDecimals();\n        return _underlyingDecimals() + _decimalsOffset();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                ASSET DECIMALS GETTER HELPER                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper function to get the decimals of the underlying asset.\n    /// Useful for setting the return value of `_underlyingDecimals` during initialization.\n    /// If the retrieval succeeds, `success` will be true, and `result` will hold the result.\n    /// Otherwise, `success` will be false, and `result` will be zero.\n    ///\n    /// Example usage:\n    /// ```\n    /// (bool success, uint8 result) = _tryGetAssetDecimals(underlying);\n    /// _decimals = success ? result : _DEFAULT_UNDERLYING_DECIMALS;\n    /// ```\n    function _tryGetAssetDecimals(address underlying)\n        internal\n        view\n        returns (bool success, uint8 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `decimals()`.\n            mstore(0x00, 0x313ce567)\n            // Arguments are evaluated last to first.\n            success :=\n                and(\n                    // Returned value is less than 256, at left-padded to 32 bytes.\n                    and(lt(mload(0x00), 0x100), gt(returndatasize(), 0x1f)),\n                    // The staticcall succeeds.\n                    staticcall(gas(), underlying, 0x1c, 0x04, 0x00, 0x20)\n                )\n            result := mul(mload(0x00), success)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ACCOUNTING LOGIC                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the total amount of the underlying asset managed by the Vault.\n    ///\n    /// - SHOULD include any compounding that occurs from the yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() public view virtual returns (uint256 assets) {\n        assets = SafeTransferLib.balanceOf(asset(), address(this));\n    }\n\n    /// @dev Returns the amount of shares that the Vault will exchange for the amount of\n    /// assets provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDiv(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == 0) {\n            return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Returns the amount of assets that the Vault will exchange for the amount of\n    /// shares provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == 0\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDiv(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == 0) {\n            return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their deposit\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of Vault shares that\n    ///   will be minted in a deposit call in the same transaction, i.e. deposit should\n    ///   return the same or more shares as `previewDeposit` if call in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from `maxDeposit` and should\n    ///   always act as if the deposit will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewDeposit` SHOULD\n    /// be considered slippage in share price or some other type of condition, meaning\n    /// the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their mint\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of assets that\n    ///   will be deposited in a mint call in the same transaction, i.e. mint should\n    ///   return the same or fewer assets as `previewMint` if called in the same transaction.\n    /// - MUST NOT account for mint limits like those returned from `maxMint` and should\n    ///   always act as if the mint will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewMint` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == 0\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDivUp(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == 0) {\n            return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal\n    /// at the current block, given the current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that\n    ///   will be burned in a withdraw call in the same transaction, i.e. withdraw should\n    ///   return the same or fewer shares as `previewWithdraw` if call in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and should\n    ///   always act as if the withdrawal will be accepted, regardless of share balance, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewWithdraw` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDivUp(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == 0) {\n            return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their redemption\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of assets that\n    ///   will be withdrawn in a redeem call in the same transaction, i.e. redeem should\n    ///   return the same or more assets as `previewRedeem` if called in the same transaction.\n    /// - MUST NOT account for redemption limits like those returned from `maxRedeem` and should\n    ///   always act as if the redemption will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST NOT revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewRedeem` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }\n\n    /// @dev Private helper to return if either value is zero.\n    function _eitherIsZero(uint256 a, uint256 b) private pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(iszero(a), iszero(b))\n        }\n    }\n\n    /// @dev Private helper to return `x + 1` without the overflow check.\n    /// Used for computing the denominator input to `FixedPointMathLib.fullMulDiv(a, b, x + 1)`.\n    /// When `x == type(uint256).max`, we get `x + 1 == 0` (mod 2**256 - 1),\n    /// and `FixedPointMathLib.fullMulDiv` will revert as the denominator is zero.\n    function _inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              DEPOSIT / WITHDRAWAL LIMIT LOGIC              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the maximum amount of the underlying asset that can be deposited\n    /// into the Vault for `to`, via a deposit call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some deposit limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxDeposit(address to) public view virtual returns (uint256 maxAssets) {\n        to = to; // Silence unused variable warning.\n        maxAssets = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the Vault shares that can be minter for `to`,\n    /// via a mint call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some mint limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxMint(address to) public view virtual returns (uint256 maxShares) {\n        to = to; // Silence unused variable warning.\n        maxShares = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the underlying asset that can be withdrawn\n    /// from the `owner`'s balance in the Vault, via a withdraw call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }\n\n    /// @dev Returns the maximum amount of Vault shares that can be redeemed\n    /// from the `owner`'s balance in the Vault, via a redeem call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST return `balanceOf(owner)` otherwise.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                 DEPOSIT / WITHDRAWAL LOGIC                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `shares` Vault shares to `to` by depositing exactly `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of `assets` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function deposit(uint256 assets, address to) public virtual returns (uint256 shares) {\n        if (assets > maxDeposit(to)) _revert(0xb3c61a83); // `DepositMoreThanMax()`.\n        shares = previewDeposit(assets);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Mints exactly `shares` Vault shares to `to` by depositing `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the mint execution, and are accounted for during mint.\n    /// - MUST revert if all of `shares` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function mint(uint256 shares, address to) public virtual returns (uint256 assets) {\n        if (shares > maxMint(to)) _revert(0x6a695959); // `MintMoreThanMax()`.\n        assets = previewMint(shares);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of `assets` cannot be withdrawn, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a withdrawal\n    /// may be performed. Those methods should be performed separately.\n    function withdraw(uint256 assets, address to, address owner)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (assets > maxWithdraw(owner)) _revert(0x936941fc); // `WithdrawMoreThanMax()`.\n        shares = previewWithdraw(assets);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Burns exactly `shares` from `owner` and sends `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a redeem\n    /// may be performed. Those methods should be performed separately.\n    function redeem(uint256 shares, address to, address owner)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (shares > maxRedeem(owner)) _revert(0x4656425a); // `RedeemMoreThanMax()`.\n        assets = previewRedeem(shares);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Internal helper for reverting efficiently.\n    function _revert(uint256 s) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, s)\n            revert(0x1c, 0x04)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      INTERNAL HELPERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev For deposits and mints.\n    ///\n    /// Emits a {Deposit} event.\n    function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual {\n        SafeTransferLib.safeTransferFrom(asset(), by, address(this), assets);\n        _mint(to, shares);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log3(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, and(m, by), and(m, to))\n        }\n        _afterDeposit(assets, shares);\n    }\n\n    /// @dev For withdrawals and redemptions.\n    ///\n    /// Emits a {Withdraw} event.\n    function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        if (by != owner) _spendAllowance(owner, by, shares);\n        _beforeWithdraw(assets, shares);\n        _burn(owner, shares);\n        SafeTransferLib.safeTransfer(asset(), to, assets);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdraw} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log4(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, and(m, by), and(m, to), and(m, owner))\n        }\n    }\n\n    /// @dev Internal conversion function (from assets to shares) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToAssets}\n    /// when overriding it.\n    function _initialConvertToShares(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        shares = assets;\n    }\n\n    /// @dev Internal conversion function (from shares to assets) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToShares}\n    /// when overriding it.\n    function _initialConvertToAssets(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        assets = shares;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any withdrawal or redemption.\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    /// @dev Hook that is called after any deposit or mint.\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\n\nimport {ERC20, MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {ERC4626, MockERC4626} from \"./utils/mocks/MockERC4626.sol\";\nimport {SafeTransferLib} from \"../src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../src/utils/FixedPointMathLib.sol\";\n\ncontract ERC4626Test is SoladyTest {\n    MockERC20 underlying;\n    MockERC4626 vault;\n\n    event Deposit(address indexed by, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed by,\n        address indexed to,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function setUp() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n    }\n\n    function _replaceWithVirtualSharesVault(uint8 decimalsOffset) internal {\n        vault = new MockERC4626(address(underlying), \"VSV\", \"VSVTKN\", true, decimalsOffset);\n    }\n\n    function _replaceWithVirtualSharesVault() internal {\n        _replaceWithVirtualSharesVault(0);\n    }\n\n    function testDifferentialFullMulDiv(uint256 x, uint256 y, uint256 d) public {\n        d = type(uint256).max - d % 4;\n        (bool success0,) = address(this).call(\n            abi.encodeWithSignature(\"fullMulDivChecked(uint256,uint256,uint256)\", x, y, d)\n        );\n        (bool success1,) = address(this).call(\n            abi.encodeWithSignature(\"fullMulDivUnchecked(uint256,uint256,uint256)\", x, y, d)\n        );\n        if (d == type(uint256).max) {\n            assertFalse(success0);\n            assertFalse(success1);\n        }\n        assertEq(success0, success1);\n    }\n\n    function fullMulDivChecked(uint256 x, uint256 y, uint256 d) public pure {\n        FixedPointMathLib.fullMulDiv(x, y, d + 1);\n    }\n\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d) public pure {\n        unchecked {\n            FixedPointMathLib.fullMulDiv(x, y, d + 1);\n        }\n    }\n\n    function testMetadata() public {\n        assertEq(vault.name(), \"Mock Token Vault\");\n        assertEq(vault.symbol(), \"vwTKN\");\n        assertEq(vault.decimals(), 18);\n    }\n\n    function testUseVirtualShares() public {\n        assertEq(vault.useVirtualShares(), false);\n        _replaceWithVirtualSharesVault();\n        assertEq(vault.useVirtualShares(), true);\n        assertEq(vault.decimals(), 18);\n        _replaceWithVirtualSharesVault(1);\n        assertEq(vault.decimals(), 19);\n    }\n\n    function testTryGetAssetDecimals() public {\n        unchecked {\n            for (uint256 i = 0; i < 5; ++i) {\n                _testTryGetAssetDecimals(uint8(i));\n            }\n            for (uint256 i = 125; i < 130; ++i) {\n                _testTryGetAssetDecimals(uint8(i));\n            }\n            for (uint256 i = 250; i < 256; ++i) {\n                _testTryGetAssetDecimals(uint8(i));\n            }\n        }\n        vault = new MockERC4626(address(this), \"\", \"\", false, 0);\n        assertEq(vault.decimals(), 18);\n    }\n\n    function _testTryGetAssetDecimals(uint8 i) internal {\n        underlying = new MockERC20(\"\", \"\", i);\n        assertEq(underlying.decimals(), i);\n        vault = new MockERC4626(address(underlying), \"\", \"\", false, 0);\n        assertEq(vault.decimals(), i);\n    }\n\n    function testSingleDepositWithdraw(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        unchecked {\n            assertEq(aliceUnderlyingAmount, aliceShareAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceShareAmount);\n            assertEq(vault.convertToAssets(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testSingleMintRedeem(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        unchecked {\n            assertEq(aliceShareAmount, aliceUnderlyingAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n            assertEq(vault.convertToAssets(aliceUnderlyingAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testMultipleMintDepositRedeemWithdraw() public {\n        _testMultipleMintDepositRedeemWithdraw(0);\n    }\n\n    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }\n\n    struct _TestTemps {\n        uint256 slippage;\n        address alice;\n        address bob;\n        uint256 mutationUnderlyingAmount;\n        uint256 aliceUnderlyingAmount;\n        uint256 aliceShareAmount;\n        uint256 bobShareAmount;\n        uint256 bobUnderlyingAmount;\n        uint256 preMutationShareBal;\n        uint256 preMutationBal;\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw(uint256 slippage) public {\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |::::::::::::::::::::::::::::::::::::::::::::::::::::::::|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        _TestTemps memory t;\n        t.slippage = slippage;\n        t.alice = address(0x9988776655443322110000112233445566778899);\n        t.bob = address(0x1122334455667788990000998877665544332211);\n\n        t.mutationUnderlyingAmount = 3000;\n\n        underlying.mint(t.alice, 4000);\n\n        vm.prank(t.alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(t.alice, address(vault)), 4000);\n\n        underlying.mint(t.bob, 7001);\n\n        vm.prank(t.bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(t.bob, address(vault)), 7001);\n\n        _testMultipleMintDepositRedeemWithdraw1(t);\n        _testMultipleMintDepositRedeemWithdraw2(t);\n        _testMultipleMintDepositRedeemWithdraw3(t);\n        _testMultipleMintDepositRedeemWithdraw4(t);\n        _testMultipleMintDepositRedeemWithdraw5(t);\n        _testMultipleMintDepositRedeemWithdraw6(t);\n        _testMultipleMintDepositRedeemWithdraw7(t);\n        _testMultipleMintDepositRedeemWithdraw8(t);\n        _testMultipleMintDepositRedeemWithdraw9(t);\n        _testMultipleMintDepositRedeemWithdraw10(t);\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw1(_TestTemps memory t) internal {\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        vm.prank(t.alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(t.alice, t.alice, 2000, 2000);\n        t.aliceUnderlyingAmount = vault.mint(2000, t.alice);\n\n        t.aliceShareAmount = vault.previewDeposit(t.aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(t.aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n        assertEq(vault.convertToAssets(t.aliceShareAmount), t.aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(t.aliceUnderlyingAmount), t.aliceShareAmount);\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(t.aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), t.aliceShareAmount);\n        assertEq(vault.totalAssets(), t.aliceUnderlyingAmount);\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw2(_TestTemps memory t) internal {\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Deposit(t.bob, t.bob, 4000, 4000);\n            t.bobShareAmount = vault.deposit(4000, t.bob);\n            t.bobUnderlyingAmount = vault.previewWithdraw(t.bobShareAmount);\n            assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n            // Expect to have received the requested underlying amount.\n            assertEq(t.bobUnderlyingAmount, 4000);\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(vault.convertToAssets(t.bobShareAmount), t.bobUnderlyingAmount);\n            assertEq(vault.convertToShares(t.bobUnderlyingAmount), t.bobShareAmount);\n\n            // Expect a 1:1 ratio before mutation.\n            assertEq(t.bobShareAmount, t.bobUnderlyingAmount);\n\n            // Sanity check.\n            t.preMutationShareBal = t.aliceShareAmount + t.bobShareAmount;\n            t.preMutationBal = t.aliceUnderlyingAmount + t.bobUnderlyingAmount;\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal);\n            assertEq(vault.totalSupply(), 6000);\n            assertEq(vault.totalAssets(), 6000);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw3(_TestTemps memory t) internal {\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal + t.mutationUnderlyingAmount);\n            assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n            assertEq(\n                vault.convertToAssets(t.aliceShareAmount),\n                t.aliceUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 1 - t.slippage\n            );\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(\n                vault.convertToAssets(t.bobShareAmount),\n                t.bobUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 2 - t.slippage\n            );\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw4(_TestTemps memory t) internal {\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        vm.prank(t.alice);\n        vault.deposit(2000, t.alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(t.alice), 3333);\n        assertEq(vault.convertToAssets(3333), 4999);\n        assertEq(vault.balanceOf(t.bob), 4000);\n        assertEq(vault.convertToAssets(4000), 6000);\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw5(_TestTemps memory t) internal {\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        unchecked {\n            vm.prank(t.bob);\n            vault.mint(2000, t.bob);\n\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.balanceOf(t.alice), 3333);\n            assertEq(vault.convertToAssets(3333), 5000 - t.slippage);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 9000);\n\n            // Sanity checks:\n            // Alice and t.bob should have spent all their tokens now\n            assertEq(underlying.balanceOf(t.alice), 0);\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 0);\n            // Assets in vault: 4k (t.alice) + 7k (t.bob) + 3k (yield) + 1 (round up)\n            assertEq(vault.totalAssets(), 14001 - t.slippage);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw6(_TestTemps memory t) internal {\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.alice)), 6071 - t.slippage);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.bob)), 10929 - t.slippage);\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.totalAssets(), 17001 - t.slippage);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw7(_TestTemps memory t) internal {\n        // 7. Alice redeem 1333 shares (2428 assets)\n        unchecked {\n            vm.prank(t.alice);\n            vault.redeem(1333, t.alice, t.alice);\n\n            assertEq(underlying.balanceOf(t.alice), 2428 - t.slippage);\n            assertEq(vault.totalSupply(), 8000);\n            assertEq(vault.totalAssets(), 14573);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 10929);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw8(_TestTemps memory t) internal {\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vault.withdraw(2929, t.bob, t.bob);\n\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 2929);\n            assertEq(vault.totalSupply(), 6392);\n            assertEq(vault.totalAssets(), 11644);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8000);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw9(_TestTemps memory t) internal {\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        unchecked {\n            vm.prank(t.alice);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.alice, t.alice, t.alice, 3643, 2000);\n            vault.withdraw(3643, t.alice, t.alice);\n            assertEq(underlying.balanceOf(t.alice), 6071 - t.slippage);\n            assertEq(vault.totalSupply(), 4392);\n            assertEq(vault.totalAssets(), 8001);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8001 - t.slippage);\n        }\n    }\n\n    function _testMultipleMintDepositRedeemWithdraw10(_TestTemps memory t) internal {\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.bob, t.bob, t.bob, 8001 - t.slippage, 4392);\n            vault.redeem(4392, t.bob, t.bob);\n            assertEq(underlying.balanceOf(t.bob), 10930);\n            assertEq(vault.totalSupply(), 0);\n            assertEq(vault.totalAssets() - t.slippage, 0);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 0);\n            assertEq(vault.convertToAssets(0), 0);\n\n            // Sanity check\n            assertEq(underlying.balanceOf(address(vault)) - t.slippage, 0);\n        }\n    }\n\n    function testDepositWithNotEnoughApprovalReverts() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n        assertEq(underlying.allowance(address(this), address(vault)), 0.5e18);\n\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.deposit(1e18, address(this));\n    }\n\n    function testWithdrawWithNotEnoughUnderlyingAmountReverts() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vm.expectRevert(ERC4626.WithdrawMoreThanMax.selector);\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testRedeemWithNotEnoughShareAmountReverts() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vm.expectRevert(ERC4626.RedeemMoreThanMax.selector);\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testWithdrawWithNoUnderlyingAmountReverts() public {\n        vm.expectRevert(ERC4626.WithdrawMoreThanMax.selector);\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testRedeemWithNoShareAmountReverts() public {\n        vm.expectRevert(ERC4626.RedeemMoreThanMax.selector);\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testDepositWithNoApprovalReverts() public {\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.deposit(1e18, address(this));\n    }\n\n    function testMintWithNoApprovalReverts() public {\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.mint(1e18, address(this));\n    }\n\n    function testMintZero() public {\n        vault.mint(0, address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(0), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testWithdrawZero() public {\n        vault.withdraw(0, address(this), address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(0), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testVaultInteractionsForSomeoneElse() public {\n        // init 2 users with a 1e18 balance\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n        underlying.mint(alice, 1e18);\n        underlying.mint(bob, 1e18);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), 1e18);\n\n        vm.prank(bob);\n        underlying.approve(address(vault), 1e18);\n\n        // alice deposits 1e18 for bob\n        vm.prank(alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(alice, bob, 1e18, 1e18);\n        vault.deposit(1e18, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(alice), 0);\n\n        // bob mint 1e18 for alice\n        vm.prank(bob);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(bob, alice, 1e18, 1e18);\n        vault.mint(1e18, alice);\n        assertEq(vault.balanceOf(alice), 1e18);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 0);\n\n        // alice redeem 1e18 for bob\n        vm.prank(alice);\n        vm.expectEmit(true, true, true, true);\n        emit Withdraw(alice, bob, alice, 1e18, 1e18);\n        vault.redeem(1e18, bob, alice);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 1e18);\n\n        // bob withdraw 1e18 for alice\n        vm.prank(bob);\n        vm.expectEmit(true, true, true, true);\n        emit Withdraw(bob, alice, bob, 1e18, 1e18);\n        vault.withdraw(1e18, alice, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(underlying.balanceOf(alice), 1e18);\n    }\n}\n",
        "contractname": "ERC4626.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         MODIFIERS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport \"./utils/mocks/MockOwnable.sol\";\n\ncontract OwnableTest is SoladyTest {\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    MockOwnable mockOwnable;\n\n    function setUp() public {\n        mockOwnable = new MockOwnable();\n    }\n\n    function testBytecodeSize() public {\n        MockOwnableBytecodeSizer mock = new MockOwnableBytecodeSizer();\n        assertTrue(address(mock).code.length > 0);\n        assertEq(mock.owner(), address(this));\n    }\n\n    function testInitializeOwnerDirect() public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(0), address(1));\n        mockOwnable.initializeOwnerDirect(address(1));\n    }\n\n    function testSetOwnerDirect(address newOwner) public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), newOwner);\n        mockOwnable.setOwnerDirect(newOwner);\n        assertEq(mockOwnable.owner(), newOwner);\n    }\n\n    function testSetOwnerDirect() public {\n        testSetOwnerDirect(address(1));\n    }\n\n    function testRenounceOwnership() public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), address(0));\n        mockOwnable.renounceOwnership();\n        assertEq(mockOwnable.owner(), address(0));\n    }\n\n    function testTransferOwnership(\n        address newOwner,\n        bool setNewOwnerToZeroAddress,\n        bool callerIsOwner\n    ) public {\n        assertEq(mockOwnable.owner(), address(this));\n\n        vm.assume(newOwner != address(this));\n\n        if (newOwner == address(0) || setNewOwnerToZeroAddress) {\n            newOwner = address(0);\n            vm.expectRevert(Ownable.NewOwnerIsZeroAddress.selector);\n        } else if (callerIsOwner) {\n            vm.expectEmit(true, true, true, true);\n            emit OwnershipTransferred(address(this), newOwner);\n        } else {\n            vm.prank(newOwner);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n\n        mockOwnable.transferOwnership(newOwner);\n\n        if (newOwner != address(0) && callerIsOwner) {\n            assertEq(mockOwnable.owner(), newOwner);\n        }\n    }\n\n    function testTransferOwnership() public {\n        testTransferOwnership(address(1), false, true);\n    }\n\n    function testOnlyOwnerModifier(address nonOwner, bool callerIsOwner) public {\n        vm.assume(nonOwner != address(this));\n\n        if (!callerIsOwner) {\n            vm.prank(nonOwner);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        mockOwnable.updateFlagWithOnlyOwner();\n    }\n\n    function testHandoverOwnership(address pendingOwner) public {\n        vm.prank(pendingOwner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverRequested(pendingOwner);\n        mockOwnable.requestOwnershipHandover();\n        assertTrue(mockOwnable.ownershipHandoverExpiresAt(pendingOwner) > block.timestamp);\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), pendingOwner);\n\n        mockOwnable.completeOwnershipHandover(pendingOwner);\n\n        assertEq(mockOwnable.owner(), pendingOwner);\n    }\n\n    function testHandoverOwnership() public {\n        testHandoverOwnership(address(1));\n    }\n\n    function testHandoverOwnershipRevertsIfCompleteIsNotOwner() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnable.requestOwnershipHandover();\n\n        vm.prank(pendingOwner);\n        vm.expectRevert(Ownable.Unauthorized.selector);\n        mockOwnable.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipWithCancellation() public {\n        address pendingOwner = address(1);\n\n        vm.prank(pendingOwner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverRequested(pendingOwner);\n        mockOwnable.requestOwnershipHandover();\n        assertTrue(mockOwnable.ownershipHandoverExpiresAt(pendingOwner) > block.timestamp);\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverCanceled(pendingOwner);\n        vm.prank(pendingOwner);\n        mockOwnable.cancelOwnershipHandover();\n        assertEq(mockOwnable.ownershipHandoverExpiresAt(pendingOwner), 0);\n        vm.expectRevert(Ownable.NoHandoverRequest.selector);\n\n        mockOwnable.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipBeforeExpiration() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnable.requestOwnershipHandover();\n\n        vm.warp(block.timestamp + mockOwnable.ownershipHandoverValidFor());\n\n        mockOwnable.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipAfterExpiration() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnable.requestOwnershipHandover();\n\n        vm.warp(block.timestamp + mockOwnable.ownershipHandoverValidFor() + 1);\n\n        vm.expectRevert(Ownable.NoHandoverRequest.selector);\n\n        mockOwnable.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testOwnershipHandoverValidForDefaultValue() public {\n        assertEq(mockOwnable.ownershipHandoverValidFor(), 48 * 3600);\n    }\n}\n",
        "contractname": "Ownable.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/// @notice Simple single owner and multiroles authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\n/// may be unique to this codebase.\nabstract contract OwnableRoles is Ownable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The `user`'s roles is updated to `roles`.\n    /// Each bit of `roles` represents whether the role is set.\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    /// @dev `keccak256(bytes(\"RolesUpdated(address,uint256)\"))`.\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The role slot of `user` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\n    ///     let roleSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// This automatically ignores the upper bits of the `user` in case\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\n    ///\n    /// Note: This is equivalent to `uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))`.\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Overwrite the roles directly without authorization guard.\n    function _setRoles(address user, uint256 roles) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Store the new value.\n            sstore(keccak256(0x0c, 0x20), roles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\n        }\n    }\n\n    /// @dev Updates the roles directly without authorization guard.\n    /// If `on` is true, each set bit of `roles` will be turned on,\n    /// otherwise, each set bit of `roles` will be turned off.\n    function _updateRoles(address user, uint256 roles, bool on) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            let roleSlot := keccak256(0x0c, 0x20)\n            // Load the current value.\n            let current := sload(roleSlot)\n            // Compute the updated roles if `on` is true.\n            let updated := or(current, roles)\n            // Compute the updated roles if `on` is false.\n            // Use `and` to compute the intersection of `current` and `roles`,\n            // `xor` it with `current` to flip the bits in the intersection.\n            if iszero(on) { updated := xor(current, and(current, roles)) }\n            // Then, store the new value.\n            sstore(roleSlot, updated)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\n        }\n    }\n\n    /// @dev Grants the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn on.\n    function _grantRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, true);\n    }\n\n    /// @dev Removes the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn off.\n    function _removeRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, false);\n    }\n\n    /// @dev Throws if the sender does not have any of the `roles`.\n    function _checkRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner,\n    /// and does not have any of the `roles`.\n    /// Checks for ownership first, then lazily checks for roles.\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner.\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                // Compute the role slot.\n                mstore(0x0c, _ROLE_SLOT_SEED)\n                mstore(0x00, caller())\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Throws if the sender does not have any of the `roles`,\n    /// and is not the owner.\n    /// Checks for roles first, then lazily checks for ownership.\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\n                // We don't need to mask the values of `ordinals`, as Solidity\n                // cleans dirty upper bits when storing variables into memory.\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\n            }\n        }\n    }\n\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the pointer to the free memory.\n            ordinals := mload(0x40)\n            let ptr := add(ordinals, 0x20)\n            let o := 0\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            for { let t := roles } 1 {} {\n                mstore(ptr, o)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(t, 1)))\n                o := add(o, 1)\n                t := shr(o, roles)\n                if iszero(t) { break }\n            }\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n            // Allocate the memory.\n            mstore(0x40, ptr)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Allows the owner to grant `user` `roles`.\n    /// If the `user` already has a role, then it will be an no-op for the role.\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _grantRoles(user, roles);\n    }\n\n    /// @dev Allows the owner to remove `user` `roles`.\n    /// If the `user` does not have a role, then it will be an no-op for the role.\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _removeRoles(user, roles);\n    }\n\n    /// @dev Allow the caller to remove their own roles.\n    /// If the caller does not have a role, then it will be an no-op for the role.\n    function renounceRoles(uint256 roles) public payable virtual {\n        _removeRoles(msg.sender, roles);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the roles of `user`.\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Load the stored value.\n            roles := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns whether `user` has any of `roles`.\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles != 0;\n    }\n\n    /// @dev Returns whether `user` has all of `roles`.\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles == roles;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         MODIFIERS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Marks a function as only callable by an account with `roles`.\n    modifier onlyRoles(uint256 roles) virtual {\n        _checkRoles(roles);\n        _;\n    }\n\n    /// @dev Marks a function as only callable by the owner or by an account\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\n        _checkOwnerOrRoles(roles);\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\n        _checkRolesOrOwner(roles);\n        _;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ROLE CONSTANTS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // IYKYK\n\n    uint256 internal constant _ROLE_0 = 1 << 0;\n    uint256 internal constant _ROLE_1 = 1 << 1;\n    uint256 internal constant _ROLE_2 = 1 << 2;\n    uint256 internal constant _ROLE_3 = 1 << 3;\n    uint256 internal constant _ROLE_4 = 1 << 4;\n    uint256 internal constant _ROLE_5 = 1 << 5;\n    uint256 internal constant _ROLE_6 = 1 << 6;\n    uint256 internal constant _ROLE_7 = 1 << 7;\n    uint256 internal constant _ROLE_8 = 1 << 8;\n    uint256 internal constant _ROLE_9 = 1 << 9;\n    uint256 internal constant _ROLE_10 = 1 << 10;\n    uint256 internal constant _ROLE_11 = 1 << 11;\n    uint256 internal constant _ROLE_12 = 1 << 12;\n    uint256 internal constant _ROLE_13 = 1 << 13;\n    uint256 internal constant _ROLE_14 = 1 << 14;\n    uint256 internal constant _ROLE_15 = 1 << 15;\n    uint256 internal constant _ROLE_16 = 1 << 16;\n    uint256 internal constant _ROLE_17 = 1 << 17;\n    uint256 internal constant _ROLE_18 = 1 << 18;\n    uint256 internal constant _ROLE_19 = 1 << 19;\n    uint256 internal constant _ROLE_20 = 1 << 20;\n    uint256 internal constant _ROLE_21 = 1 << 21;\n    uint256 internal constant _ROLE_22 = 1 << 22;\n    uint256 internal constant _ROLE_23 = 1 << 23;\n    uint256 internal constant _ROLE_24 = 1 << 24;\n    uint256 internal constant _ROLE_25 = 1 << 25;\n    uint256 internal constant _ROLE_26 = 1 << 26;\n    uint256 internal constant _ROLE_27 = 1 << 27;\n    uint256 internal constant _ROLE_28 = 1 << 28;\n    uint256 internal constant _ROLE_29 = 1 << 29;\n    uint256 internal constant _ROLE_30 = 1 << 30;\n    uint256 internal constant _ROLE_31 = 1 << 31;\n    uint256 internal constant _ROLE_32 = 1 << 32;\n    uint256 internal constant _ROLE_33 = 1 << 33;\n    uint256 internal constant _ROLE_34 = 1 << 34;\n    uint256 internal constant _ROLE_35 = 1 << 35;\n    uint256 internal constant _ROLE_36 = 1 << 36;\n    uint256 internal constant _ROLE_37 = 1 << 37;\n    uint256 internal constant _ROLE_38 = 1 << 38;\n    uint256 internal constant _ROLE_39 = 1 << 39;\n    uint256 internal constant _ROLE_40 = 1 << 40;\n    uint256 internal constant _ROLE_41 = 1 << 41;\n    uint256 internal constant _ROLE_42 = 1 << 42;\n    uint256 internal constant _ROLE_43 = 1 << 43;\n    uint256 internal constant _ROLE_44 = 1 << 44;\n    uint256 internal constant _ROLE_45 = 1 << 45;\n    uint256 internal constant _ROLE_46 = 1 << 46;\n    uint256 internal constant _ROLE_47 = 1 << 47;\n    uint256 internal constant _ROLE_48 = 1 << 48;\n    uint256 internal constant _ROLE_49 = 1 << 49;\n    uint256 internal constant _ROLE_50 = 1 << 50;\n    uint256 internal constant _ROLE_51 = 1 << 51;\n    uint256 internal constant _ROLE_52 = 1 << 52;\n    uint256 internal constant _ROLE_53 = 1 << 53;\n    uint256 internal constant _ROLE_54 = 1 << 54;\n    uint256 internal constant _ROLE_55 = 1 << 55;\n    uint256 internal constant _ROLE_56 = 1 << 56;\n    uint256 internal constant _ROLE_57 = 1 << 57;\n    uint256 internal constant _ROLE_58 = 1 << 58;\n    uint256 internal constant _ROLE_59 = 1 << 59;\n    uint256 internal constant _ROLE_60 = 1 << 60;\n    uint256 internal constant _ROLE_61 = 1 << 61;\n    uint256 internal constant _ROLE_62 = 1 << 62;\n    uint256 internal constant _ROLE_63 = 1 << 63;\n    uint256 internal constant _ROLE_64 = 1 << 64;\n    uint256 internal constant _ROLE_65 = 1 << 65;\n    uint256 internal constant _ROLE_66 = 1 << 66;\n    uint256 internal constant _ROLE_67 = 1 << 67;\n    uint256 internal constant _ROLE_68 = 1 << 68;\n    uint256 internal constant _ROLE_69 = 1 << 69;\n    uint256 internal constant _ROLE_70 = 1 << 70;\n    uint256 internal constant _ROLE_71 = 1 << 71;\n    uint256 internal constant _ROLE_72 = 1 << 72;\n    uint256 internal constant _ROLE_73 = 1 << 73;\n    uint256 internal constant _ROLE_74 = 1 << 74;\n    uint256 internal constant _ROLE_75 = 1 << 75;\n    uint256 internal constant _ROLE_76 = 1 << 76;\n    uint256 internal constant _ROLE_77 = 1 << 77;\n    uint256 internal constant _ROLE_78 = 1 << 78;\n    uint256 internal constant _ROLE_79 = 1 << 79;\n    uint256 internal constant _ROLE_80 = 1 << 80;\n    uint256 internal constant _ROLE_81 = 1 << 81;\n    uint256 internal constant _ROLE_82 = 1 << 82;\n    uint256 internal constant _ROLE_83 = 1 << 83;\n    uint256 internal constant _ROLE_84 = 1 << 84;\n    uint256 internal constant _ROLE_85 = 1 << 85;\n    uint256 internal constant _ROLE_86 = 1 << 86;\n    uint256 internal constant _ROLE_87 = 1 << 87;\n    uint256 internal constant _ROLE_88 = 1 << 88;\n    uint256 internal constant _ROLE_89 = 1 << 89;\n    uint256 internal constant _ROLE_90 = 1 << 90;\n    uint256 internal constant _ROLE_91 = 1 << 91;\n    uint256 internal constant _ROLE_92 = 1 << 92;\n    uint256 internal constant _ROLE_93 = 1 << 93;\n    uint256 internal constant _ROLE_94 = 1 << 94;\n    uint256 internal constant _ROLE_95 = 1 << 95;\n    uint256 internal constant _ROLE_96 = 1 << 96;\n    uint256 internal constant _ROLE_97 = 1 << 97;\n    uint256 internal constant _ROLE_98 = 1 << 98;\n    uint256 internal constant _ROLE_99 = 1 << 99;\n    uint256 internal constant _ROLE_100 = 1 << 100;\n    uint256 internal constant _ROLE_101 = 1 << 101;\n    uint256 internal constant _ROLE_102 = 1 << 102;\n    uint256 internal constant _ROLE_103 = 1 << 103;\n    uint256 internal constant _ROLE_104 = 1 << 104;\n    uint256 internal constant _ROLE_105 = 1 << 105;\n    uint256 internal constant _ROLE_106 = 1 << 106;\n    uint256 internal constant _ROLE_107 = 1 << 107;\n    uint256 internal constant _ROLE_108 = 1 << 108;\n    uint256 internal constant _ROLE_109 = 1 << 109;\n    uint256 internal constant _ROLE_110 = 1 << 110;\n    uint256 internal constant _ROLE_111 = 1 << 111;\n    uint256 internal constant _ROLE_112 = 1 << 112;\n    uint256 internal constant _ROLE_113 = 1 << 113;\n    uint256 internal constant _ROLE_114 = 1 << 114;\n    uint256 internal constant _ROLE_115 = 1 << 115;\n    uint256 internal constant _ROLE_116 = 1 << 116;\n    uint256 internal constant _ROLE_117 = 1 << 117;\n    uint256 internal constant _ROLE_118 = 1 << 118;\n    uint256 internal constant _ROLE_119 = 1 << 119;\n    uint256 internal constant _ROLE_120 = 1 << 120;\n    uint256 internal constant _ROLE_121 = 1 << 121;\n    uint256 internal constant _ROLE_122 = 1 << 122;\n    uint256 internal constant _ROLE_123 = 1 << 123;\n    uint256 internal constant _ROLE_124 = 1 << 124;\n    uint256 internal constant _ROLE_125 = 1 << 125;\n    uint256 internal constant _ROLE_126 = 1 << 126;\n    uint256 internal constant _ROLE_127 = 1 << 127;\n    uint256 internal constant _ROLE_128 = 1 << 128;\n    uint256 internal constant _ROLE_129 = 1 << 129;\n    uint256 internal constant _ROLE_130 = 1 << 130;\n    uint256 internal constant _ROLE_131 = 1 << 131;\n    uint256 internal constant _ROLE_132 = 1 << 132;\n    uint256 internal constant _ROLE_133 = 1 << 133;\n    uint256 internal constant _ROLE_134 = 1 << 134;\n    uint256 internal constant _ROLE_135 = 1 << 135;\n    uint256 internal constant _ROLE_136 = 1 << 136;\n    uint256 internal constant _ROLE_137 = 1 << 137;\n    uint256 internal constant _ROLE_138 = 1 << 138;\n    uint256 internal constant _ROLE_139 = 1 << 139;\n    uint256 internal constant _ROLE_140 = 1 << 140;\n    uint256 internal constant _ROLE_141 = 1 << 141;\n    uint256 internal constant _ROLE_142 = 1 << 142;\n    uint256 internal constant _ROLE_143 = 1 << 143;\n    uint256 internal constant _ROLE_144 = 1 << 144;\n    uint256 internal constant _ROLE_145 = 1 << 145;\n    uint256 internal constant _ROLE_146 = 1 << 146;\n    uint256 internal constant _ROLE_147 = 1 << 147;\n    uint256 internal constant _ROLE_148 = 1 << 148;\n    uint256 internal constant _ROLE_149 = 1 << 149;\n    uint256 internal constant _ROLE_150 = 1 << 150;\n    uint256 internal constant _ROLE_151 = 1 << 151;\n    uint256 internal constant _ROLE_152 = 1 << 152;\n    uint256 internal constant _ROLE_153 = 1 << 153;\n    uint256 internal constant _ROLE_154 = 1 << 154;\n    uint256 internal constant _ROLE_155 = 1 << 155;\n    uint256 internal constant _ROLE_156 = 1 << 156;\n    uint256 internal constant _ROLE_157 = 1 << 157;\n    uint256 internal constant _ROLE_158 = 1 << 158;\n    uint256 internal constant _ROLE_159 = 1 << 159;\n    uint256 internal constant _ROLE_160 = 1 << 160;\n    uint256 internal constant _ROLE_161 = 1 << 161;\n    uint256 internal constant _ROLE_162 = 1 << 162;\n    uint256 internal constant _ROLE_163 = 1 << 163;\n    uint256 internal constant _ROLE_164 = 1 << 164;\n    uint256 internal constant _ROLE_165 = 1 << 165;\n    uint256 internal constant _ROLE_166 = 1 << 166;\n    uint256 internal constant _ROLE_167 = 1 << 167;\n    uint256 internal constant _ROLE_168 = 1 << 168;\n    uint256 internal constant _ROLE_169 = 1 << 169;\n    uint256 internal constant _ROLE_170 = 1 << 170;\n    uint256 internal constant _ROLE_171 = 1 << 171;\n    uint256 internal constant _ROLE_172 = 1 << 172;\n    uint256 internal constant _ROLE_173 = 1 << 173;\n    uint256 internal constant _ROLE_174 = 1 << 174;\n    uint256 internal constant _ROLE_175 = 1 << 175;\n    uint256 internal constant _ROLE_176 = 1 << 176;\n    uint256 internal constant _ROLE_177 = 1 << 177;\n    uint256 internal constant _ROLE_178 = 1 << 178;\n    uint256 internal constant _ROLE_179 = 1 << 179;\n    uint256 internal constant _ROLE_180 = 1 << 180;\n    uint256 internal constant _ROLE_181 = 1 << 181;\n    uint256 internal constant _ROLE_182 = 1 << 182;\n    uint256 internal constant _ROLE_183 = 1 << 183;\n    uint256 internal constant _ROLE_184 = 1 << 184;\n    uint256 internal constant _ROLE_185 = 1 << 185;\n    uint256 internal constant _ROLE_186 = 1 << 186;\n    uint256 internal constant _ROLE_187 = 1 << 187;\n    uint256 internal constant _ROLE_188 = 1 << 188;\n    uint256 internal constant _ROLE_189 = 1 << 189;\n    uint256 internal constant _ROLE_190 = 1 << 190;\n    uint256 internal constant _ROLE_191 = 1 << 191;\n    uint256 internal constant _ROLE_192 = 1 << 192;\n    uint256 internal constant _ROLE_193 = 1 << 193;\n    uint256 internal constant _ROLE_194 = 1 << 194;\n    uint256 internal constant _ROLE_195 = 1 << 195;\n    uint256 internal constant _ROLE_196 = 1 << 196;\n    uint256 internal constant _ROLE_197 = 1 << 197;\n    uint256 internal constant _ROLE_198 = 1 << 198;\n    uint256 internal constant _ROLE_199 = 1 << 199;\n    uint256 internal constant _ROLE_200 = 1 << 200;\n    uint256 internal constant _ROLE_201 = 1 << 201;\n    uint256 internal constant _ROLE_202 = 1 << 202;\n    uint256 internal constant _ROLE_203 = 1 << 203;\n    uint256 internal constant _ROLE_204 = 1 << 204;\n    uint256 internal constant _ROLE_205 = 1 << 205;\n    uint256 internal constant _ROLE_206 = 1 << 206;\n    uint256 internal constant _ROLE_207 = 1 << 207;\n    uint256 internal constant _ROLE_208 = 1 << 208;\n    uint256 internal constant _ROLE_209 = 1 << 209;\n    uint256 internal constant _ROLE_210 = 1 << 210;\n    uint256 internal constant _ROLE_211 = 1 << 211;\n    uint256 internal constant _ROLE_212 = 1 << 212;\n    uint256 internal constant _ROLE_213 = 1 << 213;\n    uint256 internal constant _ROLE_214 = 1 << 214;\n    uint256 internal constant _ROLE_215 = 1 << 215;\n    uint256 internal constant _ROLE_216 = 1 << 216;\n    uint256 internal constant _ROLE_217 = 1 << 217;\n    uint256 internal constant _ROLE_218 = 1 << 218;\n    uint256 internal constant _ROLE_219 = 1 << 219;\n    uint256 internal constant _ROLE_220 = 1 << 220;\n    uint256 internal constant _ROLE_221 = 1 << 221;\n    uint256 internal constant _ROLE_222 = 1 << 222;\n    uint256 internal constant _ROLE_223 = 1 << 223;\n    uint256 internal constant _ROLE_224 = 1 << 224;\n    uint256 internal constant _ROLE_225 = 1 << 225;\n    uint256 internal constant _ROLE_226 = 1 << 226;\n    uint256 internal constant _ROLE_227 = 1 << 227;\n    uint256 internal constant _ROLE_228 = 1 << 228;\n    uint256 internal constant _ROLE_229 = 1 << 229;\n    uint256 internal constant _ROLE_230 = 1 << 230;\n    uint256 internal constant _ROLE_231 = 1 << 231;\n    uint256 internal constant _ROLE_232 = 1 << 232;\n    uint256 internal constant _ROLE_233 = 1 << 233;\n    uint256 internal constant _ROLE_234 = 1 << 234;\n    uint256 internal constant _ROLE_235 = 1 << 235;\n    uint256 internal constant _ROLE_236 = 1 << 236;\n    uint256 internal constant _ROLE_237 = 1 << 237;\n    uint256 internal constant _ROLE_238 = 1 << 238;\n    uint256 internal constant _ROLE_239 = 1 << 239;\n    uint256 internal constant _ROLE_240 = 1 << 240;\n    uint256 internal constant _ROLE_241 = 1 << 241;\n    uint256 internal constant _ROLE_242 = 1 << 242;\n    uint256 internal constant _ROLE_243 = 1 << 243;\n    uint256 internal constant _ROLE_244 = 1 << 244;\n    uint256 internal constant _ROLE_245 = 1 << 245;\n    uint256 internal constant _ROLE_246 = 1 << 246;\n    uint256 internal constant _ROLE_247 = 1 << 247;\n    uint256 internal constant _ROLE_248 = 1 << 248;\n    uint256 internal constant _ROLE_249 = 1 << 249;\n    uint256 internal constant _ROLE_250 = 1 << 250;\n    uint256 internal constant _ROLE_251 = 1 << 251;\n    uint256 internal constant _ROLE_252 = 1 << 252;\n    uint256 internal constant _ROLE_253 = 1 << 253;\n    uint256 internal constant _ROLE_254 = 1 << 254;\n    uint256 internal constant _ROLE_255 = 1 << 255;\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport \"./utils/mocks/MockOwnableRoles.sol\";\n\ncontract OwnableRolesTest is SoladyTest {\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    MockOwnableRoles mockOwnableRoles;\n\n    function setUp() public {\n        mockOwnableRoles = new MockOwnableRoles();\n    }\n\n    function testBytecodeSize() public {\n        MockOwnableRolesBytecodeSizer mock = new MockOwnableRolesBytecodeSizer();\n        assertTrue(address(mock).code.length > 0);\n        assertEq(mock.owner(), address(this));\n    }\n\n    function testInitializeOwnerDirect() public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(0), address(1));\n        mockOwnableRoles.initializeOwnerDirect(address(1));\n    }\n\n    function testSetOwnerDirect(address newOwner) public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), newOwner);\n        mockOwnableRoles.setOwnerDirect(newOwner);\n        assertEq(mockOwnableRoles.owner(), newOwner);\n    }\n\n    function testGrantAndRemoveRolesDirect(\n        address user,\n        uint256 rolesToGrant,\n        uint256 rolesToRemove\n    ) public {\n        mockOwnableRoles.removeRolesDirect(user, mockOwnableRoles.rolesOf(user));\n        assertEq(mockOwnableRoles.rolesOf(user), 0);\n        mockOwnableRoles.grantRolesDirect(user, rolesToGrant);\n        assertEq(mockOwnableRoles.rolesOf(user), rolesToGrant);\n        mockOwnableRoles.removeRolesDirect(user, rolesToRemove);\n        assertEq(mockOwnableRoles.rolesOf(user), rolesToGrant ^ (rolesToGrant & rolesToRemove));\n    }\n\n    struct _TestTemps {\n        address userA;\n        address userB;\n        uint256 rolesA;\n        uint256 rolesB;\n    }\n\n    function testSetRolesDirect(uint256) public {\n        _TestTemps memory t;\n        t.userA = _randomNonZeroAddress();\n        t.userB = _randomNonZeroAddress();\n        while (t.userA == t.userB) t.userA = _randomNonZeroAddress();\n        _testSetRolesDirect(t);\n        _testSetRolesDirect(t);\n    }\n\n    function _testSetRolesDirect(_TestTemps memory t) internal {\n        t.rolesA = _random();\n        t.rolesB = _random();\n        vm.expectEmit(true, true, true, true);\n        emit RolesUpdated(t.userA, t.rolesA);\n        mockOwnableRoles.setRolesDirect(t.userA, t.rolesA);\n        emit RolesUpdated(t.userB, t.rolesB);\n        mockOwnableRoles.setRolesDirect(t.userB, t.rolesB);\n        assertEq(mockOwnableRoles.rolesOf(t.userA), t.rolesA);\n        assertEq(mockOwnableRoles.rolesOf(t.userB), t.rolesB);\n    }\n\n    function testSetOwnerDirect() public {\n        testSetOwnerDirect(address(1));\n    }\n\n    function testRenounceOwnership() public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), address(0));\n        mockOwnableRoles.renounceOwnership();\n        assertEq(mockOwnableRoles.owner(), address(0));\n    }\n\n    function testTransferOwnership(\n        address newOwner,\n        bool setNewOwnerToZeroAddress,\n        bool callerIsOwner\n    ) public {\n        assertEq(mockOwnableRoles.owner(), address(this));\n\n        vm.assume(newOwner != address(this));\n\n        if (newOwner == address(0) || setNewOwnerToZeroAddress) {\n            newOwner = address(0);\n            vm.expectRevert(Ownable.NewOwnerIsZeroAddress.selector);\n        } else if (callerIsOwner) {\n            vm.expectEmit(true, true, true, true);\n            emit OwnershipTransferred(address(this), newOwner);\n        } else {\n            vm.prank(newOwner);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n\n        mockOwnableRoles.transferOwnership(newOwner);\n\n        if (newOwner != address(0) && callerIsOwner) {\n            assertEq(mockOwnableRoles.owner(), newOwner);\n        }\n    }\n\n    function testTransferOwnership() public {\n        testTransferOwnership(address(1), false, true);\n    }\n\n    function testGrantRoles() public {\n        vm.expectEmit(true, true, true, true);\n        emit RolesUpdated(address(1), 111111);\n        mockOwnableRoles.grantRoles(address(1), 111111);\n    }\n\n    function testGrantAndRevokeOrRenounceRoles(\n        address user,\n        bool granterIsOwner,\n        bool useRenounce,\n        bool revokerIsOwner,\n        uint256 rolesToGrant,\n        uint256 rolesToRevoke\n    ) public {\n        vm.assume(user != address(this));\n\n        uint256 rolesAfterRevoke = rolesToGrant ^ (rolesToGrant & rolesToRevoke);\n\n        assertTrue(rolesAfterRevoke & rolesToRevoke == 0);\n        assertTrue((rolesAfterRevoke | rolesToRevoke) & rolesToGrant == rolesToGrant);\n\n        if (granterIsOwner) {\n            vm.expectEmit(true, true, true, true);\n            emit RolesUpdated(user, rolesToGrant);\n        } else {\n            vm.prank(user);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n\n        if (!granterIsOwner) return;\n\n        assertEq(mockOwnableRoles.rolesOf(user), rolesToGrant);\n\n        if (useRenounce) {\n            vm.expectEmit(true, true, true, true);\n            emit RolesUpdated(user, rolesAfterRevoke);\n            vm.prank(user);\n            mockOwnableRoles.renounceRoles(rolesToRevoke);\n        } else if (revokerIsOwner) {\n            vm.expectEmit(true, true, true, true);\n            emit RolesUpdated(user, rolesAfterRevoke);\n            mockOwnableRoles.revokeRoles(user, rolesToRevoke);\n        } else {\n            vm.prank(user);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n            mockOwnableRoles.revokeRoles(user, rolesToRevoke);\n            return;\n        }\n\n        assertEq(mockOwnableRoles.rolesOf(user), rolesAfterRevoke);\n    }\n\n    function testHasAllRoles(\n        address user,\n        uint256 rolesToGrant,\n        uint256 rolesToGrantBrutalizer,\n        uint256 rolesToCheck,\n        bool useSameRoles\n    ) public {\n        if (useSameRoles) {\n            rolesToGrant = rolesToCheck;\n        }\n        rolesToGrant |= rolesToGrantBrutalizer;\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n\n        bool hasAllRoles = (rolesToGrant & rolesToCheck) == rolesToCheck;\n        assertEq(mockOwnableRoles.hasAllRoles(user, rolesToCheck), hasAllRoles);\n    }\n\n    function testHasAnyRole(address user, uint256 rolesToGrant, uint256 rolesToCheck) public {\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n        assertEq(mockOwnableRoles.hasAnyRole(user, rolesToCheck), rolesToGrant & rolesToCheck != 0);\n    }\n\n    function testRolesFromOrdinals(uint8[] memory ordinals) public {\n        uint256 roles;\n        unchecked {\n            for (uint256 i; i < ordinals.length; ++i) {\n                roles |= 1 << uint256(ordinals[i]);\n            }\n        }\n        assertEq(mockOwnableRoles.rolesFromOrdinals(ordinals), roles);\n    }\n\n    function testRolesFromOrdinals() public {\n        unchecked {\n            for (uint256 t; t != 32; ++t) {\n                uint8[] memory ordinals = new uint8[](_random() % 32);\n                for (uint256 i; i != ordinals.length; ++i) {\n                    uint256 randomness = _random();\n                    uint8 r;\n                    assembly {\n                        r := randomness\n                    }\n                    ordinals[i] = r;\n                }\n                testRolesFromOrdinals(ordinals);\n            }\n        }\n    }\n\n    function testOrdinalsFromRoles(uint256 roles) public {\n        uint8[] memory ordinals = new uint8[](256);\n        uint256 n;\n        unchecked {\n            for (uint256 i; i < 256; ++i) {\n                if (roles & (1 << i) != 0) ordinals[n++] = uint8(i);\n            }\n        }\n        uint8[] memory results = mockOwnableRoles.ordinalsFromRoles(roles);\n        assertEq(results.length, n);\n        unchecked {\n            for (uint256 i; i < n; ++i) {\n                assertEq(results[i], ordinals[i]);\n            }\n        }\n    }\n\n    function testOrdinalsFromRoles() public {\n        unchecked {\n            for (uint256 t; t != 32; ++t) {\n                testOrdinalsFromRoles(_random());\n            }\n        }\n    }\n\n    function testOnlyOwnerModifier(address nonOwner, bool callerIsOwner) public {\n        vm.assume(nonOwner != address(this));\n\n        if (!callerIsOwner) {\n            vm.prank(nonOwner);\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        mockOwnableRoles.updateFlagWithOnlyOwner();\n    }\n\n    function testOnlyRolesModifier(address user, uint256 rolesToGrant, uint256 rolesToCheck)\n        public\n    {\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n\n        if (rolesToGrant & rolesToCheck == 0) {\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        vm.prank(user);\n        mockOwnableRoles.updateFlagWithOnlyRoles(rolesToCheck);\n    }\n\n    function testOnlyOwnerOrRolesModifier(\n        address user,\n        bool callerIsOwner,\n        uint256 rolesToGrant,\n        uint256 rolesToCheck\n    ) public {\n        vm.assume(user != address(this));\n\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n\n        if ((rolesToGrant & rolesToCheck == 0) && !callerIsOwner) {\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        if (!callerIsOwner) {\n            vm.prank(user);\n        }\n        mockOwnableRoles.updateFlagWithOnlyOwnerOrRoles(rolesToCheck);\n    }\n\n    function testOnlyRolesOrOwnerModifier(\n        address user,\n        bool callerIsOwner,\n        uint256 rolesToGrant,\n        uint256 rolesToCheck\n    ) public {\n        vm.assume(user != address(this));\n\n        mockOwnableRoles.grantRoles(user, rolesToGrant);\n\n        if ((rolesToGrant & rolesToCheck == 0) && !callerIsOwner) {\n            vm.expectRevert(Ownable.Unauthorized.selector);\n        }\n        if (!callerIsOwner) {\n            vm.prank(user);\n        }\n        mockOwnableRoles.updateFlagWithOnlyRolesOrOwner(rolesToCheck);\n    }\n\n    function testOnlyOwnerOrRolesModifier() public {\n        testOnlyOwnerOrRolesModifier(address(1), false, 1, 2);\n    }\n\n    function testHandoverOwnership(address pendingOwner) public {\n        vm.prank(pendingOwner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverRequested(pendingOwner);\n        mockOwnableRoles.requestOwnershipHandover();\n        assertTrue(mockOwnableRoles.ownershipHandoverExpiresAt(pendingOwner) > block.timestamp);\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), pendingOwner);\n\n        mockOwnableRoles.completeOwnershipHandover(pendingOwner);\n\n        assertEq(mockOwnableRoles.owner(), pendingOwner);\n    }\n\n    function testHandoverOwnership() public {\n        testHandoverOwnership(address(1));\n    }\n\n    function testHandoverOwnershipRevertsIfCompleteIsNotOwner() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnableRoles.requestOwnershipHandover();\n\n        vm.prank(pendingOwner);\n        vm.expectRevert(Ownable.Unauthorized.selector);\n        mockOwnableRoles.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipWithCancellation() public {\n        address pendingOwner = address(1);\n\n        vm.prank(pendingOwner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverRequested(pendingOwner);\n        mockOwnableRoles.requestOwnershipHandover();\n        assertTrue(mockOwnableRoles.ownershipHandoverExpiresAt(pendingOwner) > block.timestamp);\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipHandoverCanceled(pendingOwner);\n        vm.prank(pendingOwner);\n        mockOwnableRoles.cancelOwnershipHandover();\n        assertEq(mockOwnableRoles.ownershipHandoverExpiresAt(pendingOwner), 0);\n        vm.expectRevert(Ownable.NoHandoverRequest.selector);\n\n        mockOwnableRoles.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipBeforeExpiration() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnableRoles.requestOwnershipHandover();\n\n        vm.warp(block.timestamp + mockOwnableRoles.ownershipHandoverValidFor());\n\n        mockOwnableRoles.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testHandoverOwnershipAfterExpiration() public {\n        address pendingOwner = address(1);\n        vm.prank(pendingOwner);\n        mockOwnableRoles.requestOwnershipHandover();\n\n        vm.warp(block.timestamp + mockOwnableRoles.ownershipHandoverValidFor() + 1);\n\n        vm.expectRevert(Ownable.NoHandoverRequest.selector);\n\n        mockOwnableRoles.completeOwnershipHandover(pendingOwner);\n    }\n\n    function testOwnershipHandoverValidForDefaultValue() public {\n        assertEq(mockOwnableRoles.ownershipHandoverValidFor(), 48 * 3600);\n    }\n}\n",
        "contractname": "OwnableRoles.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibClone} from \"../utils/LibClone.sol\";\n\n/// @notice Simple ERC4337 account factory implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol)\n///\n/// @dev Note:\n/// - Unlike the ERC1967Factory, this factory does NOT store any admin info on the factory itself.\n///   The deployed ERC4337 accounts are minimal ERC1967 proxies to an ERC4337 implementation.\n///   The proxy bytecode does NOT contain any upgrading logic.\n/// - This factory does NOT contain any logic for upgrading the ERC4337 accounts.\n///   Upgrading must be done via UUPS logic on the accounts themselves.\n/// - The ERC4337 standard expects the factory to use deterministic deployment.\n///   As such, this factory does not include any non-deterministic deployment methods.\ncontract ERC4337Factory {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         IMMUTABLES                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Address of the ERC4337 implementation.\n    address public immutable implementation;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    constructor(address erc4337) payable {\n        implementation = erc4337;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      DEPLOY FUNCTIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys an ERC4337 account with `salt` and returns its deterministic address.\n    /// If the account is already deployed, it will simply return its address.\n    /// Any `msg.value` will simply be forwarded to the account, regardless.\n    function createAccount(address owner, bytes32 salt) public payable virtual returns (address) {\n        // Check that the salt is tied to the owner if required, regardless.\n        LibClone.checkStartsWith(salt, owner);\n        // Constructor data is optional, and is omitted for easier Etherscan verification.\n        (bool alreadyDeployed, address account) =\n            LibClone.createDeterministicERC1967(msg.value, implementation, salt);\n\n        if (!alreadyDeployed) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x14, owner) // Store the `owner` argument.\n                mstore(0x00, 0xc4d66de8000000000000000000000000) // `initialize(address)`.\n                if iszero(call(gas(), account, 0, 0x10, 0x24, codesize(), 0x00)) {\n                    returndatacopy(mload(0x40), 0x00, returndatasize())\n                    revert(mload(0x40), returndatasize())\n                }\n            }\n        }\n        return account;\n    }\n\n    /// @dev Returns the deterministic address of the account created via `createAccount`.\n    function getAddress(bytes32 salt) public view virtual returns (address) {\n        return LibClone.predictDeterministicAddressERC1967(implementation, salt, address(this));\n    }\n\n    /// @dev Returns the initialization code hash of the ERC4337 account (a minimal ERC1967 proxy).\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash() public view virtual returns (bytes32) {\n        return LibClone.initCodeHashERC1967(implementation);\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {MockERC4337} from \"./utils/mocks/MockERC4337.sol\";\nimport {ERC4337Factory} from \"../src/accounts/ERC4337Factory.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\n\ncontract ERC4337FactoryTest is SoladyTest {\n    address internal constant _ENTRY_POINT = 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n\n    ERC4337Factory factory;\n\n    MockERC4337 erc4337;\n\n    function setUp() public {\n        // Etch something onto `_ENTRY_POINT` such that we can deploy the account implementation.\n        vm.etch(_ENTRY_POINT, hex\"00\");\n        erc4337 = new MockERC4337();\n        factory = new ERC4337Factory(address(erc4337));\n    }\n\n    function testDeployDeterministic(uint256) public {\n        vm.deal(address(this), 100 ether);\n        address owner = _randomNonZeroAddress();\n        uint256 initialValue = _random() % 100 ether;\n        bytes32 salt = _random() % 8 == 0 ? bytes32(_random()) : bytes32(uint256(uint96(_random())));\n        address account;\n        if (uint256(salt) >> 96 != uint160(owner) && uint256(salt) >> 96 != 0) {\n            vm.expectRevert(LibClone.SaltDoesNotStartWith.selector);\n            account = factory.createAccount{value: initialValue}(owner, salt);\n            return;\n        } else {\n            account = factory.createAccount{value: initialValue}(owner, salt);\n        }\n        assertEq(address(account).balance, initialValue);\n        assertEq(MockERC4337(payable(account)).owner(), owner);\n        _checkImplementationSlot(account, address(erc4337));\n    }\n\n    function testCreateAccountRepeatedDeployment() public {\n        bytes32 salt = bytes32(_random() & uint256(type(uint96).max));\n        address expectedInstance = factory.getAddress(salt);\n        address instance = factory.createAccount{value: 123}(address(0xABCD), salt);\n        assertEq(instance.balance, 123);\n        assertEq(factory.createAccount{value: 456}(address(0xABCD), salt), instance);\n        assertEq(factory.createAccount(address(0xABCD), salt), instance);\n        assertEq(instance.balance, 123 + 456);\n        assertEq(expectedInstance, instance);\n    }\n\n    function testCreateAccountRepeatedDeployment(uint256) public {\n        address owner = _randomNonZeroAddress();\n        bytes32 salt =\n            bytes32((_random() & uint256(type(uint96).max)) | (uint256(uint160(owner)) << 96));\n        address expectedInstance = factory.getAddress(salt);\n        address notOwner = _randomNonZeroAddress();\n        while (owner == notOwner) notOwner = _randomNonZeroAddress();\n        vm.expectRevert(LibClone.SaltDoesNotStartWith.selector);\n        factory.createAccount{value: 123}(notOwner, salt);\n        address instance = factory.createAccount{value: 123}(owner, salt);\n        assertEq(instance.balance, 123);\n        vm.expectRevert(LibClone.SaltDoesNotStartWith.selector);\n        factory.createAccount{value: 123}(notOwner, salt);\n        assertEq(factory.createAccount{value: 456}(owner, salt), instance);\n        assertEq(factory.createAccount(owner, salt), instance);\n        assertEq(instance.balance, 123 + 456);\n        assertEq(expectedInstance, instance);\n    }\n\n    function _checkImplementationSlot(address proxy, address implementation_) internal {\n        bytes32 slot = bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n        assertEq(vm.load(proxy, slot), bytes32(uint256(uint160(implementation_))));\n    }\n}\n",
        "contractname": "ERC4337Factory.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Receiver mixin for ETH and safe-transferred ERC721 and ERC1155 tokens.\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n///\n/// @dev Note:\n/// - Handles all ERC721 and ERC1155 token safety callbacks.\n/// - Collapses function table gas overhead and code size.\n/// - Utilizes fallback so unknown calldata will pass on.\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual {}\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback {}\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {Receiver} from \"../src/accounts/Receiver.sol\";\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\nimport {MockReceiver} from \"./utils/mocks/MockReceiver.sol\";\n\ncontract ReceiverTest is SoladyTest {\n    MockERC721 immutable erc721 = new MockERC721();\n    MockERC1155 immutable erc1155 = new MockERC1155();\n    MockReceiver immutable receiver = new MockReceiver();\n    address immutable alice = address(bytes20(\"milady\"));\n\n    function setUp() public {}\n\n    function testETHReceived() public {\n        payable(address(receiver)).transfer(1 ether);\n    }\n\n    function testOnERC721Received() public {\n        erc721.mint(alice, 1);\n        vm.prank(alice);\n        erc721.safeTransferFrom(alice, address(receiver), 1);\n    }\n\n    function testOnERC1155Received() public {\n        erc1155.mint(alice, 1, 1, \"\");\n        vm.prank(alice);\n        erc1155.safeTransferFrom(alice, address(receiver), 1, 1, \"\");\n    }\n\n    function testOnERC1155BatchReceived() public {\n        erc1155.mint(alice, 1, 1, \"\");\n        uint256[] memory ids = new uint256[](1);\n        ids[0] = 1;\n        uint256[] memory amts = new uint256[](1);\n        amts[0] = 1;\n        vm.prank(alice);\n        erc1155.safeBatchTransferFrom(alice, address(receiver), ids, amts, \"\");\n    }\n}\n",
        "contractname": "Receiver.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for interacting with ERC6551 accounts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/LibERC6551.sol)\n/// @author ERC6551 team (https://github.com/erc6551/reference/blob/main/src/lib/ERC6551AccountLib.sol)\nlibrary LibERC6551 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Failed to create a ERC6551 account via the registry.\n    error AccountCreationFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The canonical ERC6551 registry address for EVM chains.\n    address internal constant REGISTRY = 0x000000006551c19487814612e58FE06813775758;\n\n    /// @dev The canonical ERC6551 registry bytecode for EVM chains.\n    /// Useful for forge tests:\n    /// `vm.etch(REGISTRY, REGISTRY_BYTECODE)`.\n    bytes internal constant REGISTRY_BYTECODE =\n        hex\"608060405234801561001057600080fd5b50600436106100365760003560e01c8063246a00211461003b5780638a54c52f1461006a575b600080fd5b61004e6100493660046101b7565b61007d565b6040516001600160a01b03909116815260200160405180910390f35b61004e6100783660046101b7565b6100e1565b600060806024608c376e5af43d82803e903d91602b57fd5bf3606c5285605d52733d60ad80600a3d3981f3363d3d373d3d3d363d7360495260ff60005360b76055206035523060601b60015284601552605560002060601b60601c60005260206000f35b600060806024608c376e5af43d82803e903d91602b57fd5bf3606c5285605d52733d60ad80600a3d3981f3363d3d373d3d3d363d7360495260ff60005360b76055206035523060601b600152846015526055600020803b61018b578560b760556000f580610157576320188a596000526004601cfd5b80606c52508284887f79f19b3655ee38b1ce526556b7731a20c8f218fbda4a3990b6cc4172fdf887226060606ca46020606cf35b8060601b60601c60005260206000f35b80356001600160a01b03811681146101b257600080fd5b919050565b600080600080600060a086880312156101cf57600080fd5b6101d88661019b565b945060208601359350604086013592506101f46060870161019b565b94979396509194608001359291505056fea2646970667358221220ea2fe53af507453c64dd7c1db05549fa47a298dfb825d6d11e1689856135f16764736f6c63430008110033\";\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                ACCOUNT BYTECODE OPERATIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the initialization code of the ERC6551 account.\n    function initCode(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer..\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xb7), tokenId_)\n            mstore(add(result, 0x97), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x77), chainId_)\n            mstore(add(result, 0x57), salt_)\n            mstore(add(result, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x28), implementation_)\n            mstore(add(result, 0x14), 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(result, 0xb7) // Store the length.\n            mstore(0x40, add(result, 0xd7)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC6551 account.\n    function initCodeHash(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            result := keccak256(add(result, 0x0c), 0xb7)\n        }\n    }\n\n    /// @dev Creates an account via the ERC6551 registry.\n    function createAccount(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x14), implementation_)\n            mstore(add(m, 0x34), salt_)\n            mstore(add(m, 0x54), chainId_)\n            mstore(add(m, 0x74), shr(96, shl(96, tokenContract_)))\n            mstore(add(m, 0x94), tokenId_)\n            // `createAccount(address,bytes32,uint256,address,uint256)`.\n            mstore(m, 0x8a54c52f000000000000000000000000)\n            if iszero(\n                and(\n                    gt(returndatasize(), 0x1f),\n                    call(gas(), REGISTRY, 0, add(m, 0x10), 0xa4, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x20188a59) // `AccountCreationFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the address of the ERC6551 account.\n    function account(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(result, 0x0c), 0xb7))\n            mstore(0x01, shl(96, REGISTRY))\n            mstore(0x15, salt_)\n            result := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns if `a` is an ERC6551 account with `expectedImplementation`.\n    function isERC6551Account(address a, address expectedImplementation)\n        internal\n        view\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer..\n            extcodecopy(a, add(m, 0x20), 0x0a, 0xa3)\n            let implementation_ := shr(96, mload(add(m, 0x20)))\n            if mul(\n                extcodesize(implementation_),\n                gt(eq(extcodesize(a), 0xad), shl(96, xor(expectedImplementation, implementation_)))\n            ) {\n                // Layout the variables and bytecode backwards.\n                mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n                mstore(add(m, 0x14), implementation_)\n                mstore(m, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n                // Compute and store the bytecode hash.\n                mstore8(0x00, 0xff) // Write the prefix.\n                mstore(0x35, keccak256(add(m, 0x0c), 0xb7))\n                mstore(0x01, shl(96, REGISTRY))\n                mstore(0x15, mload(add(m, 0x43)))\n                result := iszero(shl(96, xor(a, keccak256(0x00, 0x55))))\n                mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the implementation of the ERC6551 account `a`.\n    function implementation(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x0a, 0x14)\n            result := shr(96, mload(0x00))\n        }\n    }\n\n    /// @dev Returns the static variables of the ERC6551 account `a`.\n    function context(address a)\n        internal\n        view\n        returns (bytes32 salt_, uint256 chainId_, address tokenContract_, uint256 tokenId_)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(a, 0x00, 0x2d, 0x80)\n            salt_ := mload(0x00)\n            chainId_ := mload(0x20)\n            tokenContract_ := mload(0x40)\n            tokenId_ := mload(0x60)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the salt of the ERC6551 account `a`.\n    function salt(address a) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x2d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the chain ID of the ERC6551 account `a`.\n    function chainId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x4d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the token contract of the ERC6551 account `a`.\n    function tokenContract(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x6d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the token ID of the ERC6551 account `a`.\n    function tokenId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x8d, 0x20)\n            result := mload(0x00)\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {LibERC6551} from \"../src/accounts/LibERC6551.sol\";\n\ninterface IERC6551Registry {\n    event ERC6551AccountCreated(\n        address account,\n        address indexed implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId\n    );\n\n    error AccountCreationFailed();\n\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address account);\n}\n\ncontract LibERC6551Test is SoladyTest {\n    function setUp() public {\n        vm.etch(LibERC6551.REGISTRY, LibERC6551.REGISTRY_BYTECODE);\n    }\n\n    function testInitCodeHash(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) public {\n        bytes memory initCode =\n            LibERC6551.initCode(implementation, salt, chainId, tokenContract, tokenId);\n        if (_random() % 8 == 0) _brutalizeMemory();\n        bytes32 initCodeHash =\n            LibERC6551.initCodeHash(implementation, salt, chainId, tokenContract, tokenId);\n        if (_random() % 8 == 0) _brutalizeMemory();\n        assertEq(initCodeHash, keccak256(initCode));\n    }\n\n    function testComputeAccountAddress(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) public {\n        IERC6551Registry registry = IERC6551Registry(LibERC6551.REGISTRY);\n        address a = registry.account(\n            _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n        );\n        if (_random() % 8 == 0) _brutalizeMemory();\n        if (_random() % 8 == 0) {\n            address deployed = _createAccount(\n                _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n            );\n            assertEq(deployed, a);\n        }\n        if (_random() % 8 == 0) _brutalizeMemory();\n        address computed = LibERC6551.account(\n            _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n        );\n        assertEq(computed, a);\n        _checkMemory();\n    }\n\n    function testIsERC6551Account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) public {\n        if (_random() % 8 == 0) implementation = address(this);\n\n        address a = _account(implementation, salt, chainId, tokenContract, tokenId);\n        assertEq(LibERC6551.isERC6551Account(_brutalized(a), _brutalized(implementation)), false);\n\n        _createAccount(implementation, salt, chainId, tokenContract, tokenId);\n        assertEq(_createAccount(implementation, salt, chainId, tokenContract, tokenId), a);\n\n        assertEq(LibERC6551.implementation(_brutalized(a)), _brutalized(implementation));\n        assertEq(\n            LibERC6551.isERC6551Account(_brutalized(a), _brutalized(implementation)),\n            implementation.code.length != 0\n        );\n        _checkMemory();\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            implementation := xor(1, implementation)\n        }\n        assertEq(LibERC6551.isERC6551Account(_brutalized(a), _brutalized(implementation)), false);\n        _checkMemory();\n    }\n\n    function _account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) internal returns (address) {\n        if (_random() % 2 == 0) {\n            return LibERC6551.account(\n                _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n            );\n        } else {\n            IERC6551Registry registry = IERC6551Registry(LibERC6551.REGISTRY);\n            return registry.account(\n                _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n            );\n        }\n    }\n\n    function _createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) internal returns (address) {\n        if (_random() % 2 == 0) {\n            return LibERC6551.createAccount(\n                _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n            );\n        } else {\n            IERC6551Registry registry = IERC6551Registry(LibERC6551.REGISTRY);\n            return registry.createAccount(\n                _brutalized(implementation), salt, chainId, _brutalized(tokenContract), tokenId\n            );\n        }\n    }\n\n    struct _TestTemps {\n        bytes32 salt;\n        uint256 chainId;\n        address tokenContract;\n        uint256 tokenId;\n    }\n\n    function testContext(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) public {\n        address a = _createAccount(implementation, salt, chainId, tokenContract, tokenId);\n        assertEq(LibERC6551.salt(_brutalized(a)), salt);\n        assertEq(LibERC6551.chainId(_brutalized(a)), chainId);\n        assertEq(LibERC6551.tokenContract(_brutalized(a)), tokenContract);\n        assertEq(LibERC6551.tokenId(_brutalized(a)), tokenId);\n        _checkMemory();\n\n        assertEq(LibERC6551.implementation(a), implementation);\n        _checkMemory();\n\n        _TestTemps memory t;\n        (t.salt, t.chainId, t.tokenContract, t.tokenId) = LibERC6551.context(a);\n        assertEq(t.chainId, chainId);\n        assertEq(t.salt, salt);\n        assertEq(t.tokenContract, tokenContract);\n        assertEq(t.tokenId, tokenId);\n        _checkMemory();\n    }\n}\n",
        "contractname": "LibERC6551.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Receiver} from \"./Receiver.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {LibZip} from \"../utils/LibZip.sol\";\nimport {UUPSUpgradeable} from \"../utils/UUPSUpgradeable.sol\";\n\n/// @notice Simple ERC6551 account implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC6551.sol)\n/// @author ERC6551 team (https://github.com/erc6551/reference/blob/main/src/examples/upgradeable/ERC6551AccountUpgradeable.sol)\n///\n/// @dev Recommended usage (regular):\n/// 1. Deploy the ERC6551 as an implementation contract, and verify it on Etherscan.\n/// 2. Use the canonical ERC6551Registry to deploy a clone to the ERC6551 implementation.\n///    The UUPSUpgradeable functions will simply become no-ops.\n///\n/// Recommended usage (upgradeable):\n/// 1. Deploy the ERC6551 as an implementation contract, and verify it on Etherscan.\n/// 2. Deploy the ERC6551Proxy pointing to the implementation.\n///    This relay proxy is required, but Etherscan verification of it is optional.\n/// 3. Use the canonical ERC6551Registry to deploy a clone to the ERC6551Proxy.\n///    If you want to reveal the \"Read as Proxy\" and \"Write as Proxy\" tabs on Etherscan,\n///    send 0 ETH to the clone to initialize its ERC1967 implementation slot,\n///    the click on \"Is this a proxy?\" on the clone's page on Etherscan.\n///\n/// Note:\n/// - This implementation does NOT include ERC4337 functionality.\n///   This is intentional, because the canonical ERC4337 entry point may still change and we\n///   don't want to encourage upgradeability by default for ERC6551 accounts just to handle this.\n///   We may include ERC4337 functionality once ERC4337 has been finalized.\n///   Recent updates to the account abstraction validation scope rules\n///   [ERC7562](https://eips.ethereum.org/EIPS/eip-7562) has made ERC6551 compatible with ERC4337.\n///   For an opinionated implementation, see https://github.com/tokenbound/contracts.\n///   If you want to add it yourself, you'll just need to add in the\n///   user operation validation functionality (and use ERC6551's execution functionality).\n/// - Please refer to the official [ERC6551](https://github.com/erc6551/reference) reference\n///   for latest updates on the ERC6551 standard, as well as canonical registry information.\nabstract contract ERC6551 is UUPSUpgradeable, Receiver, ERC1271 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Call struct for the `executeBatch` function.\n    struct Call {\n        address target;\n        uint256 value;\n        bytes data;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The operation is not supported.\n    error OperationNotSupported();\n\n    /// @dev Self ownership detected.\n    error SelfOwnDetected();\n\n    /// @dev The function selector is not recognized.\n    error FnSelectorNotRecognized();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ERC6551 state slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_ERC6551_STATE_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 internal constant _ERC6551_STATE_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffb919c7a5;\n\n    /// @dev Caches the chain ID in the deployed bytecode,\n    /// so that in the rare case of a hard fork, `owner` will still work.\n    uint256 private immutable _cachedChainId = block.chainid;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              TOKEN-BOUND OWNERSHIP OPERATIONS              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the token-bound information.\n    function token()\n        public\n        view\n        virtual\n        returns (uint256 chainId, address tokenContract, uint256 tokenId)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            chainId := mload(0x00)\n            tokenContract := mload(0x20) // Upper 96 bits will be clean.\n            tokenId := mload(0x40)\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            if eq(mload(0x00), cachedChainId) {\n                let tokenContract := mload(0x20)\n                // `tokenId` is already at 0x40.\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                result :=\n                    mul( // Returns `address(0)` on failure or if contract does not exist.\n                        mload(0x20),\n                        and(\n                            gt(returndatasize(), 0x1f),\n                            staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                        )\n                    )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Returns if `signer` is an authorized signer.\n    /// `extraData` can be anything (e.g. an address, a pointer to a struct / string in memory).\n    function _isValidSigner(address signer, bytes32 extraData, bytes calldata context)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        extraData = extraData; // Silence unused variable warning.\n        context = context; // Silence unused variable warning.\n        return signer == owner();\n    }\n\n    /// @dev Returns if `signer` is an authorized signer, with an optional `context`.\n    /// MUST return the bytes4 magic value `0x523e3260` if the given signer is valid.\n    /// By default, the holder of the non-fungible token the account is bound to\n    /// MUST be considered a valid signer.\n    function isValidSigner(address signer, bytes calldata context)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        bool isValid = _isValidSigner(signer, bytes32(0), context);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `isValid ? bytes4(keccak256(\"isValidSigner(address,bytes)\")) : 0x00000000`.\n            // We use `0x00000000` for invalid, in convention with the reference implementation.\n            result := shl(224, mul(0x523e3260, iszero(iszero(isValid))))\n        }\n    }\n\n    /// @dev Returns empty calldata bytes.\n    function _emptyContext() internal pure returns (bytes calldata context) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            context.length := 0\n        }\n    }\n\n    /// @dev Requires that the caller is a valid signer (i.e. the owner).\n    modifier onlyValidSigner() virtual {\n        if (!_isValidSigner(msg.sender, bytes32(0), _emptyContext())) revert Unauthorized();\n        _;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      STATE OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the current value of the state.\n    function state() public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_ERC6551_STATE_SLOT)\n        }\n    }\n\n    /// @dev Mutates the state. This function is required to be called in every\n    /// public / external function that may modify storage or emit events.\n    function _updateState() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _ERC6551_STATE_SLOT\n            let m := mload(0x40)\n            mstore(m, sload(s))\n            mstore(add(0x20, m), 0x40)\n            mstore(add(0x40, m), calldatasize())\n            calldatacopy(add(0x60, m), 0x00, add(0x20, calldatasize()))\n            sstore(s, keccak256(m, and(add(0x7f, calldatasize()), not(0x1f))))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    EXECUTION OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Execute a call from this account.\n    /// Reverts and bubbles up error if operation fails.\n    /// Returns the result of the operation.\n    ///\n    /// Accounts MUST accept the following operation parameter values:\n    /// - 0 = CALL\n    /// - 1 = DELEGATECALL\n    /// - 2 = CREATE\n    /// - 3 = CREATE2\n    ///\n    /// Accounts MAY support additional operations or restrict a signer's\n    /// ability to execute certain operations.\n    function execute(address target, uint256 value, bytes calldata data, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes memory result)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n        _updateState();\n    }\n\n    /// @dev Execute a sequence of calls from this account.\n    /// Reverts and bubbles up error if an operation fails.\n    /// Returns the results of the operations.\n    ///\n    /// This is a batch variant of `execute` and is not required for `IERC6551Executable`.\n    function executeBatch(Call[] calldata calls, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes[] memory results)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n        _updateState();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           ERC165                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6551: 0x6faff5f1, ERC6551Executable: 0x51945447.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x6faff5f1)), eq(s, 0x51945447))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OVERRIDES                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev To ensure that only the owner or the account itself can upgrade the implementation.\n    /// If you don't need upgradeability, override this function to return false.\n    function _authorizeUpgrade(address)\n        internal\n        virtual\n        override(UUPSUpgradeable)\n        onlyValidSigner\n    {\n        _updateState();\n    }\n\n    /// @dev Uses the `owner` as the ERC1271 signer.\n    function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }\n\n    /// @dev For handling token callbacks.\n    /// Safe-transferred ERC721 tokens will trigger a ownership cycle check.\n    modifier receiverFallback() override(Receiver) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0x00))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            if eq(s, 0x150b7a02) {\n                extcodecopy(address(), 0x00, 0x4d, 0x60) // `chainId`, `tokenContract`, `tokenId`.\n                mstore(0x60, 0xfc0c546a) // `token()`.\n                for {} 1 {} {\n                    let tokenContract := mload(0x20)\n                    // `tokenId` is already at 0x40.\n                    mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                    let chainsEq := eq(mload(0x00), cachedChainId)\n                    let currentOwner :=\n                        mul(\n                            mload(0x20),\n                            and(\n                                and(gt(returndatasize(), 0x1f), chainsEq),\n                                staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                            )\n                        )\n                    if iszero(\n                        or(\n                            eq(currentOwner, address()),\n                            and(\n                                and(chainsEq, eq(tokenContract, caller())),\n                                eq(mload(0x40), calldataload(0x44))\n                            )\n                        )\n                    ) {\n                        if iszero(\n                            and(\n                                gt(returndatasize(), 0x5f),\n                                staticcall(gas(), currentOwner, 0x7c, 0x04, 0x00, 0x60)\n                            )\n                        ) {\n                            mstore(0x40, s) // Store `msg.sig`.\n                            return(0x5c, 0x20) // Return `msg.sig`.\n                        }\n                        continue\n                    }\n                    mstore(0x00, 0xaed146d3) // `SelfOwnDetected()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81)) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n\n    /// @dev If you don't need to use `LibZip.cdFallback`, override this function to return false.\n    function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Handle token callbacks. If no token callback is triggered,\n    /// use `LibZip.cdFallback` for generalized calldata decompression.\n    fallback() external payable virtual override(Receiver) receiverFallback {\n        if (_useLibZipCdFallback()) {\n            // Reverts with out-of-gas by recursing infinitely if the first 4 bytes\n            // of the decompressed `msg.data` doesn't match any function selector.\n            LibZip.cdFallback();\n        } else {\n            revert FnSelectorNotRecognized();\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {SignatureCheckerLib} from \"../src/utils/SignatureCheckerLib.sol\";\nimport {ERC6551Proxy} from \"../src/accounts/ERC6551Proxy.sol\";\nimport {ERC6551, MockERC6551, MockERC6551V2} from \"./utils/mocks/MockERC6551.sol\";\nimport {MockERC6551Registry} from \"./utils/mocks/MockERC6551Registry.sol\";\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\nimport {LibZip} from \"../src/utils/LibZip.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\n\ncontract Target {\n    error TargetError(bytes data);\n\n    bytes32 public datahash;\n\n    bytes public data;\n\n    function setData(bytes memory data_) public payable returns (bytes memory) {\n        data = data_;\n        datahash = keccak256(data_);\n        return data_;\n    }\n\n    function revertWithTargetError(bytes memory data_) public payable {\n        revert TargetError(data_);\n    }\n}\n\ncontract ERC6551Test is SoladyTest {\n    MockERC6551Registry internal _registry;\n\n    address internal _erc6551;\n\n    address internal _erc6551V2;\n\n    address internal _erc721;\n\n    address internal _proxy;\n\n    event ChainIdSaved(uint256 indexed chainId);\n\n    // By right, this should be the keccak256 of some long-ass string:\n    // (e.g. `keccak256(\"Parent(bytes32 childHash,Mail child)Mail(Person from,Person to,string contents)Person(string name,address wallet)\")`).\n    // But I'm lazy and will use something randomish here.\n    bytes32 internal constant _PARENT_TYPEHASH =\n        0xd61db970ec8a2edc5f9fd31d876abe01b785909acb16dcd4baaf3b434b4c439b;\n\n    // By right, this should be a proper domain separator, but I'm lazy.\n    bytes32 internal constant _DOMAIN_SEP_B =\n        0xa1a044077d7677adbbfa892ded5390979b33993e0e2a457e3f974bbcda53821b;\n\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct _TestTemps {\n        address owner;\n        uint256 chainId;\n        uint256 tokenId;\n        bytes32 salt;\n        MockERC6551 account;\n        address signer;\n        uint256 privateKey;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function setUp() public {\n        _registry = new MockERC6551Registry();\n        _erc6551 = address(new MockERC6551());\n        _erc721 = address(new MockERC721());\n        _proxy = address(new ERC6551Proxy(_erc6551));\n        _erc6551V2 = address(new MockERC6551V2());\n    }\n\n    function _testTempsMint(address owner) internal returns (uint256 tokenId) {\n        while (true) {\n            tokenId = _random() % 8 == 0 ? _random() % 32 : _random();\n            (bool success,) =\n                _erc721.call(abi.encodeWithSignature(\"mint(address,uint256)\", owner, tokenId));\n            if (success) return tokenId;\n        }\n    }\n\n    function _testTemps() internal returns (_TestTemps memory t) {\n        t.owner = _randomNonZeroAddress();\n        t.tokenId = _testTempsMint(t.owner);\n        t.chainId = block.chainid;\n        t.salt = bytes32(_random());\n        address account = _registry.createAccount(_proxy, t.salt, t.chainId, _erc721, t.tokenId);\n        t.account = MockERC6551(payable(account));\n    }\n\n    function testDeployERC6551Proxy() public {\n        emit LogBytes(\"ERC6551Proxy code\", address(new ERC6551Proxy(_erc6551)).code);\n    }\n\n    function testInitializeERC6551ProxyImplementation() public {\n        address account = address(_testTemps().account);\n        (bool success,) = account.call(\"\");\n        assertTrue(success);\n        bytes32 implementationSlotValue = bytes32(uint256(uint160(_erc6551)));\n        assertEq(vm.load(account, _ERC1967_IMPLEMENTATION_SLOT), implementationSlotValue);\n    }\n\n    function testDeployERC6551(uint256) public {\n        _TestTemps memory t = _testTemps();\n        (uint256 chainId, address tokenContract, uint256 tokenId) = t.account.token();\n        assertEq(chainId, t.chainId);\n        assertEq(tokenContract, _erc721);\n        assertEq(tokenId, t.tokenId);\n        address owner = t.account.owner();\n        assertEq(owner, t.owner);\n        if (_random() % 8 == 0) {\n            vm.prank(owner);\n            address newOnwer = _randomNonZeroAddress();\n            MockERC721(_erc721).transferFrom(owner, newOnwer, t.tokenId);\n            assertEq(t.account.owner(), newOnwer);\n        }\n    }\n\n    function testOwnerWorksWithChainIdChange(uint256 oldChainId, uint256 newChainId) public {\n        oldChainId = _bound(oldChainId, 0, 2 ** 64 - 1);\n        newChainId = _bound(newChainId, 0, 2 ** 64 - 1);\n        vm.chainId(oldChainId);\n        _erc6551 = address(new MockERC6551());\n        _proxy = address(new ERC6551Proxy(_erc6551));\n        _TestTemps memory t = _testTemps();\n        assertEq(t.account.owner(), t.owner);\n        vm.chainId(newChainId);\n        assertEq(t.account.owner(), t.owner);\n    }\n\n    function testOnERC721ReceivedCycles() public {\n        unchecked {\n            uint256 n = 8;\n            _TestTemps[] memory t = new _TestTemps[](n);\n            for (uint256 i; i != n; ++i) {\n                t[i] = _testTemps();\n                if (i != 0) {\n                    vm.prank(t[i].owner);\n                    MockERC721(_erc721).safeTransferFrom(\n                        t[i].owner, address(t[i - 1].account), t[i].tokenId\n                    );\n                    t[i].owner = address(t[i - 1].account);\n                }\n            }\n            for (uint256 i; i != n; ++i) {\n                for (uint256 j = i; j != n; ++j) {\n                    vm.prank(t[i].owner);\n                    vm.expectRevert(ERC6551.SelfOwnDetected.selector);\n                    MockERC721(_erc721).safeTransferFrom(\n                        t[i].owner, address(t[j].account), t[i].tokenId\n                    );\n                }\n            }\n\n            _TestTemps memory u = _testTemps();\n            vm.prank(u.owner);\n            MockERC721(_erc721).safeTransferFrom(u.owner, address(t[n - 1].account), u.tokenId);\n        }\n    }\n\n    function testOnERC721ReceivedCyclesWithDifferentChainIds(uint256) public {\n        _TestTemps[] memory t = new _TestTemps[](3);\n        unchecked {\n            for (uint256 i; i != 3; ++i) {\n                vm.chainId(i);\n                t[i] = _testTemps();\n                if (i != 0) {\n                    vm.prank(t[i].owner);\n                    MockERC721(_erc721).safeTransferFrom(\n                        t[i].owner, address(t[i - 1].account), t[i].tokenId\n                    );\n                    t[i].owner = address(t[i - 1].account);\n                }\n            }\n        }\n        unchecked {\n            vm.chainId(_random() % 3);\n            uint256 i = _random() % 3;\n            uint256 j = _random() % 3;\n            while (j == i) j = _random() % 3;\n            vm.prank(t[i].owner);\n            MockERC721(_erc721).safeTransferFrom(t[i].owner, address(t[j].account), t[i].tokenId);\n        }\n    }\n\n    function testOnERC721Received() public {\n        _TestTemps memory t = _testTemps();\n        address alice = _randomNonZeroAddress();\n        MockERC721 erc721 = new MockERC721();\n        erc721.mint(alice, 1);\n        vm.prank(alice);\n        if (alice != address(t.account)) {\n            erc721.safeTransferFrom(alice, address(t.account), 1);\n        }\n    }\n\n    function testOnERC1155Received() public {\n        _TestTemps memory t = _testTemps();\n        address alice = _randomNonZeroAddress();\n        MockERC1155 erc1155 = new MockERC1155();\n        erc1155.mint(alice, 1, 1, \"\");\n        vm.prank(alice);\n        erc1155.safeTransferFrom(alice, address(t.account), 1, 1, \"\");\n    }\n\n    function testOnERC1155BatchReceived() public {\n        _TestTemps memory t = _testTemps();\n        address alice = _randomNonZeroAddress();\n        MockERC1155 erc1155 = new MockERC1155();\n        erc1155.mint(alice, 1, 1, \"\");\n        uint256[] memory ids = new uint256[](1);\n        ids[0] = 1;\n        uint256[] memory amts = new uint256[](1);\n        amts[0] = 1;\n        vm.prank(alice);\n        erc1155.safeBatchTransferFrom(alice, address(t.account), ids, amts, \"\");\n    }\n\n    function testExecute() public {\n        _TestTemps memory t = _testTemps();\n        vm.deal(address(t.account), 1 ether);\n\n        address target = address(new Target());\n        bytes memory data = _randomBytes(111);\n\n        assertEq(t.account.state(), bytes32(0));\n\n        vm.prank(t.owner);\n        t.account.execute(target, 123, abi.encodeWithSignature(\"setData(bytes)\", data), 0);\n        assertEq(Target(target).datahash(), keccak256(data));\n        assertEq(target.balance, 123);\n\n        vm.prank(_randomNonZeroAddress());\n        vm.expectRevert(ERC6551.Unauthorized.selector);\n        t.account.execute(target, 123, abi.encodeWithSignature(\"setData(bytes)\", data), 0);\n\n        vm.prank(t.owner);\n        vm.expectRevert(abi.encodeWithSignature(\"TargetError(bytes)\", data));\n        t.account.execute(\n            target, 123, abi.encodeWithSignature(\"revertWithTargetError(bytes)\", data), 0\n        );\n\n        vm.prank(t.owner);\n        vm.expectRevert(ERC6551.OperationNotSupported.selector);\n        t.account.execute(\n            target, 123, abi.encodeWithSignature(\"revertWithTargetError(bytes)\", data), 1\n        );\n    }\n\n    function testExecuteBatch() public {\n        _TestTemps memory t = _testTemps();\n        vm.deal(address(t.account), 1 ether);\n\n        ERC6551.Call[] memory calls = new ERC6551.Call[](2);\n        calls[0].target = address(new Target());\n        calls[1].target = address(new Target());\n        calls[0].value = 123;\n        calls[1].value = 456;\n        calls[0].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(111));\n        calls[1].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(222));\n\n        assertEq(t.account.state(), bytes32(0));\n\n        vm.prank(t.owner);\n        t.account.executeBatch(calls, 0);\n        assertEq(Target(calls[0].target).datahash(), keccak256(_randomBytes(111)));\n        assertEq(Target(calls[1].target).datahash(), keccak256(_randomBytes(222)));\n        assertEq(calls[0].target.balance, 123);\n        assertEq(calls[1].target.balance, 456);\n\n        calls[1].data = abi.encodeWithSignature(\"revertWithTargetError(bytes)\", _randomBytes(111));\n        vm.expectRevert(abi.encodeWithSignature(\"TargetError(bytes)\", _randomBytes(111)));\n        vm.prank(t.owner);\n        t.account.executeBatch(calls, 0);\n\n        vm.prank(t.owner);\n        vm.expectRevert(ERC6551.OperationNotSupported.selector);\n        t.account.executeBatch(calls, 1);\n    }\n\n    function testExecuteBatch(uint256 r) public {\n        _TestTemps memory t = _testTemps();\n        vm.deal(address(t.account), 1 ether);\n\n        assertEq(t.account.state(), bytes32(0));\n\n        unchecked {\n            uint256 n = r & 3;\n            ERC6551.Call[] memory calls = new ERC6551.Call[](n);\n\n            for (uint256 i; i != n; ++i) {\n                uint256 v = _random() & 0xff;\n                calls[i].target = address(new Target());\n                calls[i].value = v;\n                calls[i].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(v));\n            }\n\n            bytes[] memory results;\n            if (_random() & 1 == 0) {\n                vm.prank(t.owner);\n                results = t.account.executeBatch(_random(), calls, 0);\n            } else {\n                vm.prank(t.owner);\n                results = t.account.executeBatch(calls, 0);\n            }\n\n            assertEq(results.length, n);\n            for (uint256 i; i != n; ++i) {\n                uint256 v = calls[i].value;\n                assertEq(Target(calls[i].target).datahash(), keccak256(_randomBytes(v)));\n                assertEq(calls[i].target.balance, v);\n                assertEq(abi.decode(results[i], (bytes)), _randomBytes(v));\n            }\n        }\n    }\n\n    function testUpgrade() public {\n        _TestTemps memory t = _testTemps();\n        vm.expectRevert(ERC6551.Unauthorized.selector);\n        t.account.upgradeToAndCall(_erc6551V2, bytes(\"\"));\n        bytes32 state;\n        assertEq(t.account.state(), state);\n        assertEq(t.account.mockId(), \"1\");\n\n        vm.prank(t.owner);\n        bytes memory data =\n            abi.encodeWithSignature(\"upgradeToAndCall(address,bytes)\", _erc6551V2, \"\");\n        (bool success,) = address(t.account).call(data);\n        assertTrue(success);\n        assertEq(t.account.mockId(), \"2\");\n        state = keccak256(abi.encode(state, data));\n        assertEq(t.account.state(), state);\n\n        vm.prank(t.owner);\n        data = abi.encodeWithSignature(\"upgradeToAndCall(address,bytes)\", _erc6551, \"\");\n        (success,) = address(t.account).call(data);\n        assertTrue(success);\n        assertEq(t.account.mockId(), \"1\");\n        state = keccak256(abi.encode(state, data));\n        assertEq(t.account.state(), state);\n    }\n\n    function testSupportsInterface() public {\n        _TestTemps memory t = _testTemps();\n        assertTrue(t.account.supportsInterface(0x01ffc9a7));\n        assertTrue(t.account.supportsInterface(0x6faff5f1));\n        assertTrue(t.account.supportsInterface(0x51945447));\n        assertFalse(t.account.supportsInterface(0x00000001));\n    }\n\n    function testCdFallback() public {\n        _TestTemps memory t = _testTemps();\n        vm.deal(t.owner, 1 ether);\n\n        ERC6551.Call[] memory calls = new ERC6551.Call[](2);\n        calls[0].target = address(new Target());\n        calls[1].target = address(new Target());\n        calls[0].value = 123;\n        calls[1].value = 456;\n        calls[0].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(111));\n        calls[1].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(222));\n\n        bytes memory data = LibZip.cdCompress(\n            abi.encodeWithSignature(\"executeBatch((address,uint256,bytes)[],uint8)\", calls, 0)\n        );\n        vm.prank(t.owner);\n        (bool success,) = address(t.account).call{value: 1 ether}(data);\n        assertTrue(success);\n        assertEq(Target(calls[0].target).datahash(), keccak256(_randomBytes(111)));\n        assertEq(Target(calls[1].target).datahash(), keccak256(_randomBytes(222)));\n        assertEq(calls[0].target.balance, 123);\n        assertEq(calls[1].target.balance, 456);\n    }\n\n    function testIsValidSigner(address signer) public {\n        _TestTemps memory t = _testTemps();\n        if (signer == t.owner) {\n            assertEq(t.account.isValidSigner(signer, _randomBytes(111)), bytes4(0x523e3260));\n        } else {\n            assertEq(t.account.isValidSigner(signer, _randomBytes(111)), bytes4(0x00000000));\n        }\n    }\n\n    function testIsValidSignature() public {\n        _TestTemps memory t = _testTemps();\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) =\n            vm.sign(t.privateKey, _toERC1271Hash(address(t.account), keccak256(\"123\")));\n\n        vm.prank(t.owner);\n        MockERC721(_erc721).safeTransferFrom(t.owner, t.signer, t.tokenId);\n\n        bytes32 hash = keccak256(\"123\");\n        bytes memory signature =\n            abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH, _DOMAIN_SEP_B, hash);\n        // Success returns `0x1626ba7e`.\n        assertEq(t.account.isValidSignature(_toChildHash(hash), signature), bytes4(0x1626ba7e));\n    }\n\n    function _toERC1271Hash(address account, bytes32 child) internal view returns (bytes32) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(\"Milady\"),\n                keccak256(\"1\"),\n                block.chainid,\n                address(account)\n            )\n        );\n        bytes32 parentStructHash =\n            keccak256(abi.encode(_PARENT_TYPEHASH, _toChildHash(child), child));\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, parentStructHash));\n    }\n\n    function _toChildHash(bytes32 child) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"1901\", _DOMAIN_SEP_B, child));\n    }\n\n    function _randomBytes(uint256 seed) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, seed)\n            let r := keccak256(0x00, 0x20)\n            if lt(byte(2, r), 0x20) {\n                result := mload(0x40)\n                let n := and(r, 0x7f)\n                mstore(result, n)\n                codecopy(add(result, 0x20), byte(1, r), add(n, 0x40))\n                mstore(0x40, add(add(result, 0x40), n))\n            }\n        }\n    }\n\n    function testUpdateState(uint256 seed) public {\n        bytes[] memory data = new bytes[](2);\n        if (_random() % 8 != 0) data[0] = _randomBytes(seed);\n        if (_random() % 8 != 0) data[1] = _randomBytes(~seed);\n\n        bytes32[] memory statesA = new bytes32[](2);\n        bytes32[] memory statesB = new bytes32[](2);\n\n        _TestTemps memory t = _testTemps();\n\n        t.account.somethingThatUpdatesState(data[0]);\n        statesA[0] = t.account.state();\n        t.account.somethingThatUpdatesState(data[1]);\n        statesA[1] = t.account.state();\n\n        vm.prank(t.owner);\n        t.account.upgradeToAndCall(_erc6551V2, \"\");\n\n        t.account.clearState();\n\n        t.account.somethingThatUpdatesState(data[0]);\n        statesB[0] = t.account.state();\n        t.account.somethingThatUpdatesState(data[1]);\n        statesB[1] = t.account.state();\n\n        assertEq(statesA, statesB);\n        assertTrue(statesA[0] != statesA[1]);\n    }\n}\n",
        "contractname": "ERC6551.sol"
    },
    {
        "input": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Receiver} from \"./Receiver.sol\";\nimport {LibZip} from \"../utils/LibZip.sol\";\nimport {Ownable} from \"../auth/Ownable.sol\";\nimport {UUPSUpgradeable} from \"../utils/UUPSUpgradeable.sol\";\nimport {SignatureCheckerLib, ERC1271} from \"../accounts/ERC1271.sol\";\n\n/// @notice Simple ERC4337 account implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\n/// @author Infinitism (https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol)\n///\n/// @dev Recommended usage:\n/// 1. Deploy the ERC4337 as an implementation contract, and verify it on Etherscan.\n/// 2. Create a factory that uses `LibClone.deployERC1967` or\n///    `LibClone.deployDeterministicERC1967` to clone the implementation.\n///    See: `ERC4337Factory.sol`.\n///\n/// Note:\n/// ERC4337 is a very complicated standard with many potential gotchas.\n/// Also, it is subject to change and has not been finalized\n/// (so accounts are encouraged to be upgradeable).\n/// Usually, ERC4337 account implementations are developed by companies with ample funds\n/// for security reviews. This implementation is intended to serve as a base reference\n/// for smart account developers working in such companies. If you are using this\n/// implementation, please do get one or more security reviews before deployment.\nabstract contract ERC4337 is Ownable, UUPSUpgradeable, Receiver, ERC1271 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The packed ERC4337 user operation (userOp) struct.\n    struct PackedUserOperation {\n        address sender;\n        uint256 nonce;\n        bytes initCode; // Factory address and `factoryData` (or empty).\n        bytes callData;\n        bytes32 accountGasLimits; // `verificationGas` (16 bytes) and `callGas` (16 bytes).\n        uint256 preVerificationGas;\n        bytes32 gasFees; // `maxPriorityFee` (16 bytes) and `maxFeePerGas` (16 bytes).\n        bytes paymasterAndData; // Paymaster fields (or empty).\n        bytes signature;\n    }\n\n    /// @dev Call struct for the `executeBatch` function.\n    struct Call {\n        address target;\n        uint256 value;\n        bytes data;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The function selector is not recognized.\n    error FnSelectorNotRecognized();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deploys this ERC4337 account implementation and disables initialization (see below).\n    constructor() payable {\n        _disableERC4337ImplementationInitializer();\n    }\n\n    /// @dev Automatically initializes the owner for the implementation. This blocks someone\n    /// from initializing the implementation and doing a delegatecall to SELFDESTRUCT.\n    /// Proxies to the implementation will still be able to initialize as per normal.\n    function _disableERC4337ImplementationInitializer() internal virtual {\n        // Note that `Ownable._guardInitializeOwner` has been and must be overridden\n        // to return true, to block double-initialization. We'll initialize to `address(1)`,\n        // so that it's easier to verify that the implementation has been initialized.\n        _initializeOwner(address(1));\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        INITIALIZER                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Initializes the account with the owner. Can only be called once.\n    function initialize(address newOwner) public payable virtual {\n        _initializeOwner(newOwner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        ENTRY POINT                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the canonical ERC4337 EntryPoint contract (0.7).\n    /// Override this function to return a different EntryPoint.\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   VALIDATION OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Validates the signature and nonce.\n    /// The EntryPoint will make the call to the recipient only if\n    /// this validation call returns successfully.\n    ///\n    /// Signature failure should be reported by returning 1 (see: `_validateSignature`).\n    /// This allows making a \"simulation call\" without a valid signature.\n    /// Other failures (e.g. nonce mismatch, or invalid signature format)\n    /// should still revert to signal failure.\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validationData)\n    {\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n    }\n\n    /// @dev Validate `userOp.signature` for the `userOpHash`.\n    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n        internal\n        virtual\n        returns (uint256 validationData)\n    {\n        bool success = SignatureCheckerLib.isValidSignatureNowCalldata(\n            owner(), SignatureCheckerLib.toEthSignedMessageHash(userOpHash), userOp.signature\n        );\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Returns 0 if the recovered address matches the owner.\n            // Else returns 1, which is equivalent to:\n            // `(success ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48))`\n            // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n            validationData := iszero(success)\n        }\n    }\n\n    /// @dev Override to validate the nonce of the userOp.\n    /// This method may validate the nonce requirement of this account.\n    /// e.g.\n    /// To limit the nonce to use sequenced userOps only (no \"out of order\" userOps):\n    ///      `require(nonce < type(uint64).max)`\n    /// For a hypothetical account that *requires* the nonce to be out-of-order:\n    ///      `require(nonce & type(uint64).max == 0)`\n    ///\n    /// The actual nonce uniqueness is managed by the EntryPoint, and thus no other\n    /// action is needed by the account itself.\n    function _validateNonce(uint256 nonce) internal virtual {\n        nonce = nonce; // Silence unused variable warning.\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    /// @dev Requires that the caller is the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) revert Unauthorized();\n        _;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    EXECUTION OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Execute a call from this account.\n    function execute(address target, uint256 value, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a sequence of calls from this account.\n    function executeBatch(Call[] calldata calls)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes[] memory results)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    function delegateExecute(address delegate, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        delegateExecuteGuard\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Ensures that the owner and implementation slots' values aren't changed.\n    /// You can override this modifier to ensure the sanctity of other storage slots too.\n    modifier delegateExecuteGuard() virtual {\n        bytes32 ownerSlotValue;\n        bytes32 implementationSlotValue;\n        /// @solidity memory-safe-assembly\n        assembly {\n            implementationSlotValue := sload(_ERC1967_IMPLEMENTATION_SLOT)\n            ownerSlotValue := sload(_OWNER_SLOT)\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(\n                and(\n                    eq(implementationSlotValue, sload(_ERC1967_IMPLEMENTATION_SLOT)),\n                    eq(ownerSlotValue, sload(_OWNER_SLOT))\n                )\n            ) { revert(codesize(), 0x00) }\n        }\n    }\n\n    /// @dev Requires that the caller is the EntryPoint, the owner, or the account itself.\n    modifier onlyEntryPointOrOwner() virtual {\n        if (msg.sender != entryPoint()) _checkOwner();\n        _;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                 DIRECT STORAGE OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the raw storage value at `storageSlot`.\n    function storageLoad(bytes32 storageSlot) public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(storageSlot)\n        }\n    }\n\n    /// @dev Writes the raw storage value at `storageSlot`.\n    function storageStore(bytes32 storageSlot, bytes32 storageValue)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        storageStoreGuard(storageSlot)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(storageSlot, storageValue)\n        }\n    }\n\n    /// @dev Ensures that the `storageSlot` is not prohibited for direct storage writes.\n    /// You can override this modifier to ensure the sanctity of other storage slots too.\n    modifier storageStoreGuard(bytes32 storageSlot) virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if or(eq(storageSlot, _OWNER_SLOT), eq(storageSlot, _ERC1967_IMPLEMENTATION_SLOT)) {\n                revert(codesize(), 0x00)\n            }\n        }\n        _;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     DEPOSIT OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the account's balance on the EntryPoint.\n    function getDeposit() public view virtual returns (uint256 result) {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, address()) // Store the `account` argument.\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            result :=\n                mul( // Returns 0 if the EntryPoint does not exist.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), ep, 0x1c, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Deposit more funds for this account in the EntryPoint.\n    function addDeposit() public payable virtual {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The EntryPoint has balance accounting logic in the `receive()` function.\n            // forgefmt: disable-next-item\n            if iszero(mul(extcodesize(ep), call(gas(), ep, callvalue(), codesize(), 0x00, codesize(), 0x00))) {\n                revert(codesize(), 0x00) // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Withdraw ETH from the account's deposit on the EntryPoint.\n    function withdrawDepositTo(address to, uint256 amount) public payable virtual onlyOwner {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\n            if iszero(mul(extcodesize(ep), call(gas(), ep, 0, 0x10, 0x44, codesize(), 0x00))) {\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OVERRIDES                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Requires that the caller is the owner or the account itself.\n    /// This override affects the `onlyOwner` modifier.\n    function _checkOwner() internal view virtual override(Ownable) {\n        if (msg.sender != owner()) if (msg.sender != address(this)) revert Unauthorized();\n    }\n\n    /// @dev To prevent double-initialization (reuses the owner storage slot for efficiency).\n    function _guardInitializeOwner() internal pure virtual override(Ownable) returns (bool) {\n        return true;\n    }\n\n    /// @dev Uses the `owner` as the ERC1271 signer.\n    function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }\n\n    /// @dev To ensure that only the owner or the account itself can upgrade the implementation.\n    function _authorizeUpgrade(address) internal virtual override(UUPSUpgradeable) onlyOwner {}\n\n    /// @dev If you don't need to use `LibZip.cdFallback`, override this function to return false.\n    function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Handle token callbacks. If no token callback is triggered,\n    /// use `LibZip.cdFallback` for generalized calldata decompression.\n    fallback() external payable virtual override(Receiver) receiverFallback {\n        if (_useLibZipCdFallback()) {\n            // Reverts with out-of-gas by recursing infinitely if the first 4 bytes\n            // of the decompressed `msg.data` doesn't match any function selector.\n            LibZip.cdFallback();\n        } else {\n            revert FnSelectorNotRecognized();\n        }\n    }\n}\n",
        "output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./utils/SoladyTest.sol\";\nimport {Ownable, SignatureCheckerLib} from \"../src/accounts/ERC4337.sol\";\nimport {ERC4337, MockERC4337} from \"./utils/mocks/MockERC4337.sol\";\nimport {MockEntryPoint} from \"./utils/mocks/MockEntryPoint.sol\";\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\nimport {MockERC1271Wallet} from \"./utils/mocks/MockERC1271Wallet.sol\";\nimport {LibClone} from \"../src/utils/LibClone.sol\";\nimport {LibString} from \"../src/utils/LibString.sol\";\nimport {LibZip} from \"../src/utils/LibZip.sol\";\n\ncontract Target {\n    error TargetError(bytes data);\n\n    bytes32 public datahash;\n\n    bytes public data;\n\n    function setData(bytes memory data_) public payable returns (bytes memory) {\n        data = data_;\n        datahash = keccak256(data_);\n        return data_;\n    }\n\n    function revertWithTargetError(bytes memory data_) public payable {\n        revert TargetError(data_);\n    }\n\n    function changeOwnerSlotValue(bool change) public payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if change { sstore(not(0x8b78c6d8), 0x112233) }\n        }\n    }\n}\n\ncontract ERC4337Test is SoladyTest {\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    // By right, this should be the keccak256 of some long-ass string:\n    // (e.g. `keccak256(\"Parent(bytes32 childHash,Mail child)Mail(Person from,Person to,string contents)Person(string name,address wallet)\")`).\n    // But I'm lazy and will use something randomish here.\n    bytes32 internal constant _PARENT_TYPEHASH =\n        0xd61db970ec8a2edc5f9fd31d876abe01b785909acb16dcd4baaf3b434b4c439b;\n\n    // By right, this should be a proper domain separator, but I'm lazy.\n    bytes32 internal constant _DOMAIN_SEP_B =\n        0xa1a044077d7677adbbfa892ded5390979b33993e0e2a457e3f974bbcda53821b;\n\n    address internal constant _ENTRY_POINT = 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n\n    address erc4337;\n\n    MockERC4337 account;\n\n    function setUp() public {\n        // Etch something onto `_ENTRY_POINT` such that we can deploy the account implementation.\n        vm.etch(_ENTRY_POINT, hex\"00\");\n        erc4337 = address(new MockERC4337());\n        account = MockERC4337(payable(LibClone.deployERC1967(erc4337)));\n    }\n\n    function testDisableInitializerForImplementation() public {\n        MockERC4337 mock = new MockERC4337();\n        assertEq(mock.owner(), address(1));\n        vm.expectRevert(Ownable.AlreadyInitialized.selector);\n        mock.initialize(address(this));\n    }\n\n    function testInitializer() public {\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(0), address(this));\n        account.initialize(address(this));\n        assertEq(account.owner(), address(this));\n        vm.expectRevert(Ownable.AlreadyInitialized.selector);\n        account.initialize(address(this));\n\n        address newOwner = _randomNonZeroAddress();\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), newOwner);\n        account.transferOwnership(newOwner);\n        assertEq(account.owner(), newOwner);\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(newOwner, address(this));\n        vm.prank(newOwner);\n        account.transferOwnership(address(this));\n\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(this), address(0));\n        account.renounceOwnership();\n        assertEq(account.owner(), address(0));\n\n        vm.expectRevert(Ownable.AlreadyInitialized.selector);\n        account.initialize(address(this));\n        assertEq(account.owner(), address(0));\n\n        account = MockERC4337(payable(LibClone.deployERC1967(erc4337)));\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(0), address(0));\n        account.initialize(address(0));\n        assertEq(account.owner(), address(0));\n\n        vm.expectRevert(Ownable.AlreadyInitialized.selector);\n        account.initialize(address(this));\n        assertEq(account.owner(), address(0));\n\n        account = MockERC4337(payable(LibClone.deployERC1967(erc4337)));\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(address(0), address(1));\n        account.initialize(address(1));\n        assertEq(account.owner(), address(1));\n\n        vm.expectRevert(Ownable.AlreadyInitialized.selector);\n        account.initialize(address(this));\n        assertEq(account.owner(), address(1));\n    }\n\n    function testExecute() public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        address target = address(new Target());\n        bytes memory data = _randomBytes(111);\n        account.execute(target, 123, abi.encodeWithSignature(\"setData(bytes)\", data));\n        assertEq(Target(target).datahash(), keccak256(data));\n        assertEq(target.balance, 123);\n\n        vm.prank(_randomNonZeroAddress());\n        vm.expectRevert(Ownable.Unauthorized.selector);\n        account.execute(target, 123, abi.encodeWithSignature(\"setData(bytes)\", data));\n\n        vm.expectRevert(abi.encodeWithSignature(\"TargetError(bytes)\", data));\n        account.execute(target, 123, abi.encodeWithSignature(\"revertWithTargetError(bytes)\", data));\n    }\n\n    function testExecuteBatch() public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        ERC4337.Call[] memory calls = new ERC4337.Call[](2);\n        calls[0].target = address(new Target());\n        calls[1].target = address(new Target());\n        calls[0].value = 123;\n        calls[1].value = 456;\n        calls[0].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(111));\n        calls[1].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(222));\n\n        account.executeBatch(calls);\n        assertEq(Target(calls[0].target).datahash(), keccak256(_randomBytes(111)));\n        assertEq(Target(calls[1].target).datahash(), keccak256(_randomBytes(222)));\n        assertEq(calls[0].target.balance, 123);\n        assertEq(calls[1].target.balance, 456);\n\n        calls[1].data = abi.encodeWithSignature(\"revertWithTargetError(bytes)\", _randomBytes(111));\n        vm.expectRevert(abi.encodeWithSignature(\"TargetError(bytes)\", _randomBytes(111)));\n        account.executeBatch(calls);\n    }\n\n    function testExecuteBatch(uint256 r) public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        unchecked {\n            uint256 n = r & 3;\n            ERC4337.Call[] memory calls = new ERC4337.Call[](n);\n\n            for (uint256 i; i != n; ++i) {\n                uint256 v = _random() & 0xff;\n                calls[i].target = address(new Target());\n                calls[i].value = v;\n                calls[i].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(v));\n            }\n\n            bytes[] memory results;\n            if (_random() & 1 == 0) {\n                results = account.executeBatch(_random(), calls);\n            } else {\n                results = account.executeBatch(calls);\n            }\n\n            assertEq(results.length, n);\n            for (uint256 i; i != n; ++i) {\n                uint256 v = calls[i].value;\n                assertEq(Target(calls[i].target).datahash(), keccak256(_randomBytes(v)));\n                assertEq(calls[i].target.balance, v);\n                assertEq(abi.decode(results[i], (bytes)), _randomBytes(v));\n            }\n        }\n    }\n\n    function testDelegateExecute() public {\n        testDelegateExecute(123);\n    }\n\n    function testDelegateExecute(uint256 r) public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        address delegate = address(new Target());\n\n        bytes memory data;\n        data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(r));\n        data = account.delegateExecute(delegate, data);\n        assertEq(abi.decode(data, (bytes)), _randomBytes(r));\n        data = account.delegateExecute(delegate, abi.encodeWithSignature(\"datahash()\"));\n        assertEq(abi.decode(data, (bytes32)), keccak256(_randomBytes(r)));\n        data = account.delegateExecute(delegate, abi.encodeWithSignature(\"data()\"));\n        assertEq(abi.decode(data, (bytes)), _randomBytes(r));\n    }\n\n    function testDelegateExecuteRevertsIfOwnerSlotValueChanged() public {\n        account.initialize(address(this));\n\n        address delegate = address(new Target());\n\n        bytes memory data;\n        data = abi.encodeWithSignature(\"changeOwnerSlotValue(bool)\", false);\n        account.delegateExecute(delegate, data);\n        vm.expectRevert();\n        data = abi.encodeWithSignature(\"changeOwnerSlotValue(bool)\", true);\n        account.delegateExecute(delegate, data);\n        data = abi.encodeWithSignature(\"changeOwnerSlotValue(bool)\", false);\n        account.delegateExecute(delegate, data);\n    }\n\n    function testDepositFunctions() public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        vm.etch(account.entryPoint(), address(new MockEntryPoint()).code);\n        assertEq(account.getDeposit(), 0);\n        account.addDeposit{value: 123}();\n        assertEq(account.getDeposit(), 123);\n        address to = _randomNonZeroAddress();\n        assertEq(to.balance, 0);\n        account.withdrawDepositTo(to, 12);\n        assertEq(to.balance, 12);\n        assertEq(account.getDeposit(), 123 - 12);\n    }\n\n    function testCdFallback() public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        vm.etch(account.entryPoint(), address(new MockEntryPoint()).code);\n        assertEq(account.getDeposit(), 0);\n\n        bytes memory data = LibZip.cdCompress(abi.encodeWithSignature(\"addDeposit()\"));\n        (bool success,) = address(account).call{value: 123}(data);\n        assertTrue(success);\n        assertEq(account.getDeposit(), 123);\n    }\n\n    function testCdFallback2() public {\n        vm.deal(address(account), 1 ether);\n        account.initialize(address(this));\n\n        vm.etch(account.entryPoint(), address(new MockEntryPoint()).code);\n        assertEq(account.getDeposit(), 0);\n\n        ERC4337.Call[] memory calls = new ERC4337.Call[](2);\n        calls[0].target = address(new Target());\n        calls[1].target = address(new Target());\n        calls[0].value = 123;\n        calls[1].value = 456;\n        calls[0].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(111));\n        calls[1].data = abi.encodeWithSignature(\"setData(bytes)\", _randomBytes(222));\n\n        bytes memory data = LibZip.cdCompress(\n            abi.encodeWithSignature(\"executeBatch((address,uint256,bytes)[])\", calls)\n        );\n        (bool success,) = address(account).call(data);\n        assertTrue(success);\n        assertEq(Target(calls[0].target).datahash(), keccak256(_randomBytes(111)));\n        assertEq(Target(calls[1].target).datahash(), keccak256(_randomBytes(222)));\n        assertEq(calls[0].target.balance, 123);\n        assertEq(calls[1].target.balance, 456);\n    }\n\n    struct _TestTemps {\n        bytes32 userOpHash;\n        bytes32 hash;\n        address signer;\n        uint256 privateKey;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 missingAccountFunds;\n    }\n\n    function testValidateUserOp() public {\n        _TestTemps memory t;\n        t.userOpHash = keccak256(\"123\");\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) =\n            vm.sign(t.privateKey, SignatureCheckerLib.toEthSignedMessageHash(t.userOpHash));\n        t.missingAccountFunds = 456;\n        vm.deal(address(account), 1 ether);\n        assertEq(address(account).balance, 1 ether);\n\n        account.initialize(t.signer);\n\n        vm.etch(account.entryPoint(), address(new MockEntryPoint()).code);\n        MockEntryPoint ep = MockEntryPoint(payable(account.entryPoint()));\n\n        ERC4337.PackedUserOperation memory userOp;\n        // Success returns 0.\n        userOp.signature = abi.encodePacked(t.r, t.s, t.v);\n        assertEq(\n            ep.validateUserOp(address(account), userOp, t.userOpHash, t.missingAccountFunds), 0\n        );\n        assertEq(address(ep).balance, t.missingAccountFunds);\n        // Failure returns 1.\n        userOp.signature = abi.encodePacked(t.r, bytes32(uint256(t.s) ^ 1), t.v);\n        assertEq(\n            ep.validateUserOp(address(account), userOp, t.userOpHash, t.missingAccountFunds), 1\n        );\n        assertEq(address(ep).balance, t.missingAccountFunds * 2);\n        // Not entry point reverts.\n        vm.expectRevert(Ownable.Unauthorized.selector);\n        account.validateUserOp(userOp, t.userOpHash, t.missingAccountFunds);\n    }\n\n    function testIsValidSignature() public {\n        vm.txGasPrice(10);\n        _TestTemps memory t;\n        t.hash = keccak256(\"123\");\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) = vm.sign(t.privateKey, _toERC1271Hash(t.hash));\n\n        account.initialize(t.signer);\n\n        bytes memory signature =\n            abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH, _DOMAIN_SEP_B, t.hash);\n        assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0x1626ba7e));\n\n        unchecked {\n            uint256 vs = uint256(t.s) | uint256(t.v - 27) << 255;\n            signature = abi.encodePacked(t.r, vs, _PARENT_TYPEHASH, _DOMAIN_SEP_B, t.hash);\n            assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0x1626ba7e));\n        }\n\n        signature =\n            abi.encodePacked(t.r, t.s, t.v, uint256(_PARENT_TYPEHASH) ^ 1, _DOMAIN_SEP_B, t.hash);\n        assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0xffffffff));\n\n        signature =\n            abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH, uint256(_DOMAIN_SEP_B) ^ 1, t.hash);\n        assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0xffffffff));\n\n        signature =\n            abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH, _DOMAIN_SEP_B, uint256(t.hash) ^ 1);\n        assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, t.s, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = \"\";\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n    }\n\n    function testIsValidSignaturePersonalSign() public {\n        vm.txGasPrice(10);\n        _TestTemps memory t;\n        t.hash = keccak256(\"123\");\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) = vm.sign(t.privateKey, _toERC1271HashPersonalSign(t.hash));\n\n        account.initialize(t.signer);\n\n        bytes memory signature = abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0x1626ba7e));\n\n        unchecked {\n            uint256 vs = uint256(t.s) | uint256(t.v - 27) << 255;\n            signature = abi.encodePacked(t.r, vs, _PARENT_TYPEHASH);\n            assertEq(account.isValidSignature(t.hash, signature), bytes4(0x1626ba7e));\n        }\n\n        signature = abi.encodePacked(t.r, t.s, _PARENT_TYPEHASH, _DOMAIN_SEP_B, t.hash);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, t.s, _PARENT_TYPEHASH, _DOMAIN_SEP_B);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, t.s, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = abi.encodePacked(t.r, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        signature = \"\";\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n    }\n\n    function testIsValidSignatureViaRPC() public {\n        vm.txGasPrice(10);\n        _TestTemps memory t;\n        t.hash = keccak256(\"123\");\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) = vm.sign(t.privateKey, t.hash);\n\n        account.initialize(t.signer);\n\n        bytes memory signature = abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        vm.txGasPrice(1);\n        assertEq(account.isValidSignature(t.hash, signature), bytes4(0xffffffff));\n\n        vm.txGasPrice(0);\n        vm.expectRevert();\n        account.isValidSignature(t.hash, signature);\n\n        // Unfortunately, I don't know of a way to make Foundry simulate a call with `gas > gaslimit`.\n        // But we can be sure that most RPCs will do that.\n        // See: https://sepolia.etherscan.io/address/0x4f55bb26d7195babf9f8144bdc4ae4dd919c746d#code\n    }\n\n    function testIsValidSignatureWrapped() public {\n        _TestTemps memory t;\n        t.hash = keccak256(\"123\");\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) = vm.sign(t.privateKey, _toERC1271Hash(t.hash));\n\n        MockERC1271Wallet wrappedSigner = new MockERC1271Wallet(t.signer);\n        account.initialize(address(wrappedSigner));\n\n        bytes memory signature =\n            abi.encodePacked(t.r, t.s, t.v, _PARENT_TYPEHASH, _DOMAIN_SEP_B, t.hash);\n        assertEq(account.isValidSignature(_toChildHash(t.hash), signature), bytes4(0x1626ba7e));\n    }\n\n    function _toERC1271Hash(bytes32 child) internal view returns (bytes32) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(\"Milady\"),\n                keccak256(\"1\"),\n                block.chainid,\n                address(account)\n            )\n        );\n        bytes32 parentStructHash =\n            keccak256(abi.encode(_PARENT_TYPEHASH, _toChildHash(child), child));\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, parentStructHash));\n    }\n\n    function _toChildHash(bytes32 child) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"1901\", _DOMAIN_SEP_B, child));\n    }\n\n    function _toERC1271HashPersonalSign(bytes32 childHash) internal view returns (bytes32) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(\"Milady\"),\n                keccak256(\"1\"),\n                block.chainid,\n                address(account)\n            )\n        );\n        bytes32 parentStructHash = keccak256(abi.encode(_PARENT_TYPEHASH, childHash));\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, parentStructHash));\n    }\n\n    function testETHReceived() public {\n        (bool success,) = address(account).call{value: 1 ether}(\"\");\n        assertTrue(success);\n    }\n\n    function testOnERC721Received() public {\n        address alice = _randomNonZeroAddress();\n        MockERC721 erc721 = new MockERC721();\n        erc721.mint(alice, 1);\n        vm.prank(alice);\n        erc721.safeTransferFrom(alice, address(account), 1);\n    }\n\n    function testOnERC1155Received() public {\n        address alice = _randomNonZeroAddress();\n        MockERC1155 erc1155 = new MockERC1155();\n        erc1155.mint(alice, 1, 1, \"\");\n        vm.prank(alice);\n        erc1155.safeTransferFrom(alice, address(account), 1, 1, \"\");\n    }\n\n    function testOnERC1155BatchReceived() public {\n        address alice = _randomNonZeroAddress();\n        MockERC1155 erc1155 = new MockERC1155();\n        erc1155.mint(alice, 1, 1, \"\");\n        uint256[] memory ids = new uint256[](1);\n        ids[0] = 1;\n        uint256[] memory amts = new uint256[](1);\n        amts[0] = 1;\n        vm.prank(alice);\n        erc1155.safeBatchTransferFrom(alice, address(account), ids, amts, \"\");\n    }\n\n    function testDirectStorage() public {\n        bytes32 storageSlot = bytes32(uint256(123));\n        bytes32 storageValue = bytes32(uint256(456));\n\n        vm.expectRevert(Ownable.Unauthorized.selector);\n        account.storageStore(storageSlot, storageValue);\n\n        account.initialize(address(this));\n        assertEq(account.storageLoad(storageSlot), bytes32(0));\n        account.storageStore(storageSlot, storageValue);\n        assertEq(account.storageLoad(storageSlot), storageValue);\n    }\n\n    function testOwnerRecovery() public {\n        ERC4337.PackedUserOperation memory userOp;\n\n        userOp.sender = address(account);\n        userOp.nonce = 4337;\n\n        // `bob` is set as recovery.\n        address bob = address(0xb);\n        userOp.callData = abi.encodeWithSelector(\n            ERC4337.execute.selector,\n            address(account),\n            0,\n            abi.encodeWithSelector(Ownable.completeOwnershipHandover.selector, bob)\n        );\n\n        // `bob` must accept recovery.\n        // IRL this would follow need.\n        vm.prank(bob);\n        account.requestOwnershipHandover();\n\n        _TestTemps memory t;\n        t.userOpHash = keccak256(abi.encode(userOp));\n        (t.signer, t.privateKey) = _randomSigner();\n        (t.v, t.r, t.s) =\n            vm.sign(t.privateKey, SignatureCheckerLib.toEthSignedMessageHash(t.userOpHash));\n\n        t.missingAccountFunds = 456;\n        vm.deal(address(account), 1 ether);\n\n        account.initialize(t.signer);\n        assertEq(account.owner(), t.signer);\n\n        vm.etch(account.entryPoint(), address(new MockEntryPoint()).code);\n        MockEntryPoint ep = MockEntryPoint(payable(account.entryPoint()));\n\n        // Success returns 0.\n        userOp.signature = abi.encodePacked(t.r, t.s, t.v);\n        assertEq(\n            ep.validateUserOp(address(account), userOp, t.userOpHash, t.missingAccountFunds), 0\n        );\n        // Check recovery to `bob`.\n        vm.prank(address(ep));\n        (bool success,) = address(account).call(userOp.callData);\n        assertTrue(success);\n        assertEq(account.owner(), bob);\n    }\n\n    function _randomBytes(uint256 seed) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, seed)\n            let r := keccak256(0x00, 0x20)\n            if lt(byte(2, r), 0x20) {\n                result := mload(0x40)\n                let n := and(r, 0x7f)\n                mstore(result, n)\n                codecopy(add(result, 0x20), byte(1, r), add(n, 0x40))\n                mstore(0x40, add(add(result, 0x40), n))\n            }\n        }\n    }\n}\n",
        "contractname": "ERC4337.sol"
    }
]